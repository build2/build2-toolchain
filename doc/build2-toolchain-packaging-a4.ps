%!PS
%%Title: The build2 Packaging Guide
%%Creator: html2ps version 1.0 beta7
%%EndComments
save
2000 dict begin
/d {bind def} bind def
/D {def} d
/t true D
/f false D
/FL [/Times-Roman
/Times-Italic
/Times-Bold
/Times-BoldItalic
/Courier
/Courier-Oblique
/Courier-Bold
/Courier-BoldOblique
/Helvetica
/Helvetica-Oblique
/Helvetica-Bold
/Helvetica-BoldOblique] D
/WF t D
/WI 0 D
/F 1 D
/IW 454 F div D
/IL 672 F div D
/PS 842 D
/EF [0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 2 2] D
/EZ [12 9 19 17 15 13 12 11 12 12 12 12 12 12 12 12 12 12 12 12 12 12 8 8] D
/Ey [0 0 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] D
/EG [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1] D
/Tm [1 1 0.8 0.8 0.8 0.8 0.8 0.8 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1.3 0 0] D
/Bm [1 1 0.5 0.5 0.5 0.5 0.5 0.5 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1 0 0] D
/Lm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 2 0 0 0] D
/Rm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0] D
/EU [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 0 0] D
/NO f D
/YY [[{()}{ h }][{ h }{()}][{()}{()}]] D
/ZZ [[{ (Revision ) ME 0 get join(, May 2025)join }{ Pn }][{ Pn }{ (Revision ) ME 0 get join(, May 2025)join }][{ Ti }{ Ti }]] D
/Ts EZ 0 get D
/TU f D
/Xp t D
/AU f D
/SN 0 D
/Cf t D
/Tp t D
/Fe f D
/TI 2 Ts mul D
/Fm 14 D
/xL 71 D
/xR 71 D
/yL 757 D
/yR 757 D
/Wl 454 F div D
/Wr 454 F div D
/hL 672 F div D
/hR 672 F div D
/FE {newpath Fm neg Fm M CP BB IW Fm add Fm L IW Fm add IL Fm add neg L CP BB
 Fm neg IL Fm add neg L closepath} D
/LA {PM 0 eq{/IW Wl D /IL hL D}{/IW Wr D /IL hR D}ie /W IW D /LL W D /LS W D
 TU PM 0 eq and{IW 56 F div add SA{Sf div}if 0 translate}
 {PM 0 eq{xL yL}{xR yR}ie translate F SA{Sf mul}if dup scale
 CS CF FS Cf{CA CL get VC}if /Bb f D}ie 0 0 M
 TF not Tc or {Cf{gsave SA{1 Sf div dup scale}if Cb VC FE fill grestore}if}if}D
/Pi 0 Ts mul D
/SG [0.8 1 1] D
/Ab 15 D
/J 0 D
/Tc t D
/NH 6 D
/Nf f D
/Pa f D
/LH 1.2 D
/XR f D
/Xr {/pN E D ( [p ) WB pN WB (] )WB} D
/Db [16#FF 16#FF 16#FF] D
/Dt [16#00 16#00 16#00] D
/eA f D
/Fi f D
/bT f D
/Lc t D
/Dl [16#00 16#00 16#00] D
/LX f D
/Br 0.25 D
/IA ([IMAGE]) D
/DS {/PF f D()WB NL NP()pop RC ZF} D
/Gb f D
/Mb t D
/Hc [16#00 16#00 16#00] D
/Bl 3 D
/MI -15.6 D
/DX (DRAFT) D
/Di 0 D
/Tt 113.385826771654 D
/Th { (
) 2 Al()BR (
  ) 0 1 -1 H()4 FZ (The ) SM (build2) ES ( ) ME 1 get join ES()EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
) Ea()BR (
  ) 0 P (Copyright © ) ME 2 get join(.)join BR (  Permission is granted to copy, distribute and/or modify this document under
  the terms of the MIT License.) EP (

  ) 0 P (Revision ) SM() ME 0 get join ES (, May 2025) BR (  This revision of the document describes the ) SM (build2) ES ( ) ME 3 get join(
  )join SM() ME 0 get join(.x)join ES ( series.) EP()} D
/tH {()0 1 -1 H (Table of Contents) EH()} D
/FD 2 D
/Dy 2 D
/cD [16#F0 16#F0 16#F0] D
/FW 0.6 D
/FU [16#00 16#00 16#00] D
/ET {/RM f D /A0 3 D /PN SN D /OU t D /Ou t D /W IW D /LL W D D1
 Ms not TP and{Ip}if /TF f D} D

%-- End of variable part --
/MySymbol 10 dict dup begin
 /FontType 3 D /FontMatrix [.001 0 0 .001 0 0 ] D /FontBBox [25 -10 600 600] D
 /Encoding 256 array D 0 1 255{Encoding exch /.notdef put}for
 Encoding (e) 0 get /euro put
 /Metrics 2 dict D Metrics begin
  /.notdef 0 D
  /euro 651 D
 end
 /BBox 2 dict D BBox begin
  /.notdef [0 0 0 0] D
  /euro [25 -10 600 600] D
 end
 /CharacterDefs 2 dict D CharacterDefs begin
  /.notdef {} D
  /euro{newpath 114 600 moveto 631 600 lineto 464 200 lineto 573 200 lineto
   573 0 lineto -94 0 lineto 31 300 lineto -10 300 lineto closepath clip
   50 setlinewidth newpath 656 300 moveto 381 300 275 0 360 arc stroke
   -19 350 moveto 600 0 rlineto -19 250 moveto 600 0 rlineto stroke}d
 end
 /BuildChar{0 begin
  /char E D /fontdict E D /charname fontdict /Encoding get char get D
  fontdict begin
   Metrics charname get 0 BBox charname get aload pop setcachedevice
   CharacterDefs charname get exec
  end
 end}D
 /BuildChar load 0 3 dict put /UniqueID 1 D
end
definefont pop

/Cd {aload length 2 idiv dup dict begin {D} repeat currentdict end} D
/EX {EC cvx exec} D
/DU {} d
/BB {pop pop}d
/ie {ifelse} d
/E {exch} d
/M {moveto} d
/R {rmoveto} d
/L {lineto} d
/RL {rlineto} d
/CP {currentpoint} d
/SW {stringwidth} d
/GI {getinterval} d
/PI {putinterval} d
/Sg {setgray} d
/LW {setlinewidth} d
/S {dup () ne OU and{0 Co R AT 3 eq LB and HF not and A1 0 ne A2 0 ne or and
 {A2 0 32 A1 0 6 -1 roll awidthshow}{show}ie 0 Co neg R}{pop}ie
 OU PH 3 eq or{/Ms t D}if} D
/U {OU{gsave CP currentfont /FontInfo get /UnderlinePosition get
 0 E currentfont /FontMatrix get dtransform E pop add newpath M dup SW pop
 CJ 0 RL stroke grestore}if} D
/B {OU Br 0 gt and{CP Ts neg Ts .33 mul R gsave 0 Sg
 CP newpath Ts Br mul 0 360 arc closepath UI 2 mod 0 eq{stroke}{fill}ie
 grestore M CP E Ts Br 1 add mul sub E BB /Ms t D}if}D
/NP {Ms TP not or PA and OU and{TP{OR}if f1{mF k2 /mF E D /YC 0 D}if
 TP TU not PM 0 eq or and{showpage}if DU Ip TE not{LA}if 0.6 LW
 /CI 0 D /TP t D /Hs f D /hl 6 D /Hv 6 D /HI hi D /Ms f D}if Bs XO BO M} D
/Np {LE sub CP E pop gt PL 0 eq and{NP}if}D
/Ip {/PN PN 1 add D /Pn RM{1}{4}ie PN Ns D /PM PN SN sub 2 mod D} D
/GP {E dup 3 -1 roll get PN 1 add 2 mod get dup type /integertype eq
 {get 0 get}{E pop}ie}d
/Fc {dup 2 GP exec SW pop /S1 E D dup 1 GP exec SW pop /S2 E D 0 GP exec SW
 pop /S3 E D S1 0 gt{S2 2 mul S1 add S3 2 mul S1 add 2 copy lt{E}if pop}{0}ie
 S2 S3 add 2 copy lt{E}if pop IW .9 mul div dup 1 gt{1 E div}{pop 1}ie}D
/OR {Df{Sd}if tp not{gsave SA{1 Sf div dup scale}if Fe{Cf{FU VC}if FW LW
 1 setlinejoin FE stroke}if /YO {60 F div dup 40 gt{pop 40}if}D /cs CS D
 /cf CF D /CF 0 D /pf PF D /PF f D /Fn FN D /At AT D /AT 0 D /FN EF Hf 1 add
 get D Fz Fs FS ZZ Fc Fz mul Fs FS EU Hf 1 add get dup type /arraytype eq
 Cf and{VC}{pop 0 Sg}ie IW IL neg YO sub M ZZ 1 GP exec dup SW pop neg 0 R Sh
 0 IL neg YO sub M ZZ 0 GP exec Sh ZZ 2 GP exec dup SW pop IW E sub 2 div
 IL neg YO sub M Sh Fz Fs FS NO{/AW IW Pn SW pop sub D AW 2 div IL neg YO sub
 S1 0 gt S2 AW .45 mul gt or S3 AW .45 mul gt or{Fz 2 mul sub}if M Pn Sh}if
 EU Hf get dup type /arraytype eq Cf and{VC}{pop 0 Sg}ie YY Fc /FN EF Hf get D
 Hz mul HS FS IW YO M YY 1 GP exec dup SW pop neg 0 R Sh 0 YO M YY 0 GP exec Sh
 YY 2 GP exec dup SW pop IW E sub 2 div YO M Sh /FN Fn D /AT At D t Pb XO SZ
 SL get neg R /PF pf D grestore /CF 0 D cs cf FS}if}D
/Sh {dup () ne{CP Hz 4 div sub BB show CP CS add BB}{pop}ie}D
/Pb {/OU E D /Ou OU D /PB t D 0 0 M Ba{/Sa save D /BP t D /Fl t D RC /PL 0 D
 /PH 0 D /W IW D /LE IL .7 mul D /EO 0 D SI ZF /YA 0 D /BO 0 D /C1 () D
 BA 0 Ts neg R Bb{Xl Yl Xh Yh}if Bb CP Sa restore M
 {/Yh E D /Xh E D /Yl E D /Xl E D}if /Fl t D}if
 BL /OU t D /HM f D /Ou t D /PB f D} D
/Bs {/BP Ba not D}D
/reencodeISO {
 dup dup findfont dup length dict begin{1 index /FID ne{D}{pop pop}ie}forall
 /Encoding ISOLatin1Encoding D currentdict end definefont} D
/ISOLatin1Encoding [
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash
/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/space/exclamdown/cent/sterling/currency/yen/brokenbar
/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
/guillemotright/onequarter/onehalf/threequarters/questiondown
/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
/yacute/thorn/ydieresis
] D
[128/backslash 129/parenleft 130/parenright 141/circumflex 142/tilde
143/perthousand 144/dagger 145/daggerdbl 146/Ydieresis 147/scaron 148/Scaron
149/oe 150/OE 151/guilsinglleft 152/guilsinglright 153/quotesinglbase
154/quotedblbase 155/quotedblleft 156/quotedblright 157/endash 158/emdash
159/trademark]
aload length 2 idiv 1 1 3 -1 roll{pop ISOLatin1Encoding 3 1 roll put}for
/colorimage where{pop}{
 /colorimage {
  pop pop /Pr E D {/Cv Pr D /Gr Cv length 3 idiv string D 0 1 Gr length 1 sub
   {Gr E dup /i E 3 mul D Cv i get 0.299 mul Cv i 1 add get 0.587 mul add
    Cv i 2 add get 0.114 mul add cvi put}for Gr} image} D
}ie
/pdfmark where{pop}{userdict /pdfmark /cleartomark load put}ie
WF{FL{reencodeISO D}forall}{4 1 FL length 1 sub{FL E get reencodeISO D}for}ie
/Symbol dup dup findfont dup length dict begin
 {1 index /FID ne{D}{pop pop}ie}forall /Encoding [Encoding aload pop]
 dup 128 /therefore put D currentdict end definefont D

/SF {/CS E D SZ SL CS put FO SL FN put /YI CS LH neg mul D dup ST cvs ( ) join
 CS ST cvs join C1 E join ( NF ) join /C1 E D CS NF /Wf WF FN 0 gt or D
 /BW Wf{( ) SW pop}{0}ie D}D
/NF {/cS E D /cF E D cF 0 ge{FL cF get}{cF -1 eq{/Symbol}{/MySymbol}ie}ie
 findfont cS scalefont setfont} D
/FS {CF or /CF E D FR SL CF put CF CF 0 ge{FN 4 mul add}if E SF} D
/PC {SH /BP f D fin not GL not and{NL}if /HM t D /LL LS D} D
/BS {/TX E D Wf{/fin f D /CW 0 D /LK 0 D /SC 0 D
 /RT TX D {RT ( ) search{/NW E D pop /RT E D /WH NW SW pop D CW WH add LL gt
 {TX SC LK SC sub 1 sub NN GI GL{SH cF cS OC
 2 copy cS ne E cF ne or{NF}{pop pop}ie}{PC /CW WH BW add D}ie
 /SC LK D}
 {GL{JC}if
 /CW CW WH add BW add D /HM t D}ie /GL f D /Ph f D
 /LK LK NW length 1 add add D}{pop exit}ie}loop
 /fin t D TX SC LK SC sub GI SH RT () ne{GL not{CC}if}if
 /LC TX length D /WH RT SW pop D CW WH add Hy{HC SW pop add}if LL gt
 {RT GL{SH cF cS OC 2 copy cS ne E cF ne or{NF}{pop pop}ie
 Hy{/Ph t D}if /LL LS D}{NL /LL LS D SH}ie}
 {RT PC Hy{CC}if /Ph Ph Hy or D}ie RT () ne{/GL t D /HM t D}if}
 {TX SW pop LL le{TX SH}{/NW () D 0 2 TX length 1 sub
 {/CW E D TX 0 CW GI dup SW pop LL gt{pop NW SH /HM t D NL/LL W XO sub MR sub D
 /CW CW 2 sub NN D /TX TX CW TX length CW sub GI D TX BS exit}
 {/NW E D}ie}for}ie}ie /HM t D}D
/CC {C0 length 0 gt{JC}if /C0 [C1 L1 YA YB Mf NS NB TB AF Bw] D
 /C1 () D /L0 L1 D /YA 0 D /YB 0 D /Mf 0 D /NS 0 D /NB 0 D}D
/JC {C0 aload length 0 gt{pop pop pop NB add /NB E D NS add /NS E D
 dup Mf gt{/Mf E D}{pop}ie dup YB gt{/YB E D}{pop}ie
 dup YA gt{/YA E D}{pop}ie pop C1 join /C1 E D /C0 [] D}if}D
/OC {C0 length 0 gt{C1 L1 L0 sub YA YB Mf NS NB TB AF Bw GL C0 aload pop
 /Bw E D /AF E D /TB E D /NB E D /NS E D /Mf E D /YB E D /YA E D /C0 [] D
 /L1 E D /C1 E D Ph{HC SH}if NL /GL E D /Bw E D /AF E D /TB E D /NB E D /NS E D
 /Mf E D /YB E D /YA E D /L1 E D /LL W L1 sub XO sub MR sub WH sub D /CW 0 D
 C1 E join /C1 E D}if}D
/BT {/LB t D dup length string copy RS dup dup () ne E ( ) ne and
 {/CI 0 D /LS LL D /LL W L1 sub XO sub MR sub D BS}
 {dup ( ) eq{/GL f D}if dup () eq L1 0 eq or{pop}{SH /BP f D /Ph f D}ie}ie
 /LB f D} D
/BL {CP E pop XO E M} D
/NL {JC /GL f D /SK W XO sub MR sub L1 sub TB{Bw add}if D
 /YA LF{Mf HM Fl not and PF or{LH mul}if}{0 /LF t D}ie YA 2 copy lt{E}if pop D
 C1 () ne{/FB YB Mf SA{Sf mul}if 4 div 2 copy lt{E}if pop D}if Fl{/Ya YA D}if
 CP E pop YA sub YB sub LE neg lt Fl not and PB not and{NP}if NT TL BL
 OU PF not and PB or{/RE L1 TB{Bw sub}if
 W XO sub MR sub div YA YB add LE BO add div 2 copy lt{E}if pop D
 RE 1 gt{BL 1 RE div dup scale}if}if
 AT 2 le{SK AT mul 2 div YA neg R}if
 AT 3 eq{0 YA neg R TB{/NB NB 1 sub D /NS NS 1 sub D}if /NB NB 1 sub NN D
 /A3 NS 6 mul NB add D NS NB add 0 eq
  {/A1 0 D /A2 0 D}
  {NS 0 eq{/A1 SK NB div dup J gt{pop 0}if D /A2 0 D}{J A3 mul SK lt
   {/A1 J D /A2 SK J NB mul sub NS div dup Ab gt{/A1 0 D pop 0}if D}
   {/A1 SK A3 div D /A2 A1 6 mul D}ie}ie}ie /A1 A1 NN D /A2 A2 NN D}if
 AT 4 eq{0 YA neg R PH 2 le{PD 0 lt{/PD L1 D}if PD M1 gt{/M1 PD D}if
 L1 PD sub M2 gt{/M2 L1 PD sub D}if}{DV ID 1 sub get 0 ge{Lo 0 R}if}ie}if
 F0 cF ne Cs cS ne or{F0 Cs NF}if
 /ms Ms D /Ms f D CP FB sub
 C1 cvx exec XO EO sub L1 add TB{BW sub}if dup LM gt{/LM E D}{pop}ie
 PH 0 eq PH 4 eq or Ms and{HF not{/PO t D /AH t D}if
 BB CP YA add E AT 3 eq LB and{A1 sub}if TB{BW sub}if E BB}
 {pop pop}ie Ms HM PH 3 eq and or{/BP f D /Fl f D}if
 /Lo 0 D /L1 0 D /F0 cF D /Cs cS D BP not{0 YB NN neg R}if
 OU f1 and mF not and{k2 /f1 f D}if
 OU PF not and PB or{RE 1 gt{RE dup scale}if}if /Ms ms Ms or D
 /C1 AF{(Cp )}{()}ie D /YA 0 D /YB 0 D BL
 AT 4 eq LB not and PH 3 ge and
 {ID DV length lt{DV ID get dup 0 ge{DO E sub /Lo E D /L1 Lo D}{pop}ie
 /ID ID 1 add D}if}if /T t D CD{/LN LN 1 add D PD}if
 /PD -1 D /NS 0 D /NB 0 D /TB f D /Ph f D /Mf 0 D /HM f D} D
/RS {/TM E D /CN 0 D TM{10 eq{TM CN ( ) PI}if /CN CN 1 add D}forall
 /CN 0 D /BK HM EN and{0}{1}ie D TM
 {dup 32 ne{TM CN 3 2 roll put /CN CN 1 add D /BK 0 D}
 {pop BK 0 eq{TM CN 32 put /CN CN 1 add D}if /BK 1 D}ie}forall
 TM 0 CN GI dup dup () ne E ( ) ne and
 {dup CN 1 sub get 32 eq{/EN f D}{/EN t D}ie}if} D
/join {2 copy length E length add string dup 4 2 roll 2 index 0 3 index
 PI E length E PI}d
/WR {(\n) search{dup () ne BP not or
 {Li 4 le CP E pop YI Li mul add LE add 0 lt and PL 0 eq and{NP}if
 SH NL pop /Li Li 1 sub D WR}{pop pop WR}ie}{SH}ie /CI 0 D /BP f D} D
/SH {dup dup () ne E ( ) ne and PF or CS Mf gt and{/Mf CS D}if
 T not Wf and{( ) E join /T t D}if dup BP{/MF CS D}if
 AT 3 eq{2 copy length dup 0 gt{/NB E NB add D
 {( ) search{/NS NS 1 add D pop pop}{pop exit}ie}loop}{pop pop}ie}if
 CD PD 0 lt and{dup DC search{SW pop /PD E L1 add D pop pop}{pop}ie}if
 0 Np dup SW pop L1 add /L1 E D dup () ne
 {C1 (\() join E join (\)) join AU AF and UF or Wf and{( U ) join}if
 sF{( s ) join}if ( S ) join
 /C1 E D dup length 1 sub get 32 eq /TB E D /Bw BW D}{pop pop}ie} D
/BG {AI LG BC add add 0 eq} D
/ON {OU{Ty AR AI NN get dup 1 add Ln Ns Ty 2 mod 0 eq{(.  )}{(\)  )}ie join
 dup SW pop neg 0 R CP E 0 lt{0 E M}{pop}ie CP BB show /Ms t D}if} D
/Ln {AR AI 3 -1 roll put}D
/SP {dup CI lt BP not and{dup CI sub 0 E R /CI E D}{pop}ie} D
/BN {PF{WR /HM f D}{BT NL}ie} D
/NN {dup 0 lt{pop 0}if} D
/h {(h) HI ST cvs join cvx exec dup 1 get E Nf{0 get E join}{pop}ie} D
/H {/fn FN D /Hi E 1 add D 1 sub /HL E D /H2 HL 2 add D /GS EZ H2 get D
 E Tm H2 get GS mul BE dup 0 gt{1 sub}{pop EG H2 get dup 0 lt{pop AT}if}ie NA
 WW Np /SL SL 1 add D /FN EF H2 get D GS Ey H2 get FS
 EU H2 get Sc Hs not HL Hl lt and Hs HL hl lt and or Hi 0 eq or
 {/HI Hi D /Hs t D /hl HL D /Hv HL D}if HL Hl lt{/hi Hi D}if
 Nf HI 0 gt and{(h) Hi ST cvs join cvx exec 0 get WB}if
 /HF t D /AH f D /PO f D} D
/EH {Bm H2 get GS mul BE OA /SL SL 1 sub NN D /CF 0 D /FN fn D
 SZ SL get FR SL get FS /HF f D /GS Ts D ()Ec} D
/P {E PF{WR}{PO{EP}{BN}ie Ts 4 mul Np AE not{Tm 0 get Ts mul neg SP}if
 dup 0 ge AH and{Pi Pd}if}ie 1 sub dup 0 lt{pop AV AL get}if /AT E D /PO t D} D
/EP {PF{WR}{BN Ts 4 mul Np}ie AE not{Bm 0 get Ts mul neg SP}if
 /AT AV AL get D /PO f D} D
/BE {E PO{EP}{BN}ie Ts 4 mul Np neg SP} D
/HR {/Aw W EO sub D /RW E dup 0 gt{Aw mul}{neg}ie dup Aw gt{pop Aw}if D /RZ E D
 E BN Ts neg SP 1 sub 2 div Aw RW sub mul EO add CP E pop M PF{0 Ps neg R}if
 0 Np OU{gsave RZ LW Cf{Hc VC}{0 Sg}ie CP BB RW 0 RL CP BB stroke grestore}if
 /CI 0 D /BP f D PF not{Ts neg SP}if /Ms t D} D
/AD {I NL EG 14 get dup 0 lt{pop AT}if NA /AE t D Tm 14 get Ts mul neg SP
 Cf{EU 14 get dup -1 eq{pop CA CL get}if Sc}if} D
/DA {BN ()ES OA /AE f D ()Ec Bm 14 get Ts mul neg SP} D
/PR {/MW E D /Li E D Tm 1 get Ps mul BE 0 NA /FN Fp D /PF t D SI /SL SL 1 add D
 /CF 0 D Ps CS mul Ts div MW WC mul CS mul Ts div dup LL gt PL 0 eq and
 {LL div div}{pop}ie Ey 1 get FS CP E pop LE add YI neg div cvi dup Li lt
 AH and{4 lt YI Li mul 5 mul LE add 0 gt or PL 0 eq and{NP}if}{pop}ie
 EU 1 get Sc /GS Ps D}D
/RP {WR NL () /PF f D SI /FN 0 D ES Bm 1 get Ps mul neg SP OA /GS Ts D} D
/SI {/XO Lm 15 get BC NN mul Lm 16 get AI UI sub NN mul add
 Lm 17 get UI NN mul add Lm 20 get LG NN mul add Ts mul
 PF{Lm 1 get Ps mul add}if EO add D
 /MR Rm 15 get BC NN mul Rm 16 get AI UI sub NN mul add
 Rm 17 get UI NN mul add Rm 20 get LG NN mul add Ts mul
 PF{Rm 1 get Ps mul add}if D /LL W XO sub MR sub D} D
/DT {/cC E D BN /LG LG 1 sub D SI /LG LG 1 add D WW 2 div Np BL} D
/DD {WB Cc 0 eq cC 0 eq and L1 0 eq or Lm 20 get Ts mul L1 sub TB{BW add}if
 Ts 2 div lt or NL /LF E D SI BL /cC 0 D} D
/DL {Dc LG Cc put /Cc E D BG{Tm 18 get Ts mul BE}{BN}ie /LG LG 1 add D BL} D
/LD {BN LG 0 gt{/LG LG 1 sub D}if /Cc Dc LG get D SI
 BG{()Bm 18 get Ts mul BE}if BL} D
/UL {BG{Tm 17 get Ts mul BE}{BN}ie NR AI NN 0 put /UI UI 1 add D
 /AI AI 1 add D SI BL} D
/LU {BN /UI UI 1 sub D /AI AI 1 sub D SI BG{()Bm 17 get Ts mul BE}if BL} D
/OL {E BG{Tm 16 get Ts mul BE}{BN}ie TR AI NN Ty put /Ty E D NR AI NN 1 put
 /AI AI 1 add D SI BL 1 Ln} D
/LO {BN /AI AI 1 sub D /Ty TR AI get D SI BG{()Bm 16 get Ts mul BE}if BL} D
/LI {E BN -1 SP /BP f D /CI 0 D 0 Np NR AI 1 sub NN get 1 eq
 {dup dup 0 gt E 4 le and{/Ty E D}{pop}ie
 /L1 L1 Ty AR AI NN get Ns SW pop XO sub dup 0 lt{pop 0}if add D ( ON )}
 {pop ( B )}ie C1 E join /C1 E D CS Mf gt{/Mf CS D}if BL} D
/BQ {Tm 15 get Ts mul BE /BC BC 1 add D SI BL} D
/QB {Bm 15 get Ts mul BE /BC BC 1 sub D SI BL} D
/Al {E EP 1 sub dup 0 lt{pop AV AL get}if NA} D
/Ea {EP OA} D
/WB {PF{WR}{BT}ie} D
/F1 {WB /FN 0 D CS 0 FS} D
/F2 {WB /FN WI D CS 0 FS} D
/HY {/Hy t D WB /Hy f D} D
/YH {WB} D
/A {/LT E D LT 1 eq{/RN E D}if /Lh E D WB /C1 C1 ( Cp ) join D
 Lc AF not and{Cl Sc}if /AF t D} D
/EA {Lc AF and{Ec}{WB}ie TL Pa AF and Lh 0 ne and
 {( \() Lh join (\)) join /AF f D WB}if /AF f D} D
/TL {C1 ( Tl ) apa /C1 E D} d
/apa {AF OU and Lh 0 ne LT 1 eq or and{LT 1 eq{RN ( /) E ST cvs join}
 {(\() Lh join (\)) join}ie E join join}{pop}ie} d
/Cp {/Xc CP /Yc E D D} D
/SS {Cf{dup 0 ge{EU E get dup -1 eq{pop CA CL get}if}{pop CA CL get}ie Sc}
 {pop}ie SZ SL get /SL SL 1 add D} D
/I {WB 8 SS 1 FS} D
/EM {WB 8 SS /CF CF 1 xor D 0 FS} D
/BD {WB 9 SS 2 FS} D
/TT {WB 10 SS /FN Fp D 0 FS} D
/KB {WB 11 SS /FN Fp D 2 FS} D
/CT {WB 12 SS 1 FS} D
/SM {WB 13 SS /FN Fp D 0 FS} D
/Q {/QL QL 1 add D QO QL 2 mod get La get join WB} D
/EQ {QC QL 2 mod get La get join WB /QL QL 1 sub D} D
/RO {WB -1 SS /CF 0 D 0 FS} D
/SY {WB -1 SS -1 FS} D
/MY {WB -1 SS -2 FS} D
/ES {WB /SL SL 1 sub NN D /CF 0 D /FN FO SL get D SZ SL get FR SL get FS ()Ec}D
/FZ {3 sub 1.2 E exp GS mul E WB TL /C1 C1 ( Cp ) join D /SL SL 1 add D 0 FS} D
/Ef {WB TL ()ES /C1 C1 ( Cp ) join D} D
/BZ {dup /Bf E D FZ}D
/Sc {dup -1 ne Cf and{/CL CL 1 add D dup 0 eq{pop [0 0 0]}if
 dup CA E CL E put VS ( VC ) join C1 E join /C1 E D}{pop}ie} D
/Ec {WB Cf{/CL CL 1 sub NN D CA CL get VS ( VC ) join C1 E join /C1 E D}if} D
/VS {dup type /arraytype eq{([) E {ST cvs join ( ) join}forall (]) join}if} D
/VC {{255 div}forall setrgbcolor} D
/Sl {dup type /integertype ne{Ds}if /La E D WB}d
/UN {WB /UF t D} D
/NU {WB /UF f D} D
/SE {WB /sF t D} D
/XE {WB /sF f D} D
/sM {/C1 C1 ( k1 ) join D}d
/eM {/C1 C1 ( k2 ) join D}d
/k1 {/YC CP E pop Ts add D /mF t D /f1 t D}d
/k2 {gsave 3 LW -9 CP E pop Ts 0.2 mul sub M -9 YC L stroke grestore /mF f D}d
/Ac {/AC E D WB}d
/Ca {eA{( \()join AC join(\) )join}if WB}d
/s {OU{gsave 0 CS .25 mul R dup SW pop CJ 0 RL stroke grestore}if}D
/CJ {AT 3 eq LB and{E dup dup length 1 sub A1 mul E
 {( ) search{pop pop E A2 add E}{pop exit}ie}loop 3 -1 roll add
 W CP pop sub 2 copy gt{E}if pop}if}D
/So {/Co E D} D
/SO {C1 Yo ST cvs join ( So ) join /C1 E D (j) SW pop 2 div Pd} D
/Se {E WB CS E div Pd}D
/Pd {dup type /stringtype eq{SW pop}if dup /L1 E L1 add D
 ST cvs ( 0 R ) join C1 E join /C1 E D} D
/Sp {0.35 CO} D
/Sb {-0.2 CO} D
/CO {OV Io Yo put /Yo E CS mul Yo add D /Io Io 1 add D -1.5 Io mul 3 add FZ SO
 CS Yo add dup YA gt{/YA E D}{pop}ie
 Yo neg dup YB gt{/YB E D}{pop}ie} D
/Es {ES /Io Io 1 sub NN D /Yo OV Io get D SO} D
/SB {/N2 0 D 0 1 NI{/N E D{IX N2 get 0 lt{/N2 N2 1 add D}{exit}ie}loop
 /K WS N get FC N get mul D /NY AY N2 get D /BV NY array D
 0 1 NY 1 sub{/TM K string D currentfile TM readhexstring pop pop BV E TM put}
 for BM N BV put /N2 N2 1 add D}for} D
/IC [{/MA E D /MB 0 D}{2 div /MA E D /MB MA D}{/MB E CS sub D /MA CS D}
 {pop /MA YS AB mul D /MB 1 AB sub YS mul D}{pop /MA 0 D /MB 0 D}] D
/IP {BV N get /N N 1 add D} D
/II {/K E D IX K get 0 lt{/EC E D}if /TY E D
 TY 4 eq{/Y E D /X E D}if TY 3 eq{/AB E D}if
 /XW AX K get D /YW AY K get D /IS SG IT K get get D /XS XW IS mul D
 /YS YW IS mul D YS IC TY get exec /MA MA Fl not{3 add}if D} D
/IM {II /ty TY D /xs XS D /ys YS D /ya YA D /yb YB D /ma MA D /mb MB D /k K D
 /ec EC D /BP f D /CI 0 D WB TL L1 xs add dup XO add MR add W gt
 {pop /ma ma Fl{3 add}if D NL /YA ma D /YB mb D /YS ys D /L1 xs D}
 {/L1 E D ma YA gt{/YA ma D}if mb YB gt{/YB mb D}if}ie /TB f D
 OU{CP E pop YS sub LE neg lt Fl not and PB not and{NP /YA ma D /YB mb D}if
 /BP f D ty ST cvs ( ) join IX k get 0 lt{(\() join ec join (\) ) join}if
 k ST cvs join ty 3 eq{AB ST cvs ( ) join E join}if
 ty 4 eq{X ST cvs ( ) join Y ST cvs join ( ) join E join}if C1 E join
 ( DI ) join FP 2 eq FP 1 eq AF and or{( FM ) join}if
 ( Il Cp ) apa /C1 E D /EN f D}if /HM t D /T f D} D
/DI {II /Xc CP /Yc E D D /YN YW neg D /HM t D /CI 0 D /K2 IX K get D gsave
 TY 4 eq{OX X IS mul add OY FY add YS sub Y IS mul sub}
 {/FY YS D CP MB sub 2 copy /OY E D /OX E D}ie
 translate K2 0 ge{/DP AZ K2 get D /BV BM K2 get D XS YS scale /N 0 D XW YW DP
 [XW 0 0 YN 0 YW] {IP} FC K2 get 1 eq{image}{f 3 colorimage}ie}
 {EX}ie grestore XS 0 R /Ms t D} D
/FM {gsave 0 Sg CP MB sub translate XS neg 0 M 0 YS RL XS 0 RL 0 YS neg RL
 XS neg 0 RL stroke grestore} D
/NA {/AT E D /AL AL 1 add D AV AL AT put} D
/OA {AL 0 gt{/AL AL 1 sub D /AT AV AL get D}if} D
/D1 {/BR {CP E pop E BN Mb{CP E pop eq{0 YI R}if}{pop}ie} D
 /Sn {OU{C1 E ST cvs join ( Ld ) join /C1 E D}{pop}ie} D} D
/D1 {/BR {BN} D /Sn {OU {C1 E ST cvs join ( Ld ) join /C1 E D} {pop} ie} D} D
/TC {/TF t D /ML 0 D HN{SW pop dup ML gt{/ML E D}{pop}ie}forall NP /RM RM not D
 RC /OU Tc D Ep /PN 0 D Ms not TP and{Ip}if /W IW ML sub Ts sub D
 /A0 0 D TH{/BR {( ) join BT} D /Sn {pop} D /Au () D}if} D
/TN {0 eq{E EA PF HF or not XR and{HN E get Xr}{pop}ie}
 {OU{Tn 0 ge{() BN}if /Tn E D}{pop}ie WB}ie} D
/NT {OU LB not and Tn 0 ge and{PL 0 eq{Ms not{CS CF FS}if CP dup
 /y E YA sub D W 9 sub CS -1.8 mul XO L1 add 2 add{y M (.) show}for
 HN Tn get dup SW pop IW E sub y M show CP BB M}if /Tn -1 D}if} D
/Ld {/DN E D HN DN Pn put [/View [/XYZ -4 Fl{PS}{CP YA add US E pop}ie null]
 /Dest DN ST cvs cvn /DEST pdfmark} D
/C {ND 1 eq{1 sub}if TI mul /XO E D NL Nf not{pop()}if 0 3 -1 roll 1 A} D
/OP {BP not{NP}if PN 2 mod 0 eq{/Ms t D NP}if}D
/Ep {Xp PN 2 mod 0 eq and OU and{/Pn (-) D showpage /PM 1 D LA}if}D
/Dg [73 86 88 76 67 68 77] D
/Rd [0 [1 1 0][2 1 0][3 1 0][2 1 1][1 1 1][2 2 1][3 3 1][4 4 1][2 1 2]] D
/Ns {/m E D /c E 32 mul D /j m 1000 idiv D /p j 12 add string D
 c 96 le m 0 gt and{c 32 le {/i 0 D /d 77 D /l 100 D /m m j 1000 mul sub D
  j -1 1 {pop p i d c add put /i i 1 add D}for
  4 -2 0 {/j E D /n m l idiv D /m m n l mul sub D /d Dg j get D
   n 0 gt {/x Rd n get D x 0 get -1 1 {pop p i d c add put /i i 1 add D}for
   p i x 1 get sub Dg x 2 get j add get c add put}if /l l 10 idiv D
  }for p 0 i GI}
  {/i ST length 1 sub D m {1 sub dup 0 ge{dup 26 mod c add 1 add
   ST i 3 -1 roll put 26 idiv dup 0 eq{pop exit}if}if /i i 1 sub D}loop
   ST i ST length i sub GI}ie}
 {m p cvs}ie} D
/US {matrix currentmatrix matrix defaultmatrix matrix invertmatrix
 matrix concatmatrix transform} D
/GB {Gb{US}if}D
/Tl {/Rn E D Xc CP pop ne{
 [/Rect [Xc 1 sub Yc cS 0.25 mul sub GB CP E 1 add E cS 0.85 mul add GB]
  /Subtype /Link /Border [0 0 Cf Lc and LX and AU or{0}{1}ie] Rn type
  /nametype eq {/Dest Rn}{/Action [/Subtype /URI /URI Rn] Cd}ie
  /ANN pdfmark}if} D
/Il {/Rn E D [/Rect [Xc Yc GB Xc XS add Yc YS add GB] /Subtype /Link
 /Border [0 0 0] Rn type /nametype eq{/Dest Rn}
 {/Action [/Subtype /URI /URI Rn] Cd}ie /ANN pdfmark} D
/XP {[{/Z Bz 2 div D Z 0 R Z Z RL Z neg Z RL Z neg Z neg RL Z Z neg RL
 Fi cH 1 eq and{fill}if} {Bz 0 RL 0 Bz RL Bz neg 0 RL 0 Bz neg RL
 Fi cH 1 eq and{fill}if} {0 -5 R Bz 0 RL 0 21 RL Bz neg 0 RL 0 -21 RL}]} D
/MS {/Sm E D WB}D
/O {BN()0 Sm BX} D
/BX {/Bt E D Bt 2 lt{/Ch E D CS 0.8 mul}{11 mul}ie W XO sub MR sub
 2 copy gt{E}if pop /HZ E D Bt 2 eq{Fi not{pop()}if ( )E join /Ft E D TT
 /PF t D /MW 1 D /Li 1 D /Fw Ft SW pop D Fw HZ gt{/HZ Fw 8 add D}if
 HZ ST cvs( )join}{WB Ch ST cvs( )join}ie L1 HZ add XO add MR add W gt{NL}if
 Bt 2 eq{Ft ES Fw neg HM{CS sub}if Pd}if Bt ST cvs join( Bx )join
 Bt 2 eq HM and{CS Pd}if C1 E join /C1 E D /L1 L1 HZ add D /T f D
 ( ) Pd /PF f D Bt 2 lt{YA CS .8 mul lt{/YA CS .8 mul D}if}
 {YB 5 lt{/YB 5 D}if YA 21 lt{/YA 21 D}if}ie /CI 0 D} D
/Bx {dup 2 eq{E /Bz E D}{E /cH E D /Bz CS .8 mul D}ie
 OU {gsave 0 Sg XP E get exec stroke grestore}{pop}ie Bz 0 R /Ms t D}D
/SD {FD 4 mul Dy add DZ NF newpath 0 0 M DX t charpath pathbbox
 3 -1 roll sub /DY E D E dup /X1 E D sub WM mul WX DY mul add WM DG mul E div
 /DF E D /DR WX DF mul DY mul WM div 2 div D} d
/Sd {gsave 0 IL Di mul neg translate IL IW atan Di 0 eq{neg}if rotate
 FD 4 mul Dy add DZ NF DR X1 sub DY 2 div neg M cD VC DX show grestore} d
/Pt {/tp t D Tp{NP /Pn (TP) D 0 Tt neg R Th BN NP Ep ET RC ZF}if /tp f D} D
/RC {/AI 0 D /LG 0 D /BC 0 D /UI 0 D /PF f D /Cc 0 D /cC 0 D /Dc 10 array D
 /NR [0 1 9{pop 0}for] D /La Ds D /AR 10 array D /TR 10 array D /AV 30 array D
 SI /AL -1 D /AT A0 D AT NA /OV 9 array D /Yo 0 D /Co 0 D /Io 0 D /Hy f D
 /Ph f D /CL -1 D Ct Sc}D
/ZF {/FR [0 1 30{pop 0}for] D /SZ [0 1 30{pop 0}for] D /FO [0 1 30{pop 0}for] D
 /SL 0 D /CF 0 D /FN 0 D 0 Ts SF}D
/QO [[(\253)(\273)(\233)(\253\240)(\232)(\234)][(\253)(\273)(`)(\253\240)(\231)(')]] D
/QC [[(\273)(\253)(\234)(\240\273)(\233)(\234)][(\273)(\253)(')(\240\273)(`)(')]] D
/Hf EF length 2 sub D
/Hz EZ Hf get D
/HS Ey Hf get D
/Fz EZ Hf 1 add get D
/Fs Ey Hf 1 add get D
/LE IL D
/Ps EZ 1 get D
/Fp EF 1 get D
/XO 0 D
/YI 0 D
/CI 0 D
/FP 0 D
/WW Ts 7 mul D
/Mf 0 D
/YA 0 D
/YB 0 D
/Cs Ts D
/GS Ts D
/F0 0 D
/NS 0 D
/NB 0 D
/N 0 D
/C0 [] D
/C1 () D
/Lo 0 D
/L1 0 D
/LM 0 D
/PH 0 D
/EC 0 D
/Lh 0 D
/LT 0 D
/CH 1 string D
/ST 16 string D
/CA 9 array D
/HC (\255) D
/HM f D
/PF f D
/EN f D
/TB f D
/UF f D
/sF f D
/AE f D
/AF f D
/BP t D
/CD f D
/PA t D
/GL f D
/T t D
/HF f D
/AH f D
/SA f D
/PB f D
/f1 f D
/mF f D
/OX 0 D
/OY 0 D
/FY 0 D
/EO 0 D
/FB 0 D
/PL 0 D
/Bw 0 D
/PD -1 D
/TP f D
/tp f D
/TH t D
/Ty 4 D
/Tn -1 D
/Fl t D
/LB t D
/PM 1 D
/Ms f D
/Ba f D
/Bb f D
/Hl 3 D
/hl 6 D
/Hv 6 D
/Hs f D
/HI 0 D
/hi 0 D
/PO t D
/TE f D
/LF t D
/BO 0 D
/Sm 1 D
/Bf 3 D
/A1 0 D
/A2 0 D
/Ds 2 D
/QL -1 D
/Cb Db D
/Ct Dt D
/Cl Dl D
[/Creator (html2ps version 1.0 beta7) /Author () /Keywords () /Subject (toolchain)
 /Title (The build2 Packaging Guide) /DOCINFO pdfmark
/ND 1 D
/HN [(1) (1) (1) (1) (2) (3) (3) (3) (4) (4) (5) (7) (8) (8) (11) (14) (18)
(20) (21) (22) (23) (24) (26) (28) (29) (30) (31) (32) (33) (35) (36) (36)
(38) (41) (43) (43) (45) (45) (46) (47) (47) (48) (49) (49) (50) (51) (51)
(52) (54) (54) (55) (55) (55) (55) (56) (58) (59) (60) (61) (61) (61) (62)
(63) (64) (64) (65) (66) (67) (68) (69) (69) (69) (69) (70) (70) (70) (71)
(71) (71) (71) (71) (71) (72) (72) (72) (73) (73) (73) (73) (74) (75) (76)
(77) (77) (77) (78) (79) (80) (82) (83) (84) (85) (85) (86) (86) (86) (86)
(87) (88) (91) (91) (91) (92) (93) (94) (95) (95) (96) (96) (97) (98) (98)
(99) (1) (1) (2) (3) (3) (3) (4) (4) (5) (7) (8) (8) (11) (14) (18) (20)
(21) (22) (23) (24) (26) (28) (29) (30) (31) (32) (33) (35) (36) (36) (38)
(41) (43) (43) (45) (45) (46) (47) (47) (48) (49) (49) (50) (51) (51) (52)
(54) (54) (55) (55) (55) (55) (56) (58) (59) (60) (61) (61) (61) (62) (63)
(64) (64) (65) (66) (67) (68) (69) (69) (69) (69) (70) (70) (70) (71) (71)
(71) (71) (71) (71) (72) (72) (72) (73) (73) (73) (73) (74) (75) (76) (77)
(77) (77) (78) (79) (80) (82) (83) (84) (85) (85) (86) (86) (86) (86) (87)
(88) (91) (91) (91) (92) (93) (94) (95) (95) (96) (96) (97) (98) (98) (99)] D
/h0 [()(Table of Contents)] D
/h1 [(1\240\240)(Preface)] D
/h2 [(2\240\240)(1 Introduction)] D
/h3 [(2.1\240\240)(1.1 Terminology)] D
/h4 [(3\240\240)(2 Common Guidelines)] D
/h5 [(3.1\240\240)(2.1 Setup the package repository)] D
/h6 [(3.1.1\240\240)(2.1.1 Check if package repository already exists)] D
/h7 [(3.1.2\240\240)(2.1.2 Use upstream repository name as package repository name)] D
/h8 [(3.1.3\240\240)(2.1.3 Create package repository in personal workspace)] D
/h9 [(3.1.4\240\240)(2.1.4 Initialize package repository with bdep new)] D
/h10 [(3.1.5\240\240)(2.1.5 Add upstream repository as git submodule)] D
/h11 [(3.2\240\240)(2.2 Create package and generate buildfile templates)] D
/h12 [(3.2.1\240\240)(2.2.1 Decide on the package name)] D
/h13 [(3.2.2\240\240)(2.2.2 Decide on the package source code layout)] D
/h14 [(3.2.3\240\240)(2.2.3 Craft bdep new command line to create package)] D
/h15 [(3.2.4\240\240)(2.2.4 Review and test auto-generated buildfile templates)] D
/h16 [(3.2.5\240\240)(2.2.5 Create final package)] D
/h17 [(3.2.6\240\240)(2.2.6 Adjust package version)] D
/h18 [(3.3\240\240)(2.3 Fill package with source code and add dependencies)] D
/h19 [(3.3.1\240\240)(2.3.1 Initialize package in build configurations)] D
/h20 [(3.3.2\240\240)(2.3.2 Add dependencies)] D
/h21 [(3.3.3\240\240)(2.3.3 Fill with upstream source code)] D
/h22 [(3.4\240\240)(2.4 Adjust project-wide and source buildfiles)] D
/h23 [(3.4.1\240\240)(2.4.1 Adjust project-wide build system files in build/)] D
/h24 [(3.4.2\240\240)(2.4.2 Adjust source subdirectory buildfiles)] D
/h25 [(3.4.3\240\240)(2.4.3 Adjust header buildfile)] D
/h26 [(3.4.4\240\240)(2.4.4 Adjust source buildfile: overview)] D
/h27 [(3.4.5\240\240)(2.4.5 Adjust source buildfile: cleanup)] D
/h28 [(3.4.6\240\240)(2.4.6 Adjust source buildfile: dependencies)] D
/h29 [(3.4.7\240\240)(2.4.7 Adjust source buildfile: public headers)] D
/h30 [(3.4.8\240\240)(2.4.8 Adjust source buildfile: sources, private headers)] D
/h31 [(3.4.9\240\240)(2.4.9 Adjust source buildfile: build and export options)] D
/h32 [(3.4.10\240\240)(2.4.10 Adjust source buildfile: symbol exporting)] D
/h33 [(3.4.11\240\240)(2.4.11 Adjust source buildfile: shared library version)] D
/h34 [(3.4.12\240\240)(2.4.12 Adjust source buildfile: executables)] D
/h35 [(3.4.13\240\240)(2.4.13 Adjust source buildfile: extra requirements)] D
/h36 [(3.4.14\240\240)(2.4.14 Test library build)] D
/h37 [(3.5\240\240)(2.5 Make smoke test)] D
/h38 [(3.5.1\240\240)(2.5.1 Adjust project-wide build system files in tests/build/)] D
/h39 [(3.5.2\240\240)(2.5.2 Convert generated test to library smoke test)] D
/h40 [(3.5.3\240\240)(2.5.3 Make smoke test: executables)] D
/h41 [(3.5.4\240\240)(2.5.4 Test locally)] D
/h42 [(3.5.5\240\240)(2.5.5 Test locally: installation)] D
/h43 [(3.5.6\240\240)(2.5.6 Test locally: distribution)] D
/h44 [(3.5.7\240\240)(2.5.7 Commit and test with CI)] D
/h45 [(3.6\240\240)(2.6 Replace smoke test with upstream tests)] D
/h46 [(3.6.1\240\240)(2.6.1 Understand how upstream tests work)] D
/h47 [(3.6.2\240\240)(2.6.2 Convert smoke test to upstream tests)] D
/h48 [(3.6.3\240\240)(2.6.3 Test locally)] D
/h49 [(3.6.4\240\240)(2.6.4 Commit and test with CI)] D
/h50 [(3.7\240\240)(2.7 Add upstream examples, benchmarks, if any)] D
/h51 [(3.8\240\240)(2.8 Adjust root files \(buildfile, manifest, etc\))] D
/h52 [(3.8.1\240\240)(2.8.1 Adjust root buildfile)] D
/h53 [(3.8.2\240\240)(2.8.2 Adjust root buildfile: other subdirectories)] D
/h54 [(3.8.3\240\240)(2.8.3 Adjust root buildfile: commit and test)] D
/h55 [(3.8.4\240\240)(2.8.4 Adjust manifest)] D
/h56 [(3.8.5\240\240)(2.8.5 Adjust manifest: summary)] D
/h57 [(3.8.6\240\240)(2.8.6 Adjust manifest: license)] D
/h58 [(3.8.7\240\240)(2.8.7 Adjust manifest: commit and test)] D
/h59 [(3.8.8\240\240)(2.8.8 Adjust PACKAGE-README.md)] D
/h60 [(3.9\240\240)(2.9 Adjust package repository README.md)] D
/h61 [(3.10\240\240)(2.10 Release and publish)] D
/h62 [(3.10.1\240\240)(2.10.1 Transfer package repository)] D
/h63 [(3.10.2\240\240)(2.10.2 Release final version)] D
/h64 [(3.10.3\240\240)(2.10.3 Publish released version)] D
/h65 [(3.11\240\240)(2.11 Package version management)] D
/h66 [(3.11.1\240\240)(2.11.1 New revision)] D
/h67 [(3.11.2\240\240)(2.11.2 New version)] D
/h68 [(3.11.3\240\240)(2.11.3 New version: create new work branch)] D
/h69 [(3.11.4\240\240)(2.11.4 New version: open new version)] D
/h70 [(3.11.5\240\240)(2.11.5 New version: update upstream submodule)] D
/h71 [(3.11.6\240\240)(2.11.6 New version: review upstream changes)] D
/h72 [(3.11.7\240\240)(2.11.7 New version: layout changes)] D
/h73 [(3.11.8\240\240)(2.11.8 New version: new/old dependencies)] D
/h74 [(3.11.9\240\240)(2.11.9 New version: new/old source files)] D
/h75 [(3.11.10\240\240)(2.11.10 New version: changes to build system)] D
/h76 [(3.11.11\240\240)(2.11.11 New version: other new/old files/subdirectories)] D
/h77 [(3.11.12\240\240)(2.11.12 New version: review manifest and PACKAGE-README.md)] D
/h78 [(3.11.13\240\240)(2.11.13 New version: review repository README.md)] D
/h79 [(3.11.14\240\240)(2.11.14 New version: review/fix accumulated issues)] D
/h80 [(3.11.15\240\240)(2.11.15 New version: test locally and with CI)] D
/h81 [(3.11.16\240\240)(2.11.16 New version: merge, release, and publish)] D
/h82 [(3.11.17\240\240)(2.11.17 New version/revision in old release series)] D
/h83 [(4\240\240)(3 What Not to Do)] D
/h84 [(4.1\240\240)(3.1 Don't write buildfiles from scratch, use bdep-new)] D
/h85 [(4.2\240\240)(3.2 Avoid fixing upstream issues in the build2 package)] D
/h86 [(4.3\240\240)(3.3 Avoid changing upstream source code layout)] D
/h87 [(4.4\240\240)(3.4 Don't make library header-only if it can be compiled)] D
/h88 [(4.5\240\240)(3.5 Don't bundle dependencies)] D
/h89 [(4.6\240\240)(3.6 Don't build your main targets in the root buildfile)] D
/h90 [(4.7\240\240)(3.7 Don't make extensive changes in a revision)] D
/h91 [(5\240\240)(4 Packaging HOWTO)] D
/h92 [(5.1\240\240)(4.1 How do I patch upstream source code?)] D
/h93 [(5.1.1\240\240)(4.1.1 Modifying upstream source code manually)] D
/h94 [(5.1.2\240\240)(4.1.2 Modifying upstream source code during build)] D
/h95 [(5.1.3\240\240)(4.1.3 Modifying upstream source code with C/C++ preprocessor)] D
/h96 [(5.2\240\240)(4.2 How do I deal with bad header inclusion practice?)] D
/h97 [(5.3\240\240)(4.3 How do I handle extra header installation subdirectory?)] D
/h98 [(5.4\240\240)(4.4 How do I handle headers without an extension?)] D
/h99 [(5.5\240\240)(4.5 How do I expose extra debug macros of a library?)] D
/h100 [(5.6\240\240)(4.6 How do I deal with tests that don't terminate?)] D
/h101 [(5.7\240\240)(4.7 How do I deal with compiler/linker running out of RAM?)] D
/h102 [(6\240\240)(5 Packaging FAQ)] D
/h103 [(6.1\240\240)(5.1 Publishing FAQ)] D
/h104 [(6.1.1\240\240)(5.1.1 Why is my package in alpha rather than stable?)] D
/h105 [(6.1.2\240\240)(5.1.2 Where to publish if package requires staged toolchain?)] D
/h106 [(6.1.3\240\240)(5.1.3 Why "project owner authentication failed" while publishing?)] D
/h107 [(7\240\240)(6 Package Review)] D
/h108 [(7.1\240\240)(6.1 Reviewing initial package submission)] D
/h109 [(7.1.1\240\240)(6.1.1 Create review issue)] D
/h110 [(7.1.2\240\240)(6.1.2 Create review pull request)] D
/h111 [(7.1.3\240\240)(6.1.3 Go through review checklist)] D
/h112 [(7.1.4\240\240)(6.1.4 Add review outcome comment)] D
/h113 [(7.1.5\240\240)(6.1.5 Finish successful review)] D
/h114 [(7.1.6\240\240)(6.1.6 Continue with unsuccessful review)] D
/h115 [(7.1.7\240\240)(6.1.7 Send review notification email)] D
/h116 [(7.2\240\240)(6.2 Reviewing new version submission)] D
/h117 [(7.2.1\240\240)(6.2.1 Determine the extent of changes)] D
/h118 [(7.2.2\240\240)(6.2.2 Create review issue)] D
/h119 [(7.2.3\240\240)(6.2.3 Finish successful review)] D
/h120 [(7.2.4\240\240)(6.2.4 Continue with unsuccessful review)] D
/h121 [(7.3\240\240)(6.3 Reviewing new revision submission)] D
/Hr [123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139
140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157
158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175
176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193
194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211
212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229
230 231 232 233 234 235 236 237 238 239 240 241 242 243]D
/HV [1 1 2 1 2 3 3 3 3 3 2 3 3 3 3 3 3 2 3 3 3 2 3 3 3 3 3 3 3 3 3 3 3
3 3 3 2 3 3 3 3 3 3 3 2 3 3 3 3 2 2 3 3 3 3 3 3 3 3 2 2 3 3 3 2 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 2 2 2 2 2 2 2 1 2 3 3 3 2 2 2 2 2 2 1 2 3 3
3 1 2 3 3 3 3 3 3 3 2 3 3 3 3 2]D
/Cn [0 1 0 11 5 0 0 0 0 0 6 0 0 0 0 0 0 3 0 0 0 14 0 0 0 0 0 0 0 0 0 0
0 0 0 0 7 0 0 0 0 0 0 0 4 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 3 0 0 0 17 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 0 0 0 0 0 0 0 7 3 0 0 0 0 0 0 0 0 0 1 3 0
0 0 3 7 0 0 0 0 0 0 0 4 0 0 0 0 0]D
Hr length 0 gt{[/PageMode /UseOutlines /DOCVIEW pdfmark}if
/Hn 1 D
0 1 Hr length 1 sub{
 /Bn E D [Cn Bn get dup 0 gt{/Count E HV Bn get Bl ge{neg}if}{pop}ie
 /Dest Hr Bn get dup abs ST cvs cvn E 0 ge{(h)Hn ST cvs join cvx exec
 dup 1 get E Nf{0 get E join}{pop}ie /Hn Hn 1 add D}{()}ie
 /Title E dup length 255 gt{0 255 getinterval}if /OUT pdfmark}for
ZF /FN Fp D Ps 0 FS /WC Wf{( )}{<A1A1>}ie SW pop D
ET RC ZF
/Df f D
/R1 (https://cppget.org/) D
/R2 (https://build2.org/doc.xhtml) D
/R3 (https://build2.org/faq.xhtml#why-syspkg) D
/R4 (https://build2.org/faq.xhtml#why-package-managers) D
/R5 (https://github.com/build2-packaging) D
/R6 (https://ci.cppget.org/) D
/R7 (https://queue.cppget.org/) D
/R8 (https://queue.stage.build2.org/) D
/R9 (https://github.com/build2-packaging/WISHLIST/issues) D
/R10 (https://build2.org/community.xhtml#help) D
/R11 (https://github.com/build2-packaging/WISHLIST) D
/R12 (https://github.com/build2/HOWTO/blob/master/entries/handle-tests-with-extra-dependencies.md) D
/R13 (https://build2.org/article/symlinks.xhtml) D
/R14 (https://build2.org/article/symlinks.xhtml#windows) D
/R15 (https://packages.debian.org/) D
/R16 (https://github.com/build2/HOWTO/blob/master/entries/name-packages-in-project.md) D
/R17 (https://github.com/build2/HOWTO/blob/master/entries/make-header-only-library.md) D
/R18 (https://github.com/build2/HOWTO/blob/master/entries/handle-projects-which-dont-use-semver.md) D
/R19 (https://github.com/build2/HOWTO/blob/master/entries/handle-projects-which-dont-use-version.md) D
/R20 (https://cppget.org/catch2) D
/R21 (https://cppget.org/?about) D
/R22 (https://github.com/build2/HOWTO/blob/master/entries/link-system-library.md) D
/R23 (https://github.com/build2/HOWTO/blob/master/entries/keep-build-graph-config-independent.md) D
/R24 (https://github.com/build2/HOWTO/blob/master/entries/compile-options-in-buildfile.md) D
/R25 (https://github.com/build2-packaging/sqlite) D
/R26 (https://github.com/build2/HOWTO/blob/master/entries/convey-additional-information-with-exe-lib.md) D
/R27 (https://github.com/build2/libbuild2-autoconf) D
/R28 (https://github.com/build2-packaging/zstd) D
/R29 (https://cppget.org/reflex) D
/R30 (https://cppget.org/byacc) D
/R31 (https://github.com/build2/HOWTO/) D
/R32 (https://github.com/build2/HOWTO/blob/master/entries/use-assert-in-tests.md) D
/R33 (https://github.com/build2-packaging/thrift/tree/0.17) D
/R34 (https://github.com/build2/HOWTO/blob/master/entries/sanitize-test-execution.md) D
/R35 (https://cppget.org/gtest) D
/R36 (https://cppget.org/doctest) D
/R37 (https://cppget.org/libboost-test) D
/R38 (https://lists.build2.org/) D
/R39 (https://spdx.org/licenses/) D
/R40 (https://build2.org/bpkg/doc/build2-package-manager-manual.xhtml#manifest-package-license) D
/R41 (https://github.com/build2-packaging/zstd/blob/master/libzstd/PACKAGE-README.md) D
/R42 (https://github.com/build2-packaging/libevent/blob/main/PACKAGE-README.md) D
/R43 (https://github.com/build2-packaging/libevent) D
/R44 (https://github.com/build2-packaging/zstd/blob/master/zstd/PACKAGE-README.md) D
/R45 (https://github.com/build2-packaging/xxd/blob/master/xxd/README.md) D
/R46 (https://github.com/build2-packaging/xxd) D
/R47 (https://github.com/build2-packaging/zstd/blob/master/README.md) D
/R48 (https://build2.org/community.xhtml#stage) D
/R49 (https://github.com/cppget/) D
/R50 (https://queue.cppget.org/?about) D
/R51 (https://github.com/build2/bpkg-util) D
/R52 (https://www.kernel.org/doc/html/latest/process/submitting-patches.html#using-reported-by-tested-by-reviewed-by-suggested-by-and-fixes) D
/R53 (https://cppget.org/?advanced-search) D
/R54 (https://cppget.org/?advanced-search&amp;rp=pkg%3Acppget.org%2Ftesting&amp;rv=unreviewed) D
/R55 (https://raw.githubusercontent.com/build2/build2-toolchain/master/doc/packaging-initial-review-checklist.md) D
/Ba f D /BO 0 D Bs
/UR (-) D
/Ti (The build2 Packaging Guide) D
/Au () D
/Df f D
/ME [(0.18)(Packaging Guide)(2014-2025 the build2 authors)(toolchain)] D
Pt
/BO 0 D TC /Ba f D Bs /AU f D /UR () D RC ZF
 tH WB
ND 1 gt{Ts 3 mul Np 0()0 C()BD(The build2 Packaging Guide)ES()0 1 TN()EA()BN}if
1 NH le{123(1\240\240)1 C(Preface)WB 2 Sn()123 1 TN()EA()BN}if
1 NH le{124(2\240\240)1 C(1)WB 3 Sn( Introduction)124 1 TN()EA()BN}if
2 NH le{125(2.1\240\240)2 C(1.1)WB 4 Sn( Terminology)125 1 TN()EA()BN}if
1 NH le{126(3\240\240)1 C(2)WB 5 Sn( Common Guidelines)126 1 TN()EA()BN}if
2 NH le{127(3.1\240\240)2 C(2.1)WB 6 Sn( Setup the package repository)127 1 TN()EA()BN}if
3 NH le{128(3.1.1\240\240)3 C(2.1.1)WB 7 Sn( Check if package repository already
  exists)128 1 TN()EA()BN}if
3 NH le{129(3.1.2\240\240)3 C(2.1.2)WB 8 Sn( Use upstream repository name as package
  repository name)129 1 TN()EA()BN}if
3 NH le{130(3.1.3\240\240)3 C(2.1.3)WB 9 Sn( Create package repository in personal
  workspace)130 1 TN()EA()BN}if
3 NH le{131(3.1.4\240\240)3 C(2.1.4)WB 10 Sn( Initialize package repository with )SM(bdep
  new)ES()131 1 TN()EA()BN}if
3 NH le{132(3.1.5\240\240)3 C(2.1.5)WB 11 Sn( Add upstream repository as
  )SM(git)ES( submodule)132 1 TN()EA()BN}if
2 NH le{133(3.2\240\240)2 C(2.2)WB 12 Sn( Create package and generate )SM(buildfile)ES(
  templates)133 1 TN()EA()BN}if
3 NH le{134(3.2.1\240\240)3 C(2.2.1)WB 13 Sn( Decide on the package name)134 1 TN()EA()BN}if
3 NH le{135(3.2.2\240\240)3 C(2.2.2)WB 14 Sn( Decide on the package source code
  layout)135 1 TN()EA()BN}if
3 NH le{136(3.2.3\240\240)3 C(2.2.3)WB 15 Sn( Craft )SM(bdep new)ES( command
  line to create package)136 1 TN()EA()BN}if
3 NH le{137(3.2.4\240\240)3 C(2.2.4)WB 16 Sn( Review and test auto-generated
  )SM(buildfile)ES( templates)137 1 TN()EA()BN}if
3 NH le{138(3.2.5\240\240)3 C(2.2.5)WB 17 Sn( Create final package)138 1 TN()EA()BN}if
3 NH le{139(3.2.6\240\240)3 C(2.2.6)WB 18 Sn( Adjust package version)139 1 TN()EA()BN}if
2 NH le{140(3.3\240\240)2 C(2.3)WB 19 Sn( Fill package with source code and add
  dependencies)140 1 TN()EA()BN}if
3 NH le{141(3.3.1\240\240)3 C(2.3.1)WB 20 Sn( Initialize package in build
  configurations)141 1 TN()EA()BN}if
3 NH le{142(3.3.2\240\240)3 C(2.3.2)WB 21 Sn( Add dependencies)142 1 TN()EA()BN}if
3 NH le{143(3.3.3\240\240)3 C(2.3.3)WB 22 Sn( Fill with upstream source code)143 1 TN()EA()BN}if
2 NH le{144(3.4\240\240)2 C(2.4)WB 23 Sn( Adjust project-wide and source
  )SM(buildfiles)ES()144 1 TN()EA()BN}if
3 NH le{145(3.4.1\240\240)3 C(2.4.1)WB 24 Sn( Adjust project-wide build system files
  in )SM(build/)ES()145 1 TN()EA()BN}if
3 NH le{146(3.4.2\240\240)3 C(2.4.2)WB 25 Sn( Adjust source subdirectory
  )SM(buildfiles)ES()146 1 TN()EA()BN}if
3 NH le{147(3.4.3\240\240)3 C(2.4.3)WB 26 Sn( Adjust header
  )SM(buildfile)ES()147 1 TN()EA()BN}if
3 NH le{148(3.4.4\240\240)3 C(2.4.4)WB 27 Sn( Adjust source
  )SM(buildfile)ES(: overview)148 1 TN()EA()BN}if
3 NH le{149(3.4.5\240\240)3 C(2.4.5)WB 28 Sn( Adjust source
  )SM(buildfile)ES(: cleanup)149 1 TN()EA()BN}if
3 NH le{150(3.4.6\240\240)3 C(2.4.6)WB 29 Sn( Adjust source
  )SM(buildfile)ES(: dependencies)150 1 TN()EA()BN}if
3 NH le{151(3.4.7\240\240)3 C(2.4.7)WB 30 Sn( Adjust source
  )SM(buildfile)ES(: public headers)151 1 TN()EA()BN}if
3 NH le{152(3.4.8\240\240)3 C(2.4.8)WB 31 Sn( Adjust source
  )SM(buildfile)ES(: sources, private headers)152 1 TN()EA()BN}if
3 NH le{153(3.4.9\240\240)3 C(2.4.9)WB 32 Sn( Adjust source
  )SM(buildfile)ES(: build and export options)153 1 TN()EA()BN}if
3 NH le{154(3.4.10\240\240)3 C(2.4.10)WB 33 Sn( Adjust source
  )SM(buildfile)ES(: symbol exporting)154 1 TN()EA()BN}if
3 NH le{155(3.4.11\240\240)3 C(2.4.11)WB 34 Sn( Adjust source
  )SM(buildfile)ES(: shared library version)155 1 TN()EA()BN}if
3 NH le{156(3.4.12\240\240)3 C(2.4.12)WB 35 Sn( Adjust source
  )SM(buildfile)ES(: executables)156 1 TN()EA()BN}if
3 NH le{157(3.4.13\240\240)3 C(2.4.13)WB 36 Sn( Adjust source
  )SM(buildfile)ES(: extra requirements)157 1 TN()EA()BN}if
3 NH le{158(3.4.14\240\240)3 C(2.4.14)WB 37 Sn( Test library build)158 1 TN()EA()BN}if
2 NH le{159(3.5\240\240)2 C(2.5)WB 38 Sn( Make smoke test)159 1 TN()EA()BN}if
3 NH le{160(3.5.1\240\240)3 C(2.5.1)WB 39 Sn( Adjust project-wide build system
  files in )SM(tests/build/)ES()160 1 TN()EA()BN}if
3 NH le{161(3.5.2\240\240)3 C(2.5.2)WB 40 Sn( Convert generated test to library
  smoke test)161 1 TN()EA()BN}if
3 NH le{162(3.5.3\240\240)3 C(2.5.3)WB 41 Sn( Make smoke test: executables)162 1 TN()EA()BN}if
3 NH le{163(3.5.4\240\240)3 C(2.5.4)WB 42 Sn( Test locally)163 1 TN()EA()BN}if
3 NH le{164(3.5.5\240\240)3 C(2.5.5)WB 43 Sn( Test locally:
  installation)164 1 TN()EA()BN}if
3 NH le{165(3.5.6\240\240)3 C(2.5.6)WB 44 Sn( Test locally: distribution)165 1 TN()EA()BN}if
3 NH le{166(3.5.7\240\240)3 C(2.5.7)WB 45 Sn( Commit and test with CI)166 1 TN()EA()BN}if
2 NH le{167(3.6\240\240)2 C(2.6)WB 46 Sn( Replace smoke test with upstream tests)167 1 TN()EA()BN}if
3 NH le{168(3.6.1\240\240)3 C(2.6.1)WB 47 Sn( Understand how upstream tests
  work)168 1 TN()EA()BN}if
3 NH le{169(3.6.2\240\240)3 C(2.6.2)WB 48 Sn( Convert smoke test to upstream
  tests)169 1 TN()EA()BN}if
3 NH le{170(3.6.3\240\240)3 C(2.6.3)WB 49 Sn( Test locally)170 1 TN()EA()BN}if
3 NH le{171(3.6.4\240\240)3 C(2.6.4)WB 50 Sn( Commit and test with CI)171 1 TN()EA()BN}if
2 NH le{172(3.7\240\240)2 C(2.7)WB 51 Sn( Add upstream examples, benchmarks, if
  any)172 1 TN()EA()BN}if
2 NH le{173(3.8\240\240)2 C(2.8)WB 52 Sn( Adjust root files \201)SM(buildfile)ES(,
  )SM(manifest)ES(, etc\202)173 1 TN()EA()BN}if
3 NH le{174(3.8.1\240\240)3 C(2.8.1)WB 53 Sn( Adjust root )SM(buildfile)ES()174 1 TN()EA()BN}if
3 NH le{175(3.8.2\240\240)3 C(2.8.2)WB 54 Sn( Adjust root )SM(buildfile)ES(:
  other subdirectories)175 1 TN()EA()BN}if
3 NH le{176(3.8.3\240\240)3 C(2.8.3)WB 55 Sn( Adjust root
  )SM(buildfile)ES(: commit and test)176 1 TN()EA()BN}if
3 NH le{177(3.8.4\240\240)3 C(2.8.4)WB 56 Sn( Adjust )SM(manifest)ES()177 1 TN()EA()BN}if
3 NH le{178(3.8.5\240\240)3 C(2.8.5)WB 57 Sn( Adjust )SM(manifest)ES(:
  )SM(summary)ES()178 1 TN()EA()BN}if
3 NH le{179(3.8.6\240\240)3 C(2.8.6)WB 58 Sn( Adjust )SM(manifest)ES(:
  )SM(license)ES()179 1 TN()EA()BN}if
3 NH le{180(3.8.7\240\240)3 C(2.8.7)WB 59 Sn( Adjust )SM(manifest)ES(:
  commit and test)180 1 TN()EA()BN}if
3 NH le{181(3.8.8\240\240)3 C(2.8.8)WB 60 Sn( Adjust
  )SM(PACKAGE-README.md)ES()181 1 TN()EA()BN}if
2 NH le{182(3.9\240\240)2 C(2.9)WB 61 Sn( Adjust package repository
  )SM(README.md)ES()182 1 TN()EA()BN}if
2 NH le{183(3.10\240\240)2 C(2.10)WB 62 Sn( Release and publish)183 1 TN()EA()BN}if
3 NH le{184(3.10.1\240\240)3 C(2.10.1)WB 63 Sn( Transfer package
  repository)184 1 TN()EA()BN}if
3 NH le{185(3.10.2\240\240)3 C(2.10.2)WB 64 Sn( Release final version)185 1 TN()EA()BN}if
3 NH le{186(3.10.3\240\240)3 C(2.10.3)WB 65 Sn( Publish released version)186 1 TN()EA()BN}if
2 NH le{187(3.11\240\240)2 C(2.11)WB 66 Sn( Package version management)187 1 TN()EA()BN}if
3 NH le{188(3.11.1\240\240)3 C(2.11.1)WB 67 Sn( New revision)188 1 TN()EA()BN}if
3 NH le{189(3.11.2\240\240)3 C(2.11.2)WB 68 Sn( New version)189 1 TN()EA()BN}if
3 NH le{190(3.11.3\240\240)3 C(2.11.3)WB 69 Sn( New version:
  create new work branch)190 1 TN()EA()BN}if
3 NH le{191(3.11.4\240\240)3 C(2.11.4)WB 70 Sn( New version: open
  new version)191 1 TN()EA()BN}if
3 NH le{192(3.11.5\240\240)3 C(2.11.5)WB 71 Sn( New version:
  update )SM(upstream)ES( submodule)192 1 TN()EA()BN}if
3 NH le{193(3.11.6\240\240)3 C(2.11.6)WB 72 Sn( New version:
  review upstream changes)193 1 TN()EA()BN}if
3 NH le{194(3.11.7\240\240)3 C(2.11.7)WB 73 Sn( New version:
  layout changes)194 1 TN()EA()BN}if
3 NH le{195(3.11.8\240\240)3 C(2.11.8)WB 74 Sn( New
  version: new/old dependencies)195 1 TN()EA()BN}if
3 NH le{196(3.11.9\240\240)3 C(2.11.9)WB 75 Sn( New version:
  new/old source files)196 1 TN()EA()BN}if
3 NH le{197(3.11.10\240\240)3 C(2.11.10)WB 76 Sn( New version:
  changes to build system)197 1 TN()EA()BN}if
3 NH le{198(3.11.11\240\240)3 C(2.11.11)WB 77 Sn( New version:
  other new/old files/subdirectories)198 1 TN()EA()BN}if
3 NH le{199(3.11.12\240\240)3 C(2.11.12)WB 78 Sn( New version:
  review )SM(manifest)ES( and )SM(PACKAGE-README.md)ES()199 1 TN()EA()BN}if
3 NH le{200(3.11.13\240\240)3 C(2.11.13)WB 79 Sn( New version:
  review repository )SM(README.md)ES()200 1 TN()EA()BN}if
3 NH le{201(3.11.14\240\240)3 C(2.11.14)WB 80 Sn( New version:
  review/fix accumulated issues)201 1 TN()EA()BN}if
3 NH le{202(3.11.15\240\240)3 C(2.11.15)WB 81 Sn( New version: test
  locally and with CI)202 1 TN()EA()BN}if
3 NH le{203(3.11.16\240\240)3 C(2.11.16)WB 82 Sn( New version:
  merge, release, and publish)203 1 TN()EA()BN}if
3 NH le{204(3.11.17\240\240)3 C(2.11.17)WB 83 Sn( New version/revision in
  old release series)204 1 TN()EA()BN}if
1 NH le{205(4\240\240)1 C(3)WB 84 Sn( What Not to Do)205 1 TN()EA()BN}if
2 NH le{206(4.1\240\240)2 C(3.1)WB 85 Sn( Don't write )SM(buildfiles)ES( from
  scratch, use )SM(bdep-new)ES()206 1 TN()EA()BN}if
2 NH le{207(4.2\240\240)2 C(3.2)WB 86 Sn( Avoid fixing upstream issues in the
  )SM(build2)ES( package)207 1 TN()EA()BN}if
2 NH le{208(4.3\240\240)2 C(3.3)WB 87 Sn( Avoid changing upstream source code
  layout)208 1 TN()EA()BN}if
2 NH le{209(4.4\240\240)2 C(3.4)WB 88 Sn( Don't make library header-only if it can be
  compiled)209 1 TN()EA()BN}if
2 NH le{210(4.5\240\240)2 C(3.5)WB 89 Sn( Don't bundle dependencies)210 1 TN()EA()BN}if
2 NH le{211(4.6\240\240)2 C(3.6)WB 90 Sn( Don't build your main targets
  in the root )SM(buildfile)ES()211 1 TN()EA()BN}if
2 NH le{212(4.7\240\240)2 C(3.7)WB 91 Sn( Don't make extensive changes in a
  revision)212 1 TN()EA()BN}if
1 NH le{213(5\240\240)1 C(4)WB 92 Sn( Packaging HOWTO)213 1 TN()EA()BN}if
2 NH le{214(5.1\240\240)2 C(4.1)WB 93 Sn( How do I patch upstream source
  code?)214 1 TN()EA()BN}if
3 NH le{215(5.1.1\240\240)3 C(4.1.1)WB 94 Sn( Modifying upstream source
  code manually)215 1 TN()EA()BN}if
3 NH le{216(5.1.2\240\240)3 C(4.1.2)WB 95 Sn( Modifying upstream source
  code during build)216 1 TN()EA()BN}if
3 NH le{217(5.1.3\240\240)3 C(4.1.3)WB 96 Sn( Modifying upstream source
  code with C/C++ preprocessor)217 1 TN()EA()BN}if
2 NH le{218(5.2\240\240)2 C(4.2)WB 97 Sn( How do I deal with bad header
  inclusion practice?)218 1 TN()EA()BN}if
2 NH le{219(5.3\240\240)2 C(4.3)WB 98 Sn( How do I handle extra header
  installation subdirectory?)219 1 TN()EA()BN}if
2 NH le{220(5.4\240\240)2 C(4.4)WB 99 Sn( How do I handle headers without an
  extension?)220 1 TN()EA()BN}if
2 NH le{221(5.5\240\240)2 C(4.5)WB 100 Sn( How do I expose extra debug macros of a
  library?)221 1 TN()EA()BN}if
2 NH le{222(5.6\240\240)2 C(4.6)WB 101 Sn( How do I deal with tests that don't
  terminate?)222 1 TN()EA()BN}if
2 NH le{223(5.7\240\240)2 C(4.7)WB 102 Sn( How do I deal with compiler/linker running out
  of RAM?)223 1 TN()EA()BN}if
1 NH le{224(6\240\240)1 C(5)WB 103 Sn( Packaging FAQ)224 1 TN()EA()BN}if
2 NH le{225(6.1\240\240)2 C(5.1)WB 104 Sn( Publishing FAQ)225 1 TN()EA()BN}if
3 NH le{226(6.1.1\240\240)3 C(5.1.1)WB 105 Sn( Why is my package in )SM(alpha)ES(
  rather than )SM(stable)ES(?)226 1 TN()EA()BN}if
3 NH le{227(6.1.2\240\240)3 C(5.1.2)WB 106 Sn( Where to publish if package requires staged
  toolchain?)227 1 TN()EA()BN}if
3 NH le{228(6.1.3\240\240)3 C(5.1.3)WB 107 Sn( Why "project owner authentication failed"
  while publishing?)228 1 TN()EA()BN}if
1 NH le{229(7\240\240)1 C(6)WB 108 Sn( Package Review)229 1 TN()EA()BN}if
2 NH le{230(7.1\240\240)2 C(6.1)WB 109 Sn( Reviewing initial package submission)230 1 TN()EA()BN}if
3 NH le{231(7.1.1\240\240)3 C(6.1.1)WB 110 Sn( Create review issue)231 1 TN()EA()BN}if
3 NH le{232(7.1.2\240\240)3 C(6.1.2)WB 111 Sn( Create review pull request)232 1 TN()EA()BN}if
3 NH le{233(7.1.3\240\240)3 C(6.1.3)WB 112 Sn( Go through review checklist)233 1 TN()EA()BN}if
3 NH le{234(7.1.4\240\240)3 C(6.1.4)WB 113 Sn( Add review outcome comment)234 1 TN()EA()BN}if
3 NH le{235(7.1.5\240\240)3 C(6.1.5)WB 114 Sn( Finish successful review)235 1 TN()EA()BN}if
3 NH le{236(7.1.6\240\240)3 C(6.1.6)WB 115 Sn( Continue with unsuccessful review)236 1 TN()EA()BN}if
3 NH le{237(7.1.7\240\240)3 C(6.1.7)WB 116 Sn( Send review notification email)237 1 TN()EA()BN}if
2 NH le{238(7.2\240\240)2 C(6.2)WB 117 Sn( Reviewing new version submission)238 1 TN()EA()BN}if
3 NH le{239(7.2.1\240\240)3 C(6.2.1)WB 118 Sn( Determine the extent of changes)239 1 TN()EA()BN}if
3 NH le{240(7.2.2\240\240)3 C(6.2.2)WB 119 Sn( Create review issue)240 1 TN()EA()BN}if
3 NH le{241(7.2.3\240\240)3 C(6.2.3)WB 120 Sn( Finish successful review)241 1 TN()EA()BN}if
3 NH le{242(7.2.4\240\240)3 C(6.2.4)WB 121 Sn( Continue with unsuccessful
  review)242 1 TN()EA()BN}if
2 NH le{243(7.3\240\240)2 C(6.3)WB 122 Sn( Reviewing new revision submission)243 1 TN()EA()BN}if
/OU t D /Cb Db D NP Ep ET 
/Cb Db D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc

/Ba f D /BO 0 D Bs
/UR (-) D
/Ti (The build2 Packaging Guide) D
/Au () D
/Df f D
/ME [(0.18)(Packaging Guide)(2014-2025 the build2 authors)(toolchain)] D

NP RC ZF
()2 Sl()WB 0 Sn(
)BR()WB 1 Sn(
   
  )0 1 0 H(Preface)WB 123 Sn()WB 2 Sn()EH(

  )0 P(This document provides guidelines for converting third-party C/C++
  projects to the )SM(build2)ES( build system and making them available
  as packages from )R1 2 A(cppget.org)EA(, the
  )SM(build2)ES( community's central package repository. For additional
  information, including documentation for individual )SM(build2)ES(
  toolchain components, man pages, HOWTOs, etc., refer to the project )R2 2 A(Documentation)EA( page.)EP(

  )0 1 1 H(1)WB 124 Sn()WB 3 Sn( Introduction)EH(

  )0 P(The aim of this guide is to ease the conversion of third-party C/C++
  projects to the )SM(build2)ES( build system and publishing them to the
  )R1 2 A(cppget.org)EA( package repository by codifying
  the best practices and techniques. By following the presented guidelines you
  will also make it easier for others to review your work and help with
  ongoing maintenance.)EP(

  )BR(
  )0 P(A )SM(build2)ES(-based project can only consume packages that use
  the )SM(build2)ES( build system \201with the exception of )R3 2 A(system-installed
  packages)EA(\202. In other words, there is no support for "wrapping" or
  otherwise adapting third-party projects' existing build systems. While
  replacing the build system unquestionably requires more work upfront, the
  )SM(build2)ES( project's experience is that the long-term benefits of
  this effort are well justified \201see )R4 2 A(How does
  )SM(build2)ES( compare to other package managers?)EA( for details\202.)EP(
  )BR(

  )0 P(The primary focus of this guide is existing C/C++ projects that use a
  different build system and that are maintained by a third-party, which we
  will refer to as )I(upstream)ES(. Unless upstream is willing to incorporate
  support for )SM(build2)ES( directly into their repository, such
  projects are normally packaged for )SM(build2)ES( in a separate
  )SM(git)ES( repository under the )R5 2 A(github.com/build2-packaging)EA(
  organization. Note, however, that many of the presented guidelines are also
  applicable when converting your own projects \201that is, where you are the
  upstream\202 as well as projects that use languages other than C or C++.)EP(

  )0 P(Most C/C++ packages that are published to )R1 2 A(cppget.org)EA( are either libraries or executables
  \201projects that provide both are normally split into several packages\202 with
  libraries being in the strong majority. Libraries are also generally more
  difficult to build correctly. As a result, this guide uses libraries as a
  baseline. In most cases, a library-specific step is easily distinguished as
  such and can be skipped when dealing with executables. And in cases where a
  more nuanced change is required, a note will be provided.)EP(

  )0 P(At the high-level, packaging a third-party project involves the following
  steps:)EP(

  )4 OL(  )-1 LI(Create the )SM(git)ES( repository and import upstream source
  code.

  )-1 LI(Generate )SM(buildfile)ES( templates that match upstream
  layout.

  )-1 LI(Tweak the generated )SM(buildfiles)ES( to match upstream
  build.

  )-1 LI(Test locally and using the )R6 2 A()SM(build2)ES( CI service)EA(.

  )-1 LI(Release and publish the package to )R1 2 A(cppget.org)EA(.
  )LO(

  )0 P(Once this process is completed and the package is published, new releases
  normally require a small amount of work provided there are no drastic
  changes in the upstream layout or build. The sequence of steps for a new
  release would typical look like this:)EP(

  )4 OL(  )-1 LI(Add new and/or remove old upstream source code, if any.

  )-1 LI(Tweak )SM(buildfiles)ES( to match changes to upstream build, if
  any.

  )-1 LI(Test locally and using the )R6 2 A()SM(build2)ES( CI service)EA(.

  )-1 LI(Release and publish the package to )R1 2 A(cppget.org)EA(.
  )LO(

  )0 P(While packaging a simple library or executable is relatively
  straightforward, the C and C++ languages and their ecosystems are infamous
  for a large amount of variability in the platforms, compilers, source code
  layouts, and build systems used. This leads to what looks like an endless
  list of special considerations that are only applicable in certain, more
  complex cases.)EP(

  )0 P(As result, the presented guidelines are divided into four chapters: )0 5 1 A(Common Guidelines)5 0 TN TL()Ec /AF f D( cover steps that are applicable to most
  packaging efforts. As mentioned earlier, these steps will assume packaging a
  library but they should be easy to adapt to executables. This chapter is
  followed by )0 84 1 A(What Not to Do)84 0 TN TL()Ec /AF f D( which covers the common
  packaging mistakes and omissions. These are unfortunately relatively common
  because experience with other build systems often does not translate
  directly to )SM(build2)ES( and some techniques \201such as header-only
  libraries\202 are discouraged. The last two chapters are )0 92 1 A(HOWTO)92 0 TN TL()Ec /AF f D( and )0 103 1 A(FAQ)103 0 TN TL()Ec /AF f D(. The former covers the
  above-mentioned long list of special considerations that are only applicable
  in certain cases while the latter answer frequent packaging-related
  questions.)EP(

  )0 P(Besides the presented guidelines, you may also find the existing packages
  found in )R5 2 A(github.com/build2-packaging)EA( a
  good source of example material. The repositories pinned to the front page
  are the recommended starting point.)EP(

  )0 P(This guide assumes familiarity with the )SM(build2)ES( toolchain. At
  the minimum you should have read through )0 2 A(The )SM(build2)ES( Toolchain
  Introduction)EA( and the )0 2 A(Introduction)EA(
  chapter in the build system manual. Ideally, you should also have some
  experience using )SM(build2)ES( in your own projects.)EP(

  )0 P(In this guide we will only show the UNIX version of the commands. In most
  cases making a Windows version is a simple matter of adjusting paths and, if
  used, line continuations. And where this is not the case a note will be
  provided showing the equivalent Windows command.)EP(

  )0 2 2 H(1.1)WB 125 Sn()WB 4 Sn( Terminology)EH(

  )0 P(We use the term )I(upstream)ES( to refer collectively to the third-party
  project as well as to its authors. For example, we may say, "upstream does
  not use semver" meaning that the upstream project does not use semver for
  versioning. Or we may say, "upstream released a new version" meaning that
  the upstream project's authors released a new version.)EP(

  )0 P(We will often use )I(upstream)ES( as a qualifier to refer to a specific
  part of the upstream project. Commonly used qualified terms like this
  include:)EP(

  )0 DL(  )0 DT()I(upstream repository)ES(
  )DD(The version control \201normally )SM(git)ES(\202 repository of the
  third-party project.

  )0 DT()I(upstream source code)ES(
  )DD(The C/C++ source code that constitutes the third-party project.

  )0 DT()I(upstream layout)ES(
  )DD(The directory structure and location of source code in the third-party
  project.

  )0 DT()I(upstream build system)ES(
  )DD(The equivalents of )SM(buildfiles)ES( that are used by the
  third-party project to build its source code, run tests, etc. For example,
  if upstream uses CMake, then all the )SM(CMakeLists.txt)ES(,
  )SM(*.cmake)ES(, etc., files will constitute its build system.
  )LD(

  )0 P(To avoid confusion, in this guide we will always use the term
  )I(project)ES( to refer to upstream and )I(package)ES( to refer to its
  )SM(build2)ES( conversion, even though we would normally call our own
  )SM(build2)ES(-based work a project, not a package \201see )0 2 A(Project
  Structure)EA( for details on the )SM(build2)ES( terminology in this
  area\202. Some commonly used )SM(build2)ES(-side terms in this guide
  include:)EP(

  )0 DL(  )0 DT()I(package )SM(git)ES( repository)ES(
  )DD(The )SM(git)ES( repository that hosts the package of the upstream
  project.

  )0 DT()I(multi-package repository)ES(
  )DD(Sometimes it makes sense to split the upstream project into multiple
  )SM(build2)ES( packages \201for example, a library and an executable\202. In
  this case the package repository structure must become multi-package.
  )LD(

  )0 1 3 H(2)WB 126 Sn()WB 5 Sn( Common Guidelines)EH(

  )0 P(This chapter describes the recommended sequence of steps for packaging a
  third-party project for )SM(build2)ES( with the end-goal of publishing
  it to the )R1 2 A(cppget.org)EA( package
  repository.)EP(

  )0 2 4 H(2.1)WB 127 Sn()WB 6 Sn( Setup the package repository)EH(

  )0 P(This section covers the creation of the package )SM(git)ES(
  repository and the importation of the upstream source code.)EP(

  )0 3 5 H(2.1.1)WB 128 Sn()WB 7 Sn( Check if package repository already
  exists)EH(

  )0 P(Before deciding to package a third-party project you have presumably
  checked on )R1 2 A(cppget.org)EA( if someone has
  already packaged it. There are several other places that make sense to check
  as well:)EP(

  )UL(  )-1 LI()R7 2 A(queue.cppget.org)EA( contains
  packages that have been submitted but not yet published.

  )-1 LI()R8 2 A(queue.stage.build2.org)EA(
  contains packages that have been submitted but can only be published after
  the next release of the )SM(build2)ES( toolchain \201see )0 106 1 A(Where to publish if package requires staged
  toolchain?)106 0 TN TL()Ec /AF f D( for background\202.

  )-1 LI()R5 2 A(github.com/build2-packaging)EA(
  contains all the third-party package repositories. Someone could already be
  working on the package but haven't yet published it.

  )-1 LI()R9 2 A(github.com/build2-packaging/WISHLIST)EA(
  contains as issues projects that people wish were packaged. These may
  contain offers to collaborate or announcements of ongoing work.
  )LU(

  )0 P(In all these cases you should be able to locate the package
  )SM(git)ES( repository and/or connect with others in order to
  collaborate on the packaging work. If the existing effort looks abandoned
  \201for example, there hasn't been any progress for a while and the existing
  maintainer doesn't respond\202 and you would like to take over the package, )R10 2 A(get in touch)EA(.)EP(

  )0 3 6 H(2.1.2)WB 129 Sn()WB 8 Sn( Use upstream repository name as package
  repository name)EH(

  )0 P(It is almost always best to use the upstream repository name as the
  package repository name. If there is no upstream repository \201for example,
  because the project doesn't use a version control system\202, the name used in
  the source archive distribution would be the natural fallback choice.)EP(

  )BR(
  )0 P(See )0 13 1 A(Decide on the package name)13 0 TN TL()Ec /AF f D( for the
  complete picture on choosing names.)EP(
  )BR(

  )0 3 7 H(2.1.3)WB 130 Sn()WB 9 Sn( Create package repository in personal
  workspace)EH(

  )0 P(For a third-party project, the end result that we are aiming for is a
  package repository under the )R5 2 A(github.com/build2-packaging)EA(
  organization.)EP(

  )BR(
  )0 P(We require all the third-party projects that are published to )R1 2 A(cppget.org)EA( to be under the )R5 2 A(github.com/build2-packaging)EA(
  organization in order to ensure some continuity in case the original
  maintainer loses interest, etc. You will still be the owner of the
  repository and by hosting your packaging efforts under this organization \201as
  opposed to, say, your personal workspace\202 you make it easier for others to
  discover your work and to contribute to the package maintenance.)EP(

  )0 P(Note that this requirement does not apply to your own projects \201that is,
  where you are the upstream\202 and where the )SM(build2)ES( support is
  part of the upstream repository. Such projects can live anywhere one can
  host a )SM(git)ES( repository. Furthermore, if upstream adds support
  for )SM(build2)ES( in a package currently hosted under )R5 2 A(github.com/build2-packaging)EA(,
  then all future versions should normally be published directly from the
  upstream repository.)EP(

  )0 P(Finally, a note on the use of )SM(git)ES( and GitHub: if for some
  reason you are unable to use either, )R10 2 A(get in touch)EA( to discuss
  alternatives.)EP(
  )BR(

  )0 P(However, the recommended approach is to start with a repository in your
  personal workspace and then, when it is ready or in a reasonably complete
  state, transfer it to )R5 2 A(github.com/build2-packaging)EA(.
  This gives you the freedom to make destructive changes to the repository
  \201including deleting it and starting over\202 during the initial packaging work.
  It also removes the pressure to perform: you can give it a try and if things
  turn out more difficult than you expected, you can just drop the
  repository.)EP(

  )BR(
  )0 P(For repositories under )R5 2 A(github.com/build2-packaging)EA(
  the )SM(master)ES(/)SM(main)ES( branch is protected: it cannot be
  deleted and its commit history cannot be overwritten with a forced push.)EP(
  )BR(

  )BR(
  )0 P(While you can use any name for a repository under the personal workspace,
  under )R5 2 A(github.com/build2-packaging)EA(
  it should follow the )0 8 1 A(Use upstream repository name
  as package repository name)8 0 TN TL()Ec /AF f D( guideline. In particular, there should be no
  prefixes like )SM(build2-)ES( or suffixes like )SM(-package)ES(.
  If the repository under your personal workspace does not follow this
  guideline, you will need to rename it before transferring it to the )R5 2 A(github.com/build2-packaging)EA(
  organization.)EP(
  )BR(

  )0 P(There is one potential problem with this approach: it is possible that
  several people will start working on the same third-party project without
  being aware of each other's efforts. If the project you are packaging is
  relatively small and you don't expect it to take more than a day or two,
  then this is probably not worth worrying about. For bigger projects,
  however, it makes sense to announce your work by creating \201or updating\202 the
  corresponding issue in )R11 2 A(github.com/build2-packaging/WISHLIST)EA(.)EP(

  )0 P(To put it all together, the recommended sequence of actions for this
  step:)EP(

  )4 OL(  )-1 LI(Create a new empty repository under your personal workspace from the
  GitHub UI.

  )-1 LI(Set the repository description to )SM(build2 package for
  <name>)ES(, where )SM(<name>)ES( is the third-party project
  name.

  )-1 LI(Make the repository public \201otherwise you won't be able to CI it\202.

  )-1 LI(Don't automatically add any files \201)SM(README)ES(,
  )SM(LICENSE)ES(, etc\202.

  )-1 LI(Clone the empty repository to your machine \201using the SSH
  protocol\202.
  )LO(

  )BR(
  )0 P(Since this is your personal repository, you can do the initial work
  directly in )SM(master)ES(/)SM(main)ES( or in a separate branch,
  it's up to you.)EP(
  )BR(

  )0 P(As a running example, let's assume we want to package a library called
  )SM(foo)ES( whose upstream repository is at
  )SM(https://github.com/<upstream>/foo.git)ES(. We have created its
  package repository at )SM(https://github.com/<personal>/foo.git)ES(
  \201with the )SM(build2 package for foo)ES( description\202 and can now clone
  it:)EP(

  ) 1 45 PR($ git clone git@github.com:<personal>/foo.git)RP(

  )0 3 8 H(2.1.4)WB 131 Sn()WB 10 Sn( Initialize package repository with )SM(bdep
  new)ES()EH(

  )0 P(Change to the root directory of the package repository that you have
  cloned in the previous step and run \201continuing with our )SM(foo)ES(
  example\202:)EP(

  ) 12 50 PR($ cd foo/ # Change to the package repository root.
$ bdep new --type empty,third-party
$ tree -a .
./
|-- .bdep/
|\302\240\302\240 \267-- ...
|-- .git/
|\302\240\302\240 \267-- ...
|-- .gitattributes
|-- .gitignore
|-- README.md
\267-- repositories.manifest)RP(

  )BR(
  )0 P(We use the special )SM(third-party)ES( sub-option which is meant for
  converting third-party projects to )SM(build2)ES(. See )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( for
  details.)EP(
  )BR(

  )0 P(This command creates a number of files in the root of the repository:)EP(

  )0 DL(  )0 DT()SM(README.md)ES(
  )DD(This is the repository )SM(README.md)ES(. We will discuss the
  recommended content for this file later.

  )0 DT()SM(repositories.manifest)ES(
  )DD(This file specifies the repositories from which this project will obtain
  its dependencies \201see )0 2 A(Adding and
  Removing Dependencies)EA(\202. If the project you are packaging has no
  dependencies, then you can safely remove this file \201it's easy to add later
  if this changes\202. And for projects that do have dependencies we will discuss
  the appropriate changes to this file later.

  )0 DT()SM(.gitattributes)ES( and
  )SM(.gitignore)ES(
  )DD(These are the )SM(git)ES( infrastructure files for the repository.
  You shouldn't normally need to change anything in them at this stage \201see
  the comments inside for details\202.
  )LD(

  )0 P(Next add and commit these files:)EP(

  ) 4 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Initialize package repository")RP(

  )BR(
  )0 P(In these guidelines we will be using the package repository setup that is
  capable of having multiple packages \201referred to as )I(multi-package
  repository)ES(\202. This is recommended even for upstream projects that only
  provides a single package because it gives us the flexibility of adding new
  packages at a later stage without having to perform a major restructuring of
  our repository.)EP(

  )0 P(Note also that upstream providing multiple packages is not the only
  reason we may end up having multiple )SM(build2)ES( packages. Another
  common reason is factoring tests into a separate package due to a dependency
  on a testing framework \201see )R12 2 A(How
  do I handle tests that have extra dependencies?)EA( for background and
  details\202. While upstream adding new packages may not be very common,
  upstream deciding to use a testing framework is a lot more plausible.)EP(

  )0 P(The only notable drawback of using a multi-package setup with a single
  package is the extra subdirectory for the package and a few extra files
  \201such as )SM(packages.manifest)ES( that lists the packages\202 in the root
  of the repository. If you are certain that the project that you are
  converting is unlikely to have multiple packages \201for example, because you
  are the upstream\202 and won't need extra dependencies for its tests \201a
  reasonable assumption for a C project\202, then you could instead go with the
  single-package repository where the repository root is the package root. See
  )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  for details on how to initialize such a repository. In this guide, however,
  we will continue to assume a multi-package repository setup.)EP(
  )BR(

  )BR(
  )0 P(Make sure the first commit in the package repository contains no manual
  changes. In other words, it should only add files as generated by
  )SM(bdep-new)ES(. This is relied upon during the package review process
  \201see )0 111 1 A(Create review pull request)111 0 TN TL()Ec /AF f D( for
  details\202.)EP(
  )BR(

  )0 3 9 H(2.1.5)WB 132 Sn()WB 11 Sn( Add upstream repository as
  )SM(git)ES( submodule)EH(

  )0 P(If the third-party project is available from a )SM(git)ES(
  repository, then the recommended approach is to use the )SM(git)ES(
  submodule mechanism to make the upstream source code available inside the
  package repository, customarily in a subdirectory called
  )SM(upstream/)ES(.)EP(

  )BR(
  )0 P(While )SM(git)ES( submodules receive much criticism, in our case we
  use them exactly as intended: to select and track specific \201release\202 commits
  of an external project. As a result, there is nothing tricky about their use
  for our purpose and all the relevant commands will be provided and
  explained, in case you are not familiar with this )SM(git)ES(
  mechanism.)EP(
  )BR(

  )0 P(Given the upstream repository URL, to add it as a submodule, run the
  following command from the package repository root \201continuing with our
  )SM(foo)ES( example\202:)EP(

  ) 2 66 PR($ cd foo/ # Change to the package repository root.
$ git submodule add https://github.com/<upstream>/foo.git upstream)RP(

  )BR(
  )0 P(You should prefer )SM(https://)ES( over )SM(git://)ES( for the
  upstream repository URL since the )SM(git://)ES( protocol may not be
  accessible from all networks. Naturally, never use a URL that requires
  authentication, for example, SSH \201SSH URLs start with
  )SM(git@github.com)ES( for GitHub\202.)EP(
  )BR(

  )0 P(Besides the repository URL, you also need the commit of the upstream
  release which you will be packaging. It is common practice to tag releases
  so the upstream tags would be the first place to check. Failing that, you
  can always use the commit id.)EP(

  )0 P(Assuming the upstream release tag you are interested in is called
  )SM(vX.Y.Z)ES(, to update the )SM(upstream)ES( submodule to point
  to this release commit, run the following commands:)EP(

  ) 3 21 PR($ cd upstream/
$ git checkout vX.Y.Z
$ cd ../)RP(

  )0 P(Then add and commit these changes:)EP(

  ) 3 48 PR($ git add .
$ git status
$ git commit -m "Add upstream submodule, vX.Y.Z")RP(

  )0 P(Now we have all the upstream source code for the version that we are
  packaging available in the )SM(upstream/)ES( subdirectory of our
  repository.)EP(

  )0 P(The plan is to then use symbolic links \201symlinks\202 to non-invasively
  overlay the )SM(build2)ES(-related files \201)SM(buildfile)ES(,
  )SM(manifest)ES(, etc\202 with the upstream source code, if necessary
  adjusting upstream structure to split it into multiple packages and/or to
  better align with the source/output layouts recommended by
  )SM(build2)ES( \201see )R13 2 A(Using Symlinks in
  )SM(build2)ES( Projects)EA( for background and rationale\202. But before
  we can start adding symlinks to the upstream source \201and other files like
  )SM(README)ES(, )SM(LICENSE)ES(, etc\202, we need to generate the
  )SM(buildfile)ES( templates that match the upstream source code layout.
  This is the subject of the next section.)EP(

  )BR(
  )0 P(While on UNIX-like operating systems symlinks are in widespread use, on
  Windows it's a niche feature that unfortunately could be cumbersome to use
  \201see )R14 2 A(Symlinks
  and Windows)EA( for details\202. However, the flexibility afforded by symlinks
  when packaging third-party projects is unmatched by any other mechanism and
  we therefore use them despite potentially sub-optimal packaging experience
  on Windows.)EP(
  )BR(

  )0 2 10 H(2.2)WB 133 Sn()WB 12 Sn( Create package and generate )SM(buildfile)ES(
  templates)EH(

  )0 P(This section covers the addition of the package to the repository we have
  prepared in the previous steps and the generation of the
  )SM(buildfile)ES( templates that match the upstream source code
  layout.)EP(

  )0 3 11 H(2.2.1)WB 134 Sn()WB 13 Sn( Decide on the package name)EH(

  )0 P(While choosing the package repository name was pretty straightforward,
  things get less clear cut when it comes to the package name.)EP(

  )BR(
  )0 P(If you need a refresher on the distinction between projects and packages,
  see )0 4 1 A(Terminology)4 0 TN TL()Ec /AF f D(.)EP(
  )BR(

  )0 P(Picking a name for a package that provides an executable is still
  relatively straightforward: you should use the upstream name \201which is
  usually the same as the upstream project name\202 unless there is a good reason
  to deviate. One recommended place to check before deciding on a name is the
  )R15 2 A(Debian package repository)EA(. If
  their package name differs from upstream, then there is likely a good reason
  for that and it is worth trying to understand what it is.)EP(

  )BR(
  )0 P(Tip: when trying to find the corresponding Debian package, search for the
  executable file name in the package contents if you cannot find the package
  by its upstream name. Also consider searching in the )SM(unstable)ES(
  distribution in addition to )SM(stable)ES( for newer packages.)EP(
  )BR(

  )0 P(Picking a name for a package that provides a library is where things can
  get more complicated. While all the recommendations that have been listed
  for executables apply equally to libraries, there are additional
  considerations.)EP(

  )0 P(In )SM(build2)ES( we recommend \201but not require\202 that new library
  projects use a name that starts with )SM(lib)ES( in order to easily
  distinguish them from executables and avoid any clashes, potential in the
  future \201see )0 2 A(Canonical
  Project Structure)EA( for details\202. To illustrate the problem, consider the
  )SM(zstd)ES( project which provides a library and an executable. In
  upstream repository both are part of the same codebase that doesn't try to
  separate them into packages so that, for example, library could be used
  without downloading and building the executable. In )SM(build2)ES(,
  however, we do need to split them into two separate packages and both
  packages cannot be called )SM(zstd)ES(. So we call them
  )SM(zstd)ES( and )SM(libzstd)ES(.)EP(

  )BR(
  )0 P(If you are familiar with the Debian package naming policy, you will
  undoubtedly recognize this approach. In Debian all the library packages
  \201with very few exceptions\202 start with the )SM(lib)ES( prefix. So when
  searching for an upstream name in the )R15 2 A(Debian package repository)EA( make sure
  to prefix it with )SM(lib)ES( \201unless it already starts with this
  prefix, of course\202.)EP(
  )BR(

  )0 P(This brings the question of what to do about third-party libraries:
  should we add the )SM(lib)ES( prefix to the package name if it's not
  already there? Unfortunately, there is no clear cut answer and whichever
  decision you make, there will be drawbacks. Specifically, if you add the
  )SM(lib)ES( prefix, the main drawback is that the package name now
  deviates from the upstream name and if the project maintainer ever decides
  to add )SM(build2)ES( support to the upstream repository, there could
  be substantial friction. On the other hand, if you don't add the
  )SM(lib)ES( prefix, then you will always run the risk of a future clash
  with an executable name. And, as was illustrated with the )SM(zstd)ES(
  example, a late addition of an executable won't necessarily cause any issues
  to upstream. As a result, we don't have a hard requirement for the
  )SM(lib)ES( prefix unless there is already an executable that would
  cause the clash \201this applies even if it's not being packaged yet or is
  provided by an unrelated project\202. If you don't have a strong preference, we
  recommend that you add the )SM(lib)ES( prefix \201unless it is already
  there\202. In particular, this will free you from having to check for any
  potential clashes. See )R16 2 A(How
  should I name packages when packaging third-party projects?)EA( for
  additional background and details.)EP(

  )0 P(To build some intuition for choosing package names, let's consider
  several real examples. We start with executables:)EP(

  ) 11 70 PR(  upstream  |   upstream    |   Debian   | build2 package|   build2
project name|executable name|package name|repository name|package name
------------+---------------+------------+---------------+------------
byacc        byacc           byacc        byacc           byacc
sqlite       sqlite3         sqlite3      sqlite          sqlite3
vim          xxd             xxd          xxd             xxd
OpenBSD      m4              -            openbsd-m4      openbsd-m4
qtbase 5     moc             qtbase5-\200    Qt5             Qt5Moc
                             dev-tools
qtbase 6     moc             qt6-base-\200   Qt6             Qt6Moc
                             dev-tools)RP(

  )0 P(The examples are arranged from the most straightforward naming to the
  least. The last two examples show that sometimes, after carefully
  considering upstream naming, you nevertheless have no choice but to ignore
  it and forge your own path.)EP(

  )0 P(Next let's look at library examples. Notice that some use the same
  )SM(build2)ES( package repository name as the executables above. This
  means they are part of the same multi-package repository.)EP(

  ) 11 70 PR(  upstream  |  upstream     |   Debian   | build2 package|   build2
project name|library name   |package name|repository name|package name
------------+---------------+------------+---------------+------------
libevent     libevent        libevent     libevent        libevent
brotli       brotli          libbrotli    brotli          libbrotli
zlib         zlib            zlib         zlib            libz
sqlite       libsqlite3      libsqlite3   sqlite          libsqlite3
libsig\200      libsigc++       libsigc++    libsig\200         libsigc++
cplusplus                                 cplusplus
qtbase 5     QtCore          qtbase5-dev  Qt5             libQt5Core
qtbase 6     QtCore          qt6-base-dev Qt6             libQt6Core)RP(

  )0 P(If an upstream project is just a single library, then the project name is
  normally the same as the library name \201but there are exceptions, like
  )SM(libsigcplusplus)ES( in the above table\202. However, when looking at
  the upstream repository that contains multiple components \201libraries and/or
  executables, like )SM(qtcore)ES( in the above example\202, it may not be
  immediately obvious what the upstream's library names are. In such cases,
  the corresponding Debian packages can really help clarify the situation.
  Failing that, look into the existing build system. In particular, if it
  generates the )SM(pkg-config)ES( file, then the name of this file is
  usually the upstream library name.)EP(

  )BR(
  )0 P(Looking at the names of the library binaries is less helpful because on
  UNIX-like systems they must start with the )SM(lib)ES( prefix. And on
  Windows the names of library binaries often embed extra information
  \201static/import, debug/release, etc\202 and may not correspond directly to the
  library name.)EP(
  )BR(

  )0 P(And, speaking of multiple components, if you realize the upstream project
  provides multiple libraries and/or executables, then you need to decide
  whether to split them into separate )SM(build2)ES( packages and if so,
  how. Here, again, the corresponding Debian packages can be a good reference
  point. Note, however, that we often deviate from Debian's splits, especially
  when it comes to libraries. Such differences are usually due to Debian
  focusing on binary packages while in )SM(build2)ES( we are focusing on
  source packages.)EP(

  )0 P(To give a few examples, )SM(libevent)ES( shown in the above table
  provides several libraries \201)SM(libevent-core)ES(,
  )SM(libevent-extra)ES(, etc\202 and in Debian it is actually split into
  several binary packages along these lines. In )SM(build2)ES(, however,
  there is a single source package that provides all these libraries with
  everything except )SM(libevent-core)ES( being optional. An example
  which shows the decision made in a different direction would be the Boost
  libraries: in Debian all the header-only Boost libraries are bundled into a
  single package while in )SM(build2)ES( they are all separate
  packages.)EP(

  )0 P(The overall criteria here can be stated as follows: if a small family of
  libraries provide complimentary functionality \201like )SM(libevent)ES(\202,
  then we put them all into a single package, usually making the additional
  functionality optional. However, if the libraries are independent \201like
  Boost\202 or provide alternative rather than complimentary functionality \201for
  example, like different backends in )SM(imgui)ES(\202, then we make them
  separate packages. Note that we never bundle an executable and a \201public\202
  library in a single package \201because, when consumed, they usually require
  different )0 2 A(dependency
  types)EA(: build-time vs run-time\202.)EP(

  )0 P(Note also that while it's a good idea to decide on the package split and
  all the package names upfront to avoid surprises later, you don't have to
  actually provide all the packages right away. For example, if upstream
  provides a library and an executable \201like )SM(zstd)ES(\202, you can start
  with the library and the executable package can be added later \201potentially
  by someone else\202.)EP(

  )BR(
  )0 P(In the "library and executable" case, if you plan to package both, the
  sensible strategy is to first completely package the library stopping short
  of releasing and publishing, then repeat the same process to package the
  executable, and finally release and publish both.)EP(
  )BR(

  )0 P(Admittedly, the recommendations in this section are all a bit fuzzy and
  one can choose different names or different package splits that could all
  seem reasonable. If you are unsure how to split the upstream project or what
  names to use, )R10 2 A(get in
  touch)EA( to discuss the alternatives. It can be quite painful to change
  these things after you have completed the remaining packaging steps.)EP(

  )0 P(Continuing with our )SM(foo)ES( example, we will follow the above
  recommendation and call the library package )SM(libfoo)ES(.)EP(

  )0 3 12 H(2.2.2)WB 135 Sn()WB 14 Sn( Decide on the package source code
  layout)EH(

  )0 P(Another aspect we need to decide on is the source code layout inside the
  package. Here we want to stay as close to the upstream layout as possible
  unless there are valid reasons to deviate. Staying close has the best chance
  of giving us a build without any compile errors since the header inclusion
  in the project can be sensitive to this layout. This also makes it easier
  for upstream to adopt the )SM(build2)ES( build.)EP(

  )0 P(Sometimes, however, there are good reasons for deviating from upstream,
  especially in cases where upstream is clearly following bad practices, for
  example including generically-named public headers without the library name
  as a subdirectory prefix. If you do decide to change the layout, it's
  usually less disruptive \201to the build\202 to rearrange things at the outer
  levels than at the inner. For example, it should normally be possible to
  move/rename the top-level )SM(tests/)ES( directory or to place the
  library source files into a subdirectory.)EP(

  )0 P(Our overall plan is to create the initial layout and
  )SM(buildfile)ES( templates automatically using )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( in
  the )SM(--package)ES( mode, then "fill" the package with upstream
  source code using symlinks, and finish off with tweaking the generated
  )SM(buildfiles)ES( to match the upstream build.)EP(

  )0 P(The main rationale for using )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  instead of doing everything by hand is that there are many nuances in
  getting the build right and auto-generated )SM(buildfiles)ES( had years
  of refinement and fine-tuning. The familiar structure also makes it easier
  for others to understand your build, for example while reviewing your
  package submission or helping out with maintenance.)EP(

  )0 P(The )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command supports a wide variety of )0 2 A(source layouts)EA(. While it
  may take a bit of time to understand the customization points necessary to
  achieve the desired layout for your first package, this experience will pay
  off in spades when you work on converting subsequent packages.)EP(

  )0 P(And so the focus of the following several steps is to iteratively
  discover the )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command line that best approximates the upstream layout. The recommended
  procedure is as follows:)EP(

  )4 OL(  )-1 LI(Study the upstream source layout and existing
  build system.

  )-1 LI(Craft and execute the )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command line necessary to achieve the upstream layout.

  )-1 LI(Study the auto-generated )SM(buildfiles)ES(
  for things that don't fit and need to change. But don't rush to start
  manually editing the result. First get an overview of the required changes
  and then check if it's possible to achieve these changes automatically using
  one of )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  sub-options. If that's the case, delete the package, and restart from step
  2.
  )LO(

  )0 P(This and the following two sections discuss each of these steps in more
  detail and also look at some examples.)EP(

  )0 P(The first step above is to study the upstream project in order to
  understand where the various parts are \201headers, sources, etc\202 and how they
  are built. Things that can help here include:)EP(

  )UL(  )-1 LI(Read through the existing build system definitions.

  )-1 LI(Try to build the project using the existing build system.

  )-1 LI(Try to install the project using the existing build system.

  )-1 LI(Look into the Debian package contents to see if there are any
  differences with regards to the installation locations.
  )LU(

  )BR(
  )0 P(If while studying the upstream build system you notice other
  requirements, for example, the need to compile source files other than C/C++
  \201such as Objective-C/C++, assembler, etc\202 or the need to generate files from
  )SM(.in)ES( templates \201or their )SM(.cmake)ES(/)SM(.meson)ES(
  equivalents\202, and are wondering how they would be handled in the
  )SM(build2)ES( build, see the )0 36 1 A(Adjust source
  )SM(buildfile)ES(: extra requirements)36 0 TN TL()Ec /AF f D( step for a collection of
  pointers.)EP(
  )BR(

  )0 P(For libraries, the first key pieces of information we need to find is how
  the public headers are included and where they are installed. The two common
  )I(good)ES( practices is to either include the public headers with a library
  name as a subdirectory, for example,
  )SM(#include\240<foo/util.h>)ES(, or to include the library name
  into each public header name, for example,
  )SM(#include\240<foo-util.h>)ES( or
  )SM(#include\240<foo.h>)ES( \201in the last example the header name
  is the library name itself, which is also fairly common\202. Unfortunately,
  there is also a fairly common )I(bad)ES( practice: having generically named
  headers \201such as )SM(util.h)ES(\202 included without the library name as a
  subdirectory.)EP(

  )BR(
  )0 P(The reason this is a bad practice is that libraries that have such
  headers cannot coexist, neither in the same build nor when installed. See )0 97 1 A(How do I deal with bad header inclusion
  practice?)97 0 TN TL()Ec /AF f D( if you encounter such a case. See )0 2 A(Canonical Project
  Structure)EA( for additional background and details.)EP(
  )BR(

  )0 P(Where should we look to get this information? While the library source
  files sound like a natural place, oftentimes they include own headers with
  the )SM("")ES( style inclusion, either because the headers are in the
  same directory or because the library build arranges for them to be found
  this way with additional header search paths. As a result, a better place to
  look could be the library's examples and/or tests. Some libraries also
  describe which headers they provide and how to include them in their
  documentation.)EP(

  )0 P(The way public headers are included normally determines where they are
  installed. If they are included with a subdirectory, then they are normally
  installed into the same subdirectory in, say, )SM(/usr/include/)ES(.
  Continuing with the above example, a header that is included as
  )SM(<foo/util.h>)ES( would normally be installed as
  )SM(/usr/include/foo/util.h)ES(. On the other hand, if the library name
  is part of the header name, then the headers are usually \201but not always\202
  installed directly into, say, )SM(/usr/include/)ES(, for example as
  )SM(/usr/include/foo-util.h)ES(.)EP(

  )BR(
  )0 P(While these are the commonly used installation schemes, there are
  deviations. In particular, in both cases upstream may choose to add an
  additional subdirectory when installing \201so the above examples will instead
  end up with, say, )SM(/usr/include/foo-v1/foo/util.h)ES( and
  )SM(/usr/include/foo-v1/sub/foo-util.h)ES(\202. See )0 98 1 A(How do I handle extra header
  installation subdirectory?)98 0 TN TL()Ec /AF f D( if you encounter such a case.)EP(
  )BR(

  )0 P(The inclusion scheme would normally also be recreated in the upstream
  source code layout. In particular, if upstream includes public headers with
  a subdirectory prefix, then this subdirectory would normally also be present
  in the upstream layout so that such a header can be included from the
  upstream codebase directly. As an example, let's say we determined that
  public headers of )SM(libfoo)ES( are included with the
  )SM(foo/)ES( subdirectory, such as )SM(<foo/util.hpp>)ES(. One
  of the typical upstream layouts for such a library would look like this:)EP(

  ) 8 22 PR($ tree upstream/
upstream/
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     \267-- util.hpp
\267-- src/
    |-- priv.hpp
    \267-- util.cpp)RP(

  )0 P(Notice how the )SM(util.hpp)ES( header is in the )SM(foo/)ES(
  subdirectory rather than in )SM(include/)ES( directly.)EP(

  )0 P(The second key piece of information we need to find is whether and, if
  so, how the public headers and sources are split. For instance, in the above
  example, we can see that public headers go into )SM(include/)ES( while
  sources and private headers go into )SM(src/)ES(. But they could also
  be combined in the same directory, for example, as in the following
  layout:)EP(

  ) 5 16 PR(upstream/
\267-- foo/
    |-- priv.hpp
    |-- util.cpp
    \267-- util.hpp)RP(

  )BR(
  )0 P(In multi-package projects, for example, those that provide both a library
  and an executable, you would also want to understand how the sources are
  split between the packages.)EP(
  )BR(

  )0 P(If the headers and sources are split into different directories, then the
  source directory may or may not have the inclusion subdirectory, similar to
  the header directory. In the above split layout the )SM(src/)ES(
  directory doesn't contain the inclusion subdirectory \201)SM(foo/)ES(\202
  while the following layout does:)EP(

  ) 8 22 PR(upstream/
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     \267-- util.hpp
\267-- src/
    \267-- foo/
        |-- priv.hpp
        \267-- util.cpp)RP(

  )0 P(With the understanding of these key properties of upstream layout you
  should be in a good position to start crafting the )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command line that recreates it.)EP(

  )BR(
  )0 P(The )SM(bdep-new)ES( documentation uses slightly more general
  terminology compared to what we used in the previous section in order to
  also be applicable to projects that use modules instead of headers.)EP(

  )0 P(Specifically, the inclusion subdirectory \201)SM(foo/)ES(\202 is called
  )I(source subdirectory)ES( while the header directory
  \201)SM(include/)ES(\202 and source directory \201)SM(src/)ES(\202 are called
  )I(header prefix)ES( and )I(source prefix)ES(, respectively.)EP(
  )BR(

  )0 3 13 H(2.2.3)WB 136 Sn()WB 15 Sn( Craft )SM(bdep new)ES( command
  line to create package)EH(

  )0 P(The recommended procedure for this step is to read through the
  )SM(bdep-new)ES('s )0 2 A(SOURCE LAYOUT)EA( section
  \201which contains a large number of examples\202 while experimenting with various
  options in an attempt to create the desired layout. If the layout you've got
  isn't quite right yet, simply remove the package directory along with the
  )SM(packages.manifest)ES( file and try again.)EP(

  )BR(
  )0 P(Next to )SM(packages.manifest)ES(, )SM(bdep-new)ES( will also
  create the "glue" )SM(buildfile)ES( that allows building all the
  packages from the repository root. You don't need to remove it when
  re-creating the package.)EP(
  )BR(

  )0 P(Let's illustrate this approach on the first split layout from the
  previous section:)EP(

  ) 7 22 PR(upstream/
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     \267-- util.hpp
\267-- src/
    |-- priv.hpp
    \267-- util.cpp)RP(

  )0 P(We know it's split, so let's start with that and see what we get.
  Remember, our )SM(foo)ES( package repository that we have cloned and
  initialized earlier looks like this:)EP(

  ) 7 25 PR($ tree foo/
foo/
|-- upstream/
|-- .gitattributes
|-- .gitignore
|-- README.md
\267-- repositories.manifest)RP(

  )0 P(Now we create the )SM(libfoo)ES( package inside:)EP(

  ) 10 55 PR($ cd foo/
$ bdep new --package --lang c++ --type lib,split libfoo
$ tree libfoo/
libfoo/
|-- include/
|\302\240\302\240 \267-- libfoo/
|\302\240\302\240     \267-- foo.hxx
\267-- src/
    \267-- libfoo/
        \267-- foo.cxx)RP(

  )0 P(The outer structure looks right, but inside )SM(include/)ES( and
  )SM(src/)ES( things are a bit off. Specifically, the source
  subdirectory should be )SM(foo/)ES(, not )SM(libfoo/)ES(, there
  shouldn't be one inside )SM(src/)ES(, and the file extensions don't
  match upstream. All this can be easily tweaked, however:)EP(

  ) 12 48 PR($ rm -r libfoo/ packages.manifest
$ bdep new --package \200
  --lang c++,cpp     \200
  --type lib,split,subdir=foo,no-subdir-source \200
  libfoo
$ tree libfoo/
libfoo/
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     \267-- foo.hpp
\267-- src/
    \267-- foo.cpp)RP(

  )0 P(The other )SM(bdep-new)ES( sub-options \201see the )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( man
  page for the complete list\202 that you will likely want to use when packaging
  a third-party project include:)EP(

  )0 DL(  )0 DT()SM()BD(no-version)ES()ES(
  )DD(Omit the auto-generated version header. Usually upstream will provide
  its own equivalent of this functionality.

  )BR(
  )0 P(Note that even if upstream doesn't provide any version information, it's
  not a good idea to try to rectify this by providing your own version header
  since upstream may add it in a future version and you may end up with a
  conflict. Instead, work with the project authors to rectify this
  upstream.)EP(
  )BR(

  )0 DT()SM()BD(no-symexport)ES()ES(
  )BR(  )SM()BD(auto-symexport)ES()ES(
  )DD(The )SM(no-symexport)ES( sub-option suppresses the generation of
  the DLL symbol exporting header. This is an appropriate option if upstream
  provides its own symbol exporting arrangements.

  )0 P(The )SM(auto-symexport)ES( sub-option enables automatic DLL symbol
  exporting support \201see )0 2 A(Automatic
  DLL Symbol Exporting)EA( for background\202. This is an appropriate option if
  upstream relies on similar support in the existing build system. It is also
  recommended that you give this functionality a try even if upstream does not
  support building shared libraries on Windows.)EP(

  )0 DT()SM()BD(binless)ES()ES(
  )DD(Create a header-only library. See )0 88 1 A(Don't make
  library header-only if it can be compiled)88 0 TN TL()Ec /AF f D( and )R17 2 A(How
  do I make a header-only C/C++ library?)EA(

  )0 DT()SM()BD(buildfile-in-prefix)ES()ES(
  )DD(Place header/source )SM(buildfiles)ES( into the header/source
  prefix directory instead of source subdirectory. To illustrate the
  difference, compare these two auto-generated layouts paying attention to the
  location of )SM(buildfiles)ES(:

  ) 11 49 PR($ bdep new ... --type lib,split,subdir=foo libfoo
$ tree libfoo/
libfoo/
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     |-- buildfile
|\302\240\302\240     \267-- foo.hpp
\267-- src/
    \267-- foo/
        |-- buildfile
        \267-- foo.cpp)RP(

  ) 11 69 PR($ bdep new ... --type lib,split,subdir=foo,buildfile-in-prefix libfoo
$ tree libfoo/
libfoo/
|-- include/
|\302\240\302\240 |-- foo/
|\302\240\302\240 |\302\240\302\240 \267-- foo.hpp
|\302\240\302\240 \267-- buildfile
\267-- src/
    |-- foo/
    |\302\240\302\240 \267-- foo.cpp
    \267-- buildfile)RP(

  )0 P(Note that this sub-option only makes sense if we have the header and/or
  source prefixes \201)SM(include/)ES( and )SM(src/)ES( in our case\202 as
  well as the source subdirectory \201)SM(foo/)ES( in our case\202.)EP(

  )0 P(Why would we want to do this? The main reason is to be able to symlink
  the entire upstream directories rather than individual files. In the first
  listing, the generated )SM(buildfiles)ES( are inside the
  )SM(foo/)ES( subdirectories which mean we cannot just symlink
  )SM(foo/)ES( from upstream.)EP(

  )0 P(With a large number of files to symlink, this can be such a strong
  motivation that it may make sense to invent a source subdirectory in the
  source prefix even if upstream doesn't have one. See )0 90 1 A(Don't build your main targets in the
  root )SM(buildfile)ES()90 0 TN TL()Ec /AF f D( for details on this technique.)EP(

  )0 P(Another reason we may want to move )SM(buildfiles)ES( to prefix is
  to be able to handle upstream projects that have multiple source
  subdirectories. While this situation is not very common in the header
  prefix, it can be encountered in the source prefix of more complex projects,
  where upstream wishes to organize the source files into components.)EP(
  )LD(

  )BR(
  )0 P(If upstream uses a mixture of C and C++, then it's recommended to set
  this up using the )SM(--lang)ES( sub-option of )SM(bdep-new)ES(.
  For example:)EP(

  ) 1 27 PR($ bdep new --lang c++,c ...)RP(
  )BR(

  )0 P(Continuing with our )SM(libfoo)ES( example, assuming upstream
  provides its own symbol exporting, the final )SM(bdep-new)ES( command
  line would be:)EP(

  ) 4 72 PR($ bdep new --package \200
  --lang c++,cpp     \200
  --type lib,split,subdir=foo,no-subdir-source,no-version,no-symexport \200
  libfoo)RP(

  )0 P(When packaging an executable, things are usually quite a bit simpler:
  there is no version header, symbol exporting, and the layout is normally
  combined \201since there are no public headers\202. Typically the only potentially
  tricky decision you will need to make is whether to use )I(prefix)ES( or
  )I(source subdirectory)ES(. Most likely it will be )I(prefix)ES( since most
  executable projects will use the )SM("")ES( style inclusion for own
  headers. For example:)EP(

  ) 4 47 PR($ bdep new --package \200
  --lang c++         \200
  --type exe,no-subdir,prefix=foo,export-stub \200
  foo)RP(

  )BR(
  )0 P(The )SM(export-stub)ES( sub-option causes the generation of
  )SM(build/export.build)ES(, an export stub that facilitates the
  importation of targets from our package \201see )0 2 A(Target
  Importation)EA( for details\202. The generation of this file for a library is
  the default since it will normally be used by other projects and thus
  imported. An executable, however, will only need an export stub if it can
  plausibly be used during the build \201see )0 2 A(Build-Time
  Dependencies and Linked Configurations)EA( for background\202. Source code
  generators are an obvious example of such executables. A less obvious
  example would be compression utilities such as )SM(gzip)ES( or
  )SM(zstd)ES(. If you are unsure, it's best to provide an export
  stub.)EP(
  )BR(

  )0 3 14 H(2.2.4)WB 137 Sn()WB 16 Sn( Review and test auto-generated
  )SM(buildfile)ES( templates)EH(

  )0 P(Let's get a more complete view of what got generated by the final
  )SM(bdep-new)ES( command line from the previous section:)EP(

  ) 21 26 PR($ tree libfoo/
libfoo/
|-- build/
|\302\240\302\240 \267-- ...
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     |-- buildfile
|\302\240\302\240     \267-- foo.hpp
|-- src/
|\302\240\302\240 |-- buildfile
|\302\240\302\240 \267-- foo.cpp
|-- tests/
|\302\240\302\240 |-- build/
|\302\240\302\240 |\302\240\302\240 \267-- ...
|\302\240\302\240 |-- basics/
|\302\240\302\240 |\302\240\302\240 |-- buildfile
|\302\240\302\240 |\302\240\302\240 \267-- driver.cpp
|\302\240\302\240 \267-- buildfile
|-- buildfile
|-- manifest
\267-- README.md)RP(

  )0 P(Once the overall layout looks right, the next step is to take a closer
  look at the generated )SM(buildfiles)ES( to make sure that overall they
  match the upstream build. Of particular interest are the header and source
  directory )SM(buildfiles)ES( \201)SM(libfoo/include/foo/buildfile)ES(
  and )SM(libfoo/src/buildfile)ES( in the above listing\202 which define how
  the library is built and installed.)EP(

  )0 P(Here we are focusing on the macro-level differences that are easier to
  change by tweaking the )SM(bdep-new)ES( command line rather than
  manually. For example, if we look at the generated source directory
  )SM(buildfile)ES( and realize it builds a )I(binful)ES( library \201that
  is, a library that includes source files and therefore produces library
  binaries\202 while the upstream library is header-only, it is much easier to
  fix this by re-running )SM(bdep-new)ES( with the )SM(binless)ES(
  sub-option than by changing the )SM(buildfiles)ES( manually.)EP(

  )BR(
  )0 P(Don't be tempted to start making manual changes at this stage even if you
  cannot see anything else that can be fixed with a )SM(bdep-new)ES(
  re-run. This is still a dry-run and we will recreate the package one more
  time in the following section before starting manual adjustments.)EP(
  )BR(

  )0 P(Besides examining the generated )SM(buildfiles)ES(, it's also a good
  idea to build, test, and install the generated package to make sure
  everything ends up where you expected and matches upstream where necessary.
  In particular, make sure public headers are installed into the same location
  as upstream \201unless you have decided to deviate, of course\202 or at least it's
  clear how to tweak the generated )SM(buildfiles)ES( to achieve
  this.)EP(

  )BR(
  )0 P(The )SM(bdep-new)ES(-generated library is a simple "Hello, World!"
  example that can nevertheless be built, tested, and installed. The idea here
  is to verify it matches upstream using the generated source files before
  replacing them with the upstream source file symlinks.)EP(

  )0 P(If you are using Windows, then you will need to temporarily replace the
  )SM(no-symexport)ES( sub-option with )SM(auto-symexport)ES( in
  order to make the generated library buildable. But do not forget to drop
  this sub-option in the next step.)EP(
  )BR(

  )0 P(Note that at this stage it's easiest to build, test, and install in the
  source directory, skipping the )SM(bdep)ES( initialization of the
  package \201which we would have to de-initialize before we can re-run
  )SM(bdep-new)ES(\202. Continue with the above example, the recommended
  sequence of commands would be:)EP(

  ) 6 44 PR($ cd libfoo/
$ b update
$ b test
$ rm -rf /tmp/install
$ b install config.install.root=/tmp/install
$ b clean)RP(

  )BR(
  )0 P(One relatively common case where the installation location may not match
  upstream are libraries that include their headers without the subdirectory
  prefix \201for example, )SM(<foo_util.h>)ES( instead of
  )SM(<foo/util.h>)ES(\202. In such cases, in the )SM(bdep-new)ES(
  command, you may want to use )I(prefix)ES( rather than )I(source
  subdirectory)ES( \201with the latter being the default\202. For example:)EP(

  ) 1 41 PR($ bdep new --lib,no-subdir,prefix=foo ...)RP(

  )0 P(See )0 2 A(SOURCE LAYOUT)EA(
  for details.)EP(
  )BR(

  )0 P(Let's also briefly discuss other subdirectories and files found in the
  )SM(bdep-new)ES(-generated )SM(libfoo)ES( package.)EP(

  )0 P(The )SM(build/)ES( subdirectory is the standard )SM(build2)ES(
  place for project-wide build system information \201see )0 2 A(Project
  Structure)EA( for details\202. We will look closer at its contents in the
  following sections.)EP(

  )0 P(In the root directory of our package we find the root
  )SM(buildfile)ES( and package )SM(manifest)ES(. We will be
  tweaking both in the following steps. There is also )SM(README.md)ES(
  which we will replace with the upstream symlink.)EP(

  )0 P(The )SM(tests/)ES( subdirectory is the standard )SM(build2)ES(
  tests subproject \201see )0 2 A(Testing)EA(
  for background and details\202. While you can suppress its generation with the
  )SM(no-tests)ES( )SM(bdep-new)ES( sub-option, we recommend that
  you keep it and use it as a starting point for porting upstream tests or, if
  upstream doesn't provide any, for a basic "smoke test".)EP(

  )BR(
  )0 P(You can easily add/remove/rename this )SM(tests/)ES( subproject. The
  only place where it is mentioned explicitly and where you will need to make
  changes is the root )SM(buildfile)ES(. In particular, if upstream
  provides examples that you wish to port, it is recommended that you use a
  copy of the generated )SM(tests/)ES( subproject as a starting point
  \201not forgetting to add the corresponding entry in the root
  )SM(buildfile)ES(\202.)EP(
  )BR(

  )0 3 15 H(2.2.5)WB 138 Sn()WB 17 Sn( Create final package)EH(

  )0 P(If you are satisfied with the )SM(bdep-new)ES( command line and
  there are no more automatic adjustments you can squeeze out of it, then it's
  time to re-run )SM(bdep-new)ES( one last time to create the final
  package.)EP(

  )BR(
  )0 P(While redoing this step later will require more effort, especially if
  you've made manual modifications to )SM(buildfile)ES( and
  )SM(manifest)ES(, nothing is set in stone and it can be done again by
  simply removing the package directory, removing \201or editing, if you have
  multiple packages and only want to redo some of them\202
  )SM(packages.manifest)ES(, and starting over.)EP(
  )BR(

  )0 P(This time, however, we will do things a bit differently in order to take
  advantage of some additional automation offered by
  )SM(bdep-new)ES(.)EP(

  )0 P(Firstly, we will use the special )SM(third-party)ES( sub-option
  which is meant for converting third-party projects to )SM(build2)ES(.
  Specifically, this sub-option automatically enables )SM(no-version)ES(
  and )SM(no-symexport)ES( \201unless )SM(auto-symexport)ES( is
  specified\202. It also adds a number of values to )SM(manifest)ES( that
  makes sense to specify in a package of a third-party project. Finally, it
  generates the )SM(PACKAGE-README.md)ES( template which describes how to
  use the package from a )SM(build2)ES(-based project \201see the )0 2 A()SM(package-description)ES()EA(
  )SM(manifest)ES( value for background\202.)EP(

  )0 P(Secondly, if the package directory already exists and contains certain
  files, )SM(bdep-new)ES( can take this into account when generating the
  root )SM(buildfile)ES( and package )SM(manifest)ES(. In
  particular, it will try to guess the license from the )SM(LICENSE)ES(
  file and extract the summary from )SM(README.md)ES( and use this
  information in )SM(manifest)ES( as well as generated
  )SM(PACKAGE-README.md)ES(.)EP(

  )BR(
  )0 P(If the file names or formats used by upstream don't match those
  recognized by )SM(bdep-new)ES(, then for now simply omit the
  corresponding files from the package directory and add them later manually.
  Similarly, if an attempt to extract the information is unsuccessful, we will
  have a chance to adjust it in )SM(manifest)ES( later.)EP(

  )0 P(Specifically, for )SM(README)ES(, )SM(bdep-new)ES( recognizes
  )SM(README.md)ES(, )SM(README.txt)ES( and )SM(README)ES( but
  will only attempt to extract the summary from )SM(README.md)ES(.)EP(

  )0 P(For license files, )SM(bdep-new)ES( recognizes )SM(LICENSE)ES(,
  )SM(LICENSE.txt)ES( )SM(LICENSE.md)ES(, )SM(COPYING)ES(, and
  )SM(UNLICENSE)ES(.)EP(

  )0 P(For changes-related files, )SM(bdep-new)ES( recognizes
  )SM(NEWS)ES(, )SM(CHANGES)ES(, and )SM(CHANGELOG)ES( in
  various cases as well as with the )SM(.md)ES(, )SM(.txt)ES(
  extensions.)EP(
  )BR(

  )0 P(Continuing with our )SM(libfoo)ES( example and assuming upstream
  provides the )SM(README.md)ES(, )SM(LICENSE)ES(, and
  )SM(NEWS)ES( files, we first manually create the package directory,
  then add the symlinks, and finally run )SM(bdep-new)ES( \201notice that we
  have replaced )SM(no-version)ES( and )SM(no-symexport)ES( with
  )SM(third-party)ES( and omitted the package name from the
  )SM(bdep-new)ES( command line since we are running from inside the
  package directory\202:)EP(

  ) 13 58 PR($ cd foo/ # Change to the package repository root.

$ rm -r libfoo/ packages.manifest
$ mkdir libfoo/

$ cd libfoo/ # Change to the package root.
$ ln -s ../upstream/README.md ./
$ ln -s ../upstream/LICENSE   ./
$ ln -s ../upstream/NEWS      ./

$ bdep new --package \200
  --lang c++,cpp     \200
  --type lib,split,subdir=foo,no-subdir-source,third-party)RP(

  )0 P(The final contents of our package will look like this \201)SM(->)ES(
  denotes a symlink\202:)EP(

  ) 25 39 PR($ cd ../
$ tree libfoo/
libfoo/
|-- build/
|\302\240\302\240 \267-- ...
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     |-- buildfile
|\302\240\302\240     \267-- foo.hpp
|-- src/
|\302\240\302\240 |-- buildfile
|\302\240\302\240 \267-- foo.cpp
|-- tests/
|\302\240\302\240 |-- build/
|\302\240\302\240 |\302\240\302\240 \267-- ...
|\302\240\302\240 |-- basics/
|\302\240\302\240 |\302\240\302\240 |-- buildfile
|\302\240\302\240 |\302\240\302\240 \267-- driver.cpp
|\302\240\302\240 \267-- buildfile
|-- buildfile
|-- manifest
|-- NEWS       -> ../upstream/NEWS
|-- LICENSE    -> ../upstream/LICENSE
|-- README.md  -> ../upstream/README.md
\267-- PACKAGE-README.md)RP(

  )0 P(If auto-detection of )SM(README)ES(, )SM(LICENSE)ES(, and
  )SM(NEWS)ES( succeeds, then you should see the )SM(summary)ES( and
  )SM(license)ES( values automatically populated in )SM(manifest)ES(
  and the symlinked files listed in the root )SM(buildfile)ES(.)EP(

  )0 3 16 H(2.2.6)WB 139 Sn()WB 18 Sn( Adjust package version)EH(

  )0 P(While adjusting the )SM(bdep-new)ES(-generated code is the subject
  of the following sections, one tweak that we want to make right away is to
  change the package version in the )SM(manifest)ES( file.)EP(

  )0 P(In this guide we will assume the upstream package uses semver \201semantic
  version\202 or semver-like \201that is, has three version components\202 and will
  rely on the )I(continuous versioning)ES( feature of )SM(build2)ES( to
  make sure that each commit in our package repository has a distinct version
  \201see )0 2 A(Versioning
  and Release Management)EA( for background\202.)EP(

  )BR(
  )0 P(If upstream does not use semver, then see )R18 2 A(How
  do I handle projects that don't use semantic versioning?)EA( and )R19 2 A(How
  do I handle projects that don't use versions at all?)EA( for available
  options. If you decide to use the non-semver upstream version as is, then
  you will have to forgo )I(continuous versioning)ES( as well as the use of )0 2 A()SM()BD(bdep-release\2011\202)ES()ES()EA(
  for release management. The rest of the guide, however, will still apply. In
  particular, you will still be able to use )0 2 A()SM()BD(bdep-ci\2011\202)ES()ES()EA( and
  )0 2 A()SM()BD(bdep-publish\2011\202)ES()ES()EA(
  with a bit of extra effort.)EP(
  )BR(

  )0 P(The overall plan to implement continuous versioning is to start with a
  pre-release snapshot of the upstream version, keep it like that while we are
  adjusting the )SM(bdep-new)ES(-generated package and committing our
  changes \201at which point we get distinct snapshot versions\202, and finally,
  when the package is ready to publish, change to the final upstream version
  with the help of )0 2 A()SM()BD(bdep-release\2011\202)ES()ES()EA(.
  Specifically, if the upstream version is
  )SM()I(X)ES(.)I(Y)ES(.)I(Z)ES()ES(, then we start with the
  )SM()I(X)ES(.)I(Y)ES(.)I(Z)ES(-a.0.z)ES( pre-release snapshot.)EP(

  )BR(
  )0 P(In continuous versioning )SM()I(X)ES(.)I(Y)ES(.)I(Z)ES(-a.0.z)ES(
  means a snapshot after the \201non-existent\202 )SM(0)ES(th alpha pre-release
  of the )SM()I(X)ES(.)I(Y)ES(.)I(Z)ES()ES( version. See )0 2 A(Versioning
  and Release Management)EA( for a more detailed explanation and examples.)EP(
  )BR(

  )0 P(Let's see how this works for our )SM(libfoo)ES( example. Say, the
  upstream version that we are packaging is )SM(2.1.0)ES(. This means we
  start with )SM(2.1.0-a.0.z)ES(.)EP(

  )BR(
  )0 P(Naturally, the upstream version that we are using should correspond to
  the commit of the )SM(upstream)ES( submodule we have added in the )0 11 1 A(Add upstream repository as )SM(git)ES(
  submodule)11 0 TN TL()Ec /AF f D( step.)EP(
  )BR(

  )0 P(Next we edit the )SM(manifest)ES( file in the )SM(libfoo)ES(
  package and change the )SM(version)ES( value to read:)EP(

  ) 1 20 PR(version: 2.1.0-a.0.z)RP(

  )0 P(Let's also commit this initial state of the package for easier
  rollbacks:)EP(

  ) 4 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Initialize package")RP(

  )0 2 17 H(2.3)WB 140 Sn()WB 19 Sn( Fill package with source code and add
  dependencies)EH(

  )0 P(With the package skeleton ready, the next steps are to fill it with
  upstream source code, add dependencies, and make any necessary manual
  adjustments to the generated )SM(buildfiles)ES(, )SM(manifest)ES(,
  etc. If we do this all at once, however, it can be hard to pin-point the
  cause of build failures. For example, if we convert both the library and its
  tests right away and something doesn't work, it can be hard to determine
  whether the mistake is in the library or in the tests.  As a result, we are
  going to split this work into a sequence or smaller steps that incrementally
  replace the )SM(bdep-new)ES(-generated code with upstream while
  allowing us to test each change individually. We will also commit the
  changes on each step for easy rollbacks. Specifically, the overall plan is
  as follows:)EP(

  )4 OL(  )-1 LI(Initialize \201)SM(bdep-init)ES(\202 the package in one or more build
  configurations.

  )-1 LI(Add dependencies, if any.

  )-1 LI(Fill the library with upstream source code.

  )-1 LI(Adjust project-wide and source subdirectory
  )SM(buildfiles)ES(.

  )-1 LI(Make a smoke test for the library.

  )-1 LI(Replace the smoke test with upstream tests.

  )-1 LI(Tweak root )SM(buildfile)ES( and )SM(manifest)ES(.
  )LO(

  )0 P(The first three steps are the subject of this section with the following
  sections covering the rest of the plan.)EP(

  )BR(
  )0 P(As you become more experienced with packaging third-party projects for
  )SM(build2)ES(, it may make sense to start combining or omitting some
  steps, especially for simpler libraries. For example, if you see that a
  library comes with a simple test that shouldn't cause any complications,
  then you could omit the smoke test.)EP(
  )BR(

  )0 3 18 H(2.3.1)WB 141 Sn()WB 20 Sn( Initialize package in build
  configurations)EH(

  )0 P(Before we start making any changes to the )SM(bdep-new)ES(-generated
  files, let's initialize the package in at least one build configuration so
  that we are able to build and test our changes \201see )0 2 A(Getting Started Guide)EA( for
  background on )SM(bdep)ES(-based development workflow\202. Continuing with
  our )SM(libfoo)ES( example from the earlier steps:)EP(

  ) 2 50 PR($ cd foo/ # Change to the package repository root.
$ bdep init -C ../foo-gcc @gcc cc config.cxx=g++)RP(

  )BR(
  )0 P(If you are initializing subsequent packages in the already created
  configuration, then the command line will be just:)EP(

  ) 1 16 PR($ bdep init @gcc)RP(
  )BR(

  )0 P(Let's build and test the )SM(bdep-new)ES(-generated package to make
  sure everything is in order:)EP(

  ) 3 13 PR($ bdep update
$ bdep test
$ bdep clean)RP(

  )0 P(You can create additional configurations, for example, if you have access
  to several compilers. For instance, to create a build configuration for
  Clang:)EP(

  ) 1 56 PR($ bdep init -C ../foo-clang @clang cc config.cxx=clang++)RP(

  )0 P(If you would like to perform a certain operation on all the build
  configurations, pass the )SM(-a|--all)ES( flag to
  )SM(bdep)ES(:)EP(

  ) 3 16 PR($ bdep update -a
$ bdep test -a
$ bdep clean -a)RP(

  )0 P(Let's also verify that the resulting package repository is clean \201doesn't
  have any uncommitted or untracked files\202:)EP(

  ) 1 12 PR($ git status)RP(

  )0 3 19 H(2.3.2)WB 142 Sn()WB 21 Sn( Add dependencies)EH(

  )0 P(If the upstream project has any dependencies, now is a good time to
  specify them so that when we attempt to build the upstream source code, they
  are already present.)EP(

  )0 P(Identifying whether the upstream project has dependencies is not always
  easy. The natural first places to check are the documentation and the
  existing build system. Sometimes projects also bundle their dependencies
  with the project source code \201also called vendoring\202. So it makes sense to
  look around the upstream repository for anything that looks like bundled
  dependencies. Normally we would need to "unbundle" such dependencies when
  converting to )SM(build2)ES( by instead specifying a dependency on an
  external package \201see )0 89 1 A(Don't bundle dependencies)89 0 TN TL()Ec /AF f D(
  for background\202.)EP(

  )BR(
  )0 P(While there are several reasons we insist on unbundling of dependencies,
  the main one is that bundling can cause multiple, potentially conflicting
  copies of the same dependency to exist in the build. This can cause subtle
  build failures that are hard to understand and track down.)EP(
  )BR(

  )0 P(One particularly common case to check for is bundling of the testing
  framework, such as )R20 2 A()SM(catch2)ES()EA(, by C++ projects.
  If you have identified that the upstream tests depend on a testing framework
  \201whether bundled or not\202, see )R12 2 A(How
  do I handle tests that have extra dependencies?)EA( for the recommended way
  to deal with that.)EP(

  )BR(
  )0 P(One special type of dependency which is easy to overlook is between
  packages in the same package repository. For example, if we were packaging
  both )SM(libfoo)ES( as well as the )SM(foo)ES( executable that
  depends on it, then the )SM(foo)ES( package has a dependency on
  )SM(libfoo)ES( and it must be specified. In this case we don't need to
  add anything to )SM(repositories.manifest)ES( and in the
  )SM(depends)ES( entry \201see below\202 in )SM(foo)ES('s
  )SM(manifest)ES( we will normally use the special
  )SM(==\240$)ES( version constraint, meaning )SM(libfoo)ES(
  should have the same version as )SM(foo)ES( \201see the )0 2 A()SM(depends)ES(
  package )SM(manifest)ES( value)EA( for details\202. For example:)EP(

  ) 1 20 PR(depends: libfoo == $)RP(
  )BR(

  )0 P(If you have concluded that the upstream project doesn't have any
  dependencies, then you can remove )SM(repositories.manifest)ES( from
  the package repository root \201unless you have already done so\202, commit this
  change, and skip the rest of this section.)EP(

  )0 P(And if you are still reading, then we assume you have a list of
  dependencies you need to add, preferably with their minimum required
  versions. If you could not identify the minimum required version for a
  dependency, then you can fallback to the latest available version, as will
  be described in a moment.)EP(

  )0 P(With the list of dependencies in hand, the next step is to determine
  whether they are already available as )SM(build2)ES( packages. For
  that, head over to )R1 2 A(cppget.org)EA( and search
  for each dependency.)EP(

  )0 P(If you are unable to find a package for a dependency, then it means it
  hasn't been packaged for )SM(build2)ES( yet. Check the places mentioned
  in the )0 7 1 A(Check if package repository already
  exists)7 0 TN TL()Ec /AF f D( step to see if perhaps someone is already working on the package.
  If not and the dependency is not optional, then the only way forward is to
  first package the dependency.)EP(

  )0 P(If you do find a package for a dependency, then note the section of the
  repository \201)SM(stable)ES(, )SM(testing)ES(, etc; see )0 2 A(Package
  Repositories)EA( for background\202 from which the minimum required version of
  the package is available. If you were unable to identify the minimum
  required version, then note the latest version available from the
  )SM(stable)ES( section.)EP(

  )0 P(Given the list of repository sections, edit the
  )SM(repositories.manifest)ES( file in the package repository root and
  uncomment the entry for )SM(cppget.org)ES(:)EP(

  ) 4 41 PR(:
role: prerequisite
location: https://pkg.cppget.org/1/stable
#trust: ...)RP(

  )0 P(Next, replace )SM(stable)ES( at the end of the )SM(location)ES(
  value with the least stable section from your list. For example, if your
  list contains )SM(stable)ES(, )SM(testing)ES(, and
  )SM(beta)ES(, then you need )SM(beta)ES( \201the sections form a
  hierarchy and so )SM(beta)ES( includes )SM(testing)ES( which in
  turn includes )SM(stable)ES(\202.)EP(

  )BR(
  )0 P(If you wish, you can also uncomment the )SM(trust)ES( value and
  replace )SM(...)ES( with the )R21 2 A(repository fingerprint)EA(. This way you
  won't be prompted to confirm the repository authenticity on the first fetch.
  See )0 2 A(Adding and
  Removing Dependencies)EA( for details.)EP(
  )BR(

  )0 P(Once this is done, edit )SM(manifest)ES( in package root and add the
  )SM(depends)ES( value for each dependency. See )0 2 A(Adding and
  Removing Dependencies)EA( for background. In particular, here you will use
  the minimum required version \201or the latest available\202 to form a version
  constraint. Which constraint operator to use will depend on the dependency's
  versioning policies. If the dependency uses semver, then a
  )SM(^)ES(-based constraint is a sensible default.)EP(

  )0 P(As an example, let's say our )SM(libfoo)ES( depends on
  )SM(libz)ES(, )SM(libasio)ES(, and )SM(libsqlite3)ES(. To
  specify these dependencies we would add the following entries to its
  )SM(manifest)ES(:)EP(

  ) 3 27 PR(depends: libz ^1.2.0
depends: libasio ^1.28.0
depends: libsqlite3 ^3.39.4)RP(

  )0 P(With all the dependencies specified, let's now synchronize the state of
  the build configurations with our changes by running )0 2 A()SM()BD(bdep-sync\2011\202)ES()ES()EA(
  from the package repository root:)EP(

  ) 1 14 PR($ bdep sync -a)RP(

  )0 P(This command should first fetch the metadata for the repository we
  specified in )SM(repositories.manifest)ES( and then fetch, unpack and
  configure each dependency that we specified in )SM(manifest)ES(.)EP(

  )BR(
  )0 P(If you have any build-time dependencies \201see )0 2 A(Build-Time
  Dependencies and Linked Configurations)EA( for background\202, then you will
  get a warning about the corresponding )SM(config.import.*)ES( variable
  being unused and therefore dropped. This is because we haven't yet added the
  corresponding )SM(import)ES( directives to our )SM(buildfiles)ES(.
  For now you can ignore this warning, which we will fix later, when we adjust
  the generated )SM(buildfiles)ES(.)EP(
  )BR(

  )0 P(We can examine the resulting state, including the version of each
  dependency, with )0 2 A()SM()BD(bdep-status\2011\202)ES()ES()EA(:)EP(

  ) 1 17 PR($ bdep status -ai)RP(

  )0 P(The last step for this section is to commit our changes:)EP(

  ) 4 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Add dependencies")RP(

  )0 3 20 H(2.3.3)WB 143 Sn()WB 22 Sn( Fill with upstream source code)EH(

  )0 P(Now we are ready to begin replacing the )SM(bdep-new)ES(-generated
  files with upstream source code symlinks. We start with the library's header
  and source files. Continuing with our )SM(libfoo)ES( example, this is
  what we currently have \201notice that )SM(LICENSE)ES(,
  )SM(README.md)ES(, and )SM(NEWS)ES( are already symlinks to
  upstream\202:)EP(

  ) 21 50 PR($ cd foo/ # Change to the package repository root.

$ tree libfoo/
libfoo/
|-- build/
|\302\240\302\240 \267-- ...
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     |-- buildfile
|\302\240\302\240     \267-- foo.hpp
|-- src/
|\302\240\302\240 |-- buildfile
|\302\240\302\240 \267-- foo.cpp
|-- tests/
|\302\240\302\240 \267-- ...
|-- buildfile
|-- manifest
|-- NEWS       -> ../upstream/NEWS
|-- LICENSE    -> ../upstream/LICENSE
|-- README.md  -> ../upstream/README.md
\267-- PACKAGE-README.md)RP(

  )0 P(Now we replace generated )SM(include/foo/foo.hpp)ES( with the
  library's real headers and )SM(src/foo.cpp)ES( with its real source
  files:)EP(

  ) 30 64 PR($ cd libfoo/ # Change to the package root.

$ cd include/foo/
$ rm foo.hpp
$ ln -s ../../../upstream/include/foo/*.hpp ./
$ cd -

$ cd src/
$ rm foo.cpp
$ ln -s ../../upstream/src/*.hpp ./
$ ln -s ../../upstream/src/*.cpp ./
$ cd -

$ tree libfoo/
libfoo/
|-- build/
|\302\240\302\240 \267-- ...
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     |-- buildfile
|\302\240\302\240     |-- core.hpp -> ../../../upstream/include/foo/core.hpp
|\302\240\302\240     \267-- util.hpp -> ../../../upstream/include/foo/util.hpp
|-- src/
|\302\240\302\240 |-- buildfile
|\302\240\302\240 |-- impl.hpp -> ../../upstream/src/impl.hpp
|\302\240\302\240 |-- core.cpp -> ../../upstream/src/core.cpp
|\302\240\302\240 \267-- util.cpp -> ../../upstream/src/util.cpp
|-- tests/
|\302\240\302\240 \267-- ...
\267-- ...)RP(

  )0 P(Note that the wildcards used above may not be enough in all situations
  and it's a good idea to manually examine the relevant upstream directories
  and make sure nothing is missing. Specifically, look out for:)EP(

  )UL(  )-1 LI(Header/sources with other extensions, for example, C, Objective-C,
  etc.

  )-1 LI(Other files that may be needed, for example, )SM(.def)ES(,
  )SM(config.h.in)ES(, etc.

  )-1 LI(Subdirectories that contain more header/source files.
  )LU(

  )0 P(If upstream contains subdirectories with additional header/source files,
  then you can symlink entire subdirectories instead of doing it file by file.
  For example, let's say )SM(libfoo)ES('s upstream source directory
  contains the )SM(impl/)ES( subdirectory with additional source
  files:)EP(

  ) 21 49 PR($ cd src/
$ ln -s ../../upstream/impl ./
$ cd -

$ tree libfoo/
libfoo/
|-- build/
|\302\240\302\240 \267-- ...
|-- include/
|\302\240\302\240 \267-- ...
|-- src/
|\302\240\302\240 |-- impl/ -> ../../upstream/src/impl/
|\302\240\302\240 |\302\240\302\240 |-- bar.cpp
|\302\240\302\240 |\302\240\302\240 \267-- baz.cpp
|\302\240\302\240 |-- buildfile
|\302\240\302\240 |-- impl.hpp -> ../../upstream/src/impl.hpp
|\302\240\302\240 |-- core.cpp -> ../../upstream/src/core.cpp
|\302\240\302\240 \267-- util.cpp -> ../../upstream/src/util.cpp
|-- tests/
|\302\240\302\240 \267-- ...
\267-- ...)RP(

  )0 P(Wouldn't it be nice if we could symlink the entire top-level
  subdirectories \201)SM(include/foo/)ES( and )SM(src/)ES( in our case\202
  instead of symlinking individual files? As discussed in )0 15 1 A(Craft )SM(bdep new)ES( command line to
  create package)15 0 TN TL()Ec /AF f D(, we can, but we will need to change the package layout.
  Specifically, we will need to move the )SM(buildfiles)ES( out of the
  source subdirectories with the help of the )SM(buildfile-in-prefix)ES(
  sub-option of )SM(bdep-new)ES(. In the above case, we will also need to
  invent a source subdirectory in )SM(src/)ES(. Whether this is a
  worthwhile change largely depends on how many files you have to symlink
  individually. If it's just a handful, then it's probably not worth the
  complication, especially if you have to invent source subdirectories. On the
  other hand, if you are looking at symlinking hundreds of files, changing the
  layout makes perfect sense.)EP(

  )BR(
  )0 P(One minor drawback of symlinking entire directories is that you cannot
  easily patch individual upstream files \201see )0 93 1 A(How do I patch upstream source
  code?)93 0 TN TL()Ec /AF f D(\202.)EP(

  )0 P(You will also need to explicitly list such directories as symlinks in
  )SM(.gitattributes)ES( if you want your package to be usable from the
  )SM(git)ES( repository directly on Windows. See )R14 2 A(Symlinks and
  Windows)EA( for details.)EP(
  )BR(

  )0 P(We won't be able to test this change yet because to make things build we
  will most likely also need to tweak the generated )SM(buildfiles)ES(,
  which is the subject of the next section. However, it still makes sense to
  commit our changes to make rollbacks easier:)EP(

  ) 4 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Add upstream source symlinks")RP(

  )0 2 21 H(2.4)WB 144 Sn()WB 23 Sn( Adjust project-wide and source
  )SM(buildfiles)ES()EH(

  )0 P(With source code and dependencies added, the next step is to adjust the
  regenerated )SM(buildfiles)ES( that build the library. This involves
  two places: the project-wide build system files in )SM(build/)ES( and
  the source subdirectory )SM(buildfiles)ES( \201in )SM(include/)ES(
  and )SM(src/)ES( for our )SM(libfoo)ES( example\202.)EP(

  )0 3 22 H(2.4.1)WB 145 Sn()WB 24 Sn( Adjust project-wide build system files
  in )SM(build/)ES()EH(

  )0 P(We start with reviewing and adjusting the files in the
  )SM(build/)ES( subdirectory of our package, where you will find three
  files:)EP(

  ) 8 50 PR($ cd foo/ # Change to the package repository root.
$ tree libfoo/
libfoo/
|-- build/
|\302\240\302\240 |-- bootstrap.build
|\302\240\302\240 |-- root.build
|\302\240\302\240 \267-- export.build
\267-- ...)RP(

  )0 P(To recap, the first two contain the project-wide build system setup \201see
  )0 2 A(Project
  Structure)EA( for details\202 while the last is an export stub that facilitates
  the importation of targets from our package \201see )0 2 A(Target
  Importation)EA( for details\202.)EP(

  )0 P(Normally you don't need to change anything in
  )SM(bootstrap.build)ES( \235 all it does is specify the build system
  project name and load a standard set of core build system modules. Likewise,
  )SM(export.build)ES( is ok as generated unless you need to do something
  special, like exporting targets from different subdirectories of your
  package.)EP(

  )0 P(While )SM(root.build)ES( is also often good as is, situations where
  you may need to tweak it are not uncommon and include:)EP(

  )UL(  )-1 LI(Loading an additional build system module.

  )0 P(For example, if your package makes use of Objective-C/C++ \201see )0 2 A(Objective-C
  Compilation)EA( and )0 2 A(Objective-C++
  Compilation)EA(\202 or Assembler \201see )0 2 A(Assembler
  with C Preprocessor Compilation)EA(\202, then )SM(root.build)ES( would be
  the natural place to load the corresponding modules.)EP(

  )BR(
  )0 P(If your package uses a mixture of C and C++, then it's recommended to set
  this up using the )SM(--lang)ES( sub-option of )SM(bdep-new)ES(
  rather than manually. For example:)EP(

  ) 1 27 PR($ bdep new --lang c++,c ...)RP(
  )BR(

  )-1 LI(Specifying package configuration variables.

  )0 P(If upstream provides the ability to configure their code, for example to
  enable optional features, then you may want to translate this to
  )SM(build2)ES( configuration variables, which are specified in
  )SM(root.build)ES( \201see )0 2 A(Project
  Configuration)EA( for background and details\202.)EP(

  )0 P(Note that you don't need to add all the configuration variables right
  away. Instead, you could first handle the "core" functionality which doesn't
  require any configuration and then add the configuration variables one by
  one while also making the corresponding changes in
  )SM(buildfiles)ES(.)EP(

  )BR(
  )0 P(One type of configuration that you should normally not expose when
  packaging for )SM(build2)ES( is support for both header-only and
  compiled modes. See )0 88 1 A(Don't make library
  header-only if it can be compiled)88 0 TN TL()Ec /AF f D( for details.)EP(
  )BR(
  )LU(

  )0 P(Also, in C++ projects, if you don't have any inline or template files,
  then you can drop the assignment of the file extension for the
  )SM(ixx{})ES( and )SM(txx{})ES( target types, respectively.)EP(

  )0 P(If you have added any configuration variables and would like to use
  non-default values for some of them in your build, then you will need to
  reconfigure the package. For example, let's say we have added the
  )SM(config.libfoo.debug)ES( variable to our )SM(libfoo)ES( package
  which enables additional debugging facilities in the library. This is how we
  can reconfigure all our builds to enable this functionality:)EP(

  ) 1 39 PR($ bdep sync -a config.libfoo.debug=true)RP(

  )0 P(If you have made any changes, commit them \201similar to the previous step,
  we cannot test things just yet\202:)EP(

  ) 4 56 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Adjust project-wide build system files")RP(

  )0 3 23 H(2.4.2)WB 146 Sn()WB 25 Sn( Adjust source subdirectory
  )SM(buildfiles)ES()EH(

  )0 P(The last step we need to perform before we can try to build our library
  is to adjust its )SM(buildfiles)ES(. These )SM(buildfiles)ES( are
  found in the source subdirectory or, if we used the
  )SM(buildfile-in-prefix)ES( )SM(bdep-new)ES( sub-option, in the
  prefix directory. There will be two )SM(buildfiles)ES( if we use the
  split layout \201)SM(split)ES( sub-option\202 or a single
  )SM(buildfile)ES( in the combined layout. The single
  )SM(buildfile)ES( in the combined layout contains essentially the same
  definitions as the split )SM(buildfiles)ES( but combined into one and
  with some minor simplifications that this allows. Here we will assume the
  split layout and continue with our )SM(libfoo)ES( from the previous
  sections. To recap, here is the layout we've got with the
  )SM(buildfiles)ES( of interest found in )SM(include/foo/)ES( and
  in )SM(src/)ES(:)EP(

  ) 16 64 PR(libfoo/
|-- build/
|\302\240\302\240 \267-- ...
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     |-- buildfile
|\302\240\302\240     |-- core.hpp -> ../../../upstream/include/foo/core.hpp
|\302\240\302\240     \267-- util.hpp -> ../../../upstream/include/foo/util.hpp
|-- src/
|\302\240\302\240 |-- buildfile
|\302\240\302\240 |-- impl.hpp -> ../../upstream/src/impl.hpp
|\302\240\302\240 |-- core.cpp -> ../../upstream/src/core.cpp
|\302\240\302\240 \267-- util.cpp -> ../../upstream/src/util.cpp
|-- tests/
|\302\240\302\240 \267-- ...
\267-- ...)RP(

  )BR(
  )0 P(If instead of a library you are packaging an executable, you can skip
  directly to )0 35 1 A(Adjust source
  )SM(buildfile)ES(: executables)35 0 TN TL()Ec /AF f D(.)EP(
  )BR(

  )0 3 24 H(2.4.3)WB 147 Sn()WB 26 Sn( Adjust header
  )SM(buildfile)ES()EH(

  )0 P(The )SM(buildfile)ES( in )SM(include/foo/)ES( is pretty
  simple:)EP(

  )BR(
  )0 P(The )SM(buildfile)ES( in your package may look slightly different,
  depending on the exact )SM(bdep-new)ES( sub-options used. However, all
  the relevant definitions discussed below should still be easily
  recognizable.)EP(
  )BR(

  ) 12 59 PR(pub_hdrs = {hxx ixx txx}{**}

./: $pub_hdrs

# Install into the foo/ subdirectory of, say, /usr/include/
# recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/foo/
  install.subdirs = true
})RP(

  )0 P(Normally, the only change that you would make to this
  )SM(buildfile)ES( is to adjust the installation location of headers
  \201see )0 2 A(Installing)EA(
  for background\202. In particular, if our headers were included without the
  )SM(<foo/...>)ES( prefix but instead contained the library name in
  their names \201for example, )SM(foo-util.hpp)ES(\202, then the installation
  setup would instead look like this:)EP(

  ) 7 69 PR(# Install directly into say, /usr/include/ recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/
  install.subdirs = true
})RP(

  )0 P(If the library doesn't have any headers in nested subdirectories \201for
  example, )SM(<foo/util/string.hpp>)ES(\202, you can drop the
  )SM(install.subdirs)ES( variable:)EP(

  ) 3 60 PR(# Install into the foo/ subdirectory of, say, /usr/include/.
#
{hxx ixx txx}{*}: install = include/foo/)RP(

  )BR(
  )0 P(In the combined layout, the installation-related definitions are at the
  end of the combined )SM(buildfile)ES(.)EP(

  )0 P(Compared to the split layout where the public and private headers are
  separated physically, in the combined layout you may need to achieve the
  same result \201that is, avoid installing private headers\202 at the build system
  level. If the library provides only a handful of public headers and this set
  is unlikely to change often, then listing them explicitly is the most
  straightforward approach. For example \201the )SM(@./)ES( qualifier tells
  )SM(build2)ES( they are in the source directory\202:)EP(

  ) 4 55 PR(# Only install public headers into, say, /usr/include/.
#
h{foo}@./ h{foo_version}@./: install = include/
h{*}: install = false)RP(
  )BR(

  )0 P(See also )0 98 1 A(How do I handle
  extra header installation subdirectory?)98 0 TN TL()Ec /AF f D()EP(

  )0 3 25 H(2.4.4)WB 148 Sn()WB 27 Sn( Adjust source
  )SM(buildfile)ES(: overview)EH(

  )0 P(Next is the )SM(buildfile)ES( in )SM(src/)ES(:)EP(

  )BR(
  )0 P(Again, the )SM(buildfile)ES( in your package may look slightly
  different, depending on the exact )SM(bdep-new)ES( sub-options used.
  However, all the relevant definitions discussed below should still be easily
  recognizable.)EP(

  )0 P(For a binless \201header-only\202 library, this )SM(buildfile)ES( will
  contain only a small subset of the definitions shown below. See )R17 2 A(How
  do I make a header-only C/C++ library?)EA( for additional considerations
  when packaging header-only libraries.)EP(
  )BR(

  ) 54 68 PR(intf_libs = # Interface dependencies.
impl_libs = # Implementation dependencies.
#import xxxx_libs += libhello%lib{hello}

# Public headers.
#
pub = [dir_path] ../include/foo/

include $pub

pub_hdrs = $\201$pub/ pub_hdrs\202

lib{foo}: $pub/{$pub_hdrs}

# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx ixx txx cxx}{**} $impl_libs $intf_libs

# Build options.
#
out_pfx_inc = [dir_path] $out_root/include/
src_pfx_inc = [dir_path] $src_root/include/
out_pfx_src = [dir_path] $out_root/src/
src_pfx_src = [dir_path] $src_root/src/

cxx.poptions =+ "-I$out_pfx_src" "-I$src_pfx_src" \200
                "-I$out_pfx_inc" "-I$src_pfx_inc"

#obja{*}: cxx.poptions += -DFOO_STATIC_BUILD
#objs{*}: cxx.poptions += -DFOO_SHARED_BUILD
)WR(
# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$out_pfx_inc" "-I$src_pfx_inc"
  cxx.export.libs = $intf_libs
}

#liba{foo}: cxx.export.poptions += -DFOO_STATIC
#libs{foo}: cxx.export.poptions += -DFOO_SHARED

# For pre-releases use the complete version to make sure they cannot
# be used in place of another pre-release or the final version. See
# the version module for details on the version.* variable values.
#
if $version.pre_release
  lib{foo}: bin.lib.version = "-$version.project_id"
else
  lib{foo}: bin.lib.version = "-$version.major.$version.minor"

# Don't install private headers.
#
{hxx ixx txx}{*}: install = false)RP(

  )0 3 26 H(2.4.5)WB 149 Sn()WB 28 Sn( Adjust source
  )SM(buildfile)ES(: cleanup)EH(

  )0 P(As a first step, let's remove all the definitions that we don't need in
  our library. The two common pieces of functionality that are often not
  needed are support for auto-generated headers \201such as )SM(config.h)ES(
  generated from )SM(config.h.in)ES(\202 and dependencies on other
  libraries.)EP(

  )0 P(If you don't have any auto-generated headers, then remove all the
  assignments and expansions of the )SM(out_pfx_inc)ES( and
  )SM(out_pfx_src)ES( variables. Here is what the relevant lines in the
  above )SM(buildfile)ES( should look like after this change:)EP(

  ) 13 49 PR(# Build options.
#
src_pfx_inc = [dir_path] $src_root/include/
src_pfx_src = [dir_path] $src_root/src/

cxx.poptions =+ "-I$src_pfx_src" "-I$src_pfx_inc"

# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$src_pfx_inc"
})RP(

  )BR(
  )0 P(If you do have auto-generated headers, then in the split layout you can
  remove )SM(out_pfx_inc)ES( if you only have private auto-generated
  headers and )SM(out_pfx_src)ES( if you only have public ones.)EP(
  )BR(

  )BR(
  )0 P(In the combined layout the single )SM(buildfile)ES( does not set the
  )SM(*_pfx_*)ES( variables. Instead it uses the )SM(src_root)ES(
  and )SM(out_root)ES( variables directly. For example:)EP(

  ) 10 51 PR(# Build options.
#
cxx.poptions =+ "-I$out_root" "-I$src_root"

# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$out_root" "-I$src_root"
})RP(

  )0 P(To remove support for auto-generated headers in the combined
  )SM(buildfile)ES(, simply remove the corresponding
  )SM(out_root)ES( expansions:)EP(

  ) 10 37 PR(# Build options.
#
cxx.poptions =+ "-I$src_root"

# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$src_root"
})RP(

  )0 P(If you only have private auto-generated headers, then only remove the
  expansion from )SM(cxx.export.poptions)ES(.)EP(
  )BR(

  )0 P(If you don't have any dependencies, then remove all the assignments and
  expansions of the )SM(intf_libs)ES( and )SM(impl_libs)ES(
  variables. That is, the following lines in the original
  )SM(buildfile)ES(:)EP(

  ) 15 57 PR(intf_libs = # Interface dependencies.
impl_libs = # Implementation dependencies.
#import xxxx_libs += libhello%lib{hello}

# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx ixx txx cxx}{**} $impl_libs $intf_libs

# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$out_pfx_inc" "-I$src_pfx_inc"
  cxx.export.libs = $intf_libs
})RP(

  )0 P(Become just these:)EP(

  ) 10 57 PR(# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx ixx txx cxx}{**}

# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$out_pfx_inc" "-I$src_pfx_inc"
})RP(

  )0 3 27 H(2.4.6)WB 150 Sn()WB 29 Sn( Adjust source
  )SM(buildfile)ES(: dependencies)EH(

  )0 P(If you do have dependencies, then let's handle them now.)EP(

  )BR(
  )0 P(Here we will assume dependencies on other libraries, which is the common
  case. If you have dependencies on executables, for example, source code
  generators, see )0 2 A(Build-Time
  Dependencies and Linked Configurations)EA( on how to handle that. In this
  case you will also need to reconfigure your package after adding the
  corresponding )SM(import)ES( directives in order to re-acquire the
  previously dropped )SM(config.import.*)ES( values. Make sure to also
  pass any configuration variables you specified in )0 24 1 A(Adjust project-wide build system files in
  )SM(build/)ES()24 0 TN TL()Ec /AF f D(. For example:)EP(

  ) 1 51 PR($ bdep sync -a --disfigure config.libfoo.debug=true)RP(
  )BR(

  )0 P(For each library that your package depends on \201and which you have added
  to )SM(manifest)ES( in the )0 21 1 A(Add
  dependencies)21 0 TN TL()Ec /AF f D( step\202, you need to first determine whether it's an
  interface or implementation dependency and then import it either into the
  )SM(intf_libs)ES( or )SM(impl_libs)ES( variable, respectively.)EP(

  )0 P(See )0 2 A(Library
  Exportation and Versioning)EA( for background on the interface vs
  implementation distinction. But as a quick rule of thumb, if the library you
  are packaging includes a header from the dependency library in one of its
  public headers, then it's an interface dependency. Otherwise, it's an
  implementation dependency.)EP(

  )0 P(Continuing with our )SM(libfoo)ES( example, as we have established
  in )0 21 1 A(Add dependencies)21 0 TN TL()Ec /AF f D(, it depends on
  )SM(libasio)ES(, )SM(libz)ES(, and )SM(libsqlite3)ES( and
  let's say we've determined that )SM(libasio)ES( is an interface
  dependency because it's included from )SM(include/foo/core.hpp)ES(
  while the other two are implementation dependencies because they are only
  included from )SM(src/)ES(. Here is how we would change our
  )SM(buildfile)ES( to import them:)EP(

  ) 5 43 PR(intf_libs = # Interface dependencies.
impl_libs = # Implementation dependencies.
import intf_libs += libasio%lib{asio}
import impl_libs += libz%lib{z}
import impl_libs += libsqlite3%lib{sqlite3})RP(

  )0 P(You can tidy this a bit further if you would like:)EP(

  ) 3 43 PR(import intf_libs = libasio%lib{asio}
import impl_libs = libz%lib{z}
import impl_libs += libsqlite3%lib{sqlite3})RP(

  )BR(
  )0 P(If you don't have any implementation or interface dependencies, you can
  remove the assignment and all the expansions of the corresponding
  )SM(*_libs)ES( variable.)EP(
  )BR(

  )0 P(Note also that system libraries like )SM(-lm)ES(, )SM(-ldl)ES(
  on UNIX or )SM(advapi32.lib)ES(, )SM(ws2_32.lib)ES( on Windows
  should not be imported. Instead, they should be listed in the
  )SM(c.libs)ES( or )SM(cxx.libs)ES( variables. See )R22 2 A(How
  do I link a system library)EA( for details.)EP(

  )0 3 28 H(2.4.7)WB 151 Sn()WB 30 Sn( Adjust source
  )SM(buildfile)ES(: public headers)EH(

  )0 P(With the unnecessary parts of the )SM(buildfile)ES( cleaned up and
  dependencies handled, let's discuss the common changes to the remaining
  definitions, going from top to bottom. We start with the public headers
  block:)EP(

  ) 9 32 PR(# Public headers.
#
pub = [dir_path] ../include/foo/

include $pub

pub_hdrs = $\201$pub/ pub_hdrs\202

lib{foo}: $pub/{$pub_hdrs})RP(

  )0 P(This block gets hold of the list of public headers and makes them
  prerequisites of the library. Normally you shouldn't need to make any
  changes here. If you need to exclude some headers, it should be done in the
  header )SM(buildfile)ES( in the )SM(include/)ES( directory.)EP(

  )BR(
  )0 P(In the combined layout the single )SM(buildfile)ES( does not have
  such code. Instead, all the headers are covered by the wildcard pattern in
  the following block.)EP(
  )BR(

  )0 3 29 H(2.4.8)WB 152 Sn()WB 31 Sn( Adjust source
  )SM(buildfile)ES(: sources, private headers)EH(

  )0 P(The next block deals with sources, private headers, and dependencies, if
  any:)EP(

  ) 3 54 PR(# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx ixx txx cxx}{**} $impl_libs $intf_libs)RP(

  )0 P(By default it will list all the relevant files as prerequisites of the
  library, starting from the directory of the )SM(buildfile)ES( and
  including all the subdirectories, recursively \201see )0 2 A(Name
  Patterns)EA( for background on wildcard patterns\202.)EP(

  )0 P(If your C++ package doesn't have any inline or template files, then you
  can remove the )SM(ixx)ES( and )SM(txx)ES( target types,
  respectively \201which would be parallel to the change made in
  )SM(root.build)ES(; see )0 24 1 A(Adjust
  project-wide build system files in )SM(build/)ES()24 0 TN TL()Ec /AF f D(\202. For
  example:)EP(

  ) 3 54 PR(# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx cxx}{**} $impl_libs $intf_libs)RP(

  )BR(
  )0 P(Source files other than C/C++ \201for example, Assembler, Objective-C/C++\202
  are dealt with in )0 36 1 A(Adjust source
  )SM(buildfile)ES(: extra requirements)36 0 TN TL()Ec /AF f D( below.)EP(
  )BR(

  )0 P(The other common change to this block is the exclusion of certain files
  or making them conditionally included. As an example, let's say in our
  )SM(libfoo)ES( the source subdirectory contains a bunch of
  )SM(*-test.cpp)ES( files which are unit tests and should not be listed
  as prerequisites of a library. Here is how we can exclude them:)EP(

  ) 3 54 PR(# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx cxx}{** -**-test} $impl_libs $intf_libs)RP(

  )0 P(Let's also assume our )SM(libfoo)ES( contains
  )SM(impl-win32.cpp)ES( and )SM(impl-posix.cpp)ES( which provide
  alternative implementations of the same functionality for Windows and POSIX
  and therefore should only be included as prerequisites on the respective
  platforms. Here is how we can handle that:)EP(

  ) 6 69 PR(# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx cxx}{** -impl-win32 -impl-posix -**-test}
lib{foo}: cxx{impl-win32}: include = \201$cxx.target.class == 'windows'\202
lib{foo}: cxx{impl-posix}: include = \201$cxx.target.class != 'windows'\202
lib{foo}: $impl_libs $intf_libs)RP(

  )0 P(There are two nuances in the above example worth highlighting. Firstly,
  we have to exclude the files from the wildcard pattern before we can
  conditionally include them. Secondly, we have to always link libraries last.
  In particular, the following is a shorter but an incorrect version of the
  above:)EP(

  ) 4 69 PR(lib{foo}: {hxx cxx}{** -impl-win32 -impl-posix -**-test} \200
          $impl_libs $intf_libs
lib{foo}: cxx{impl-win32}: include = \201$cxx.target.class == 'windows'\202
lib{foo}: cxx{impl-posix}: include = \201$cxx.target.class != 'windows'\202)RP(

  )BR(
  )0 P(You may also be tempted to use the )SM(if)ES( directive instead of
  the )SM(include)ES( variable for conditional prerequisites. For
  example:)EP(

  ) 4 35 PR(if \201$cxx.target.class == 'windows'\202
  lib{foo}: cxx{impl-win32}
else
  lib{foo}: cxx{impl-posix})RP(

  )0 P(This would also be incorrect. For background and details, see )R23 2 A(How
  do I keep the build graph configuration-independent?)EA()EP(
  )BR(

  )0 3 30 H(2.4.9)WB 153 Sn()WB 32 Sn( Adjust source
  )SM(buildfile)ES(: build and export options)EH(

  )0 P(The next two blocks are the build and export options, which we will
  discuss together:)EP(

  ) 23 57 PR(# Build options.
#
out_pfx_inc = [dir_path] $out_root/include/
src_pfx_inc = [dir_path] $src_root/include/
out_pfx_src = [dir_path] $out_root/src/
src_pfx_src = [dir_path] $src_root/src/

cxx.poptions =+ "-I$out_pfx_src" "-I$src_pfx_src" \200
                "-I$out_pfx_inc" "-I$src_pfx_inc"

#obja{*}: cxx.poptions += -DFOO_STATIC_BUILD
#objs{*}: cxx.poptions += -DFOO_SHARED_BUILD

# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$out_pfx_inc" "-I$src_pfx_inc"
  cxx.export.libs = $intf_libs
}

#liba{foo}: cxx.export.poptions += -DFOO_STATIC
#libs{foo}: cxx.export.poptions += -DFOO_SHARED)RP(

  )0 P(The build options are in effect when the library itself is being built
  and the exported options are propagated to the library consumers \201see )0 2 A(Library
  Exportation and Versioning)EA( for background on exported options\202. For now
  we will ignore the commented out lines that add )SM(-DFOO_STATIC*)ES(
  and )SM(-DFOO_SHARED*)ES( macros \235 they are for symbol exporting
  and we will discuss this topic separately.)EP(

  )0 P(If the library you are packaging only relied on platform-independent
  APIs, then chances are you won't need to change anything here. On the other
  hand, if it does anything platform-specific, then you will most likely need
  to add some options.)EP(

  )0 P(As discussed in the )0 2 A(Output
  Directories and Scopes)EA( section of the build system introduction, there
  is a number of variables that are used to specify compilation and linking
  options, such as )SM(*.poptions)ES( \201)SM(cxx.poptions)ES( in the
  above example\202, )SM(*.coptions)ES(, etc. The below table shows all of
  them with their rough )SM(make)ES( equivalents in the third column:)EP(

  ) 5 46 PR(*.poptions   preprocess        CPPFLAGS
*.coptions   compile           CFLAGS/CXXFLAGS
*.loptions   link              LDFLAGS
*.aoptions   archive           ARFLAGS
*.libs       system libraries  LIBS/LDLIBS)RP(

  )0 P(The recommended approach here is to study the upstream build system and
  copy custom compile/link options to the appropriate )SM(build2)ES(
  variables. Note, however, that doing it thoughtlessly/faithfully by copying
  all the options may not always be a good idea. See )R24 2 A(Which
  C/C++ compile/link options are OK to specify in a project's buildfile?)EA(
  for the guidelines.)EP(

  )BR(
  )0 P(If you are packaging a library that includes a large number of optional
  features, it may be unclear which of them would make sense to enable by
  default. The notorious example of this situation is )R25 2 A()SM(libsqlite3)ES()EA(
  which provides hundreds of preprocessor macros to enable or tune various
  aspects of its functionality.)EP(

  )0 P(The recommended approach in cases like this is to study the configuration
  of such a library in distributions like Debian and Fedora and use the same
  defaults. In particular, this will allow us to substitute the
  )SM(build2)ES( package with the system-installed version.)EP(
  )BR(

  )0 P(Oftentimes, custom options must only be specified for certain target
  platforms or when using a certain compiler. While )SM(build2)ES(
  provides a large amount of information to identify the build configuration
  as well as more advanced )SM(buildfile)ES( language mechanisms \201such as
  )0 2 A(Pattern
  Matching)EA(\202 to make sense of it, this is a large topic for which we refer
  you to )0 2 A(The
  )SM(build2)ES( Build System)EA( manual. Additionally, )R5 2 A(github.com/build2-packaging)EA(
  now contains a large number of packages that you can study and search for
  examples.)EP(

  )BR(
  )0 P(While exporting preprocessor macros to communicate configuration is a
  fairly common technique, it has a number of drawbacks and limitations.
  Specifically, a large number of such macros will add a lot of noise to the
  consumer's compilation command lines \201especially if multiple libraries
  indulge in this\202. Plus, the information conveyed by such macros is limited
  to simple values and is not easily accessible in consumer
  )SM(buildfiles)ES(.)EP(

  )0 P(To overcome these drawbacks and limitations, )SM(build2)ES( provides
  a mechanism for conveying metadata with C/C++ libraries \201and executables\202.
  See, )R26 2 A(How
  do I convey additional information \201metadata\202 with executables and C/C++
  libraries?)EA( for details.)EP(

  )0 P(Note that outright replacing the preprocessor macros with metadata can be
  done if this information is only used by the library consumers. In other
  words, if the library's public headers rely on the presence of such macros,
  then we have no choice but to export them, potentially also providing the
  metadata so that this information is easily accessible from
  )SM(buildfiles)ES(.)EP(
  )BR(

  )0 P(Let's consider a representative example based on our )SM(libfoo)ES(
  to get a sense of what this normally looks like as well as to highlight a
  few nuances. We will assume our )SM(libfoo)ES( requires either the
  )SM(FOO_POSIX)ES( or )SM(FOO_WIN32)ES( macro to be defined during
  the build in order to identify the target platform. Additionally, extra
  features can be enabled by defining )SM(FOO_EXTRAS)ES(, which should be
  done both during the build and for consumption \201so this macro must also be
  exported\202. Next, this library requires the )SM(-fno-strict-aliasing)ES(
  compile option for the GCC-class compilers \201GCC, Clang, etc\202. Finally, we
  need to link )SM(pthread)ES( on POSIX and )SM(ws2_32.lib)ES( on
  Windows. This is how we would work all this into the above fragment:)EP(

  ) 43 70 PR(# Build options.
#
out_pfx_inc = [dir_path] $out_root/include/
src_pfx_inc = [dir_path] $src_root/include/
out_pfx_src = [dir_path] $out_root/src/
src_pfx_src = [dir_path] $src_root/src/

cxx.poptions =+ "-I$out_pfx_src" "-I$src_pfx_src" \200
                "-I$out_pfx_inc" "-I$src_pfx_inc"

cxx.poptions += -DFOO_EXTRAS

if \201$cxx.target.class == 'windows'\202
  cxx.poptions += -DFOO_WIN32
else
  cxx.poptions += -DFOO_POSIX

#obja{*}: cxx.poptions += -DFOO_STATIC_BUILD
#objs{*}: cxx.poptions += -DFOO_SHARED_BUILD

if \201$cxx.class == 'gcc'\202
  cxx.coptions += -fno-strict-aliasing

switch $cxx.target.class, $cxx.target.system
{
  case 'windows', 'mingw32'
    cxx.libs += -lws2_32
  case 'windows'
    cxx.libs += ws2_32.lib
  default
    cxx.libs += -pthread)WR(
}

# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$out_pfx_inc" "-I$src_pfx_inc" -DFOO_EXTRAS
  cxx.export.libs = $intf_libs
}

#liba{foo}: cxx.export.poptions += -DFOO_STATIC
#libs{foo}: cxx.export.poptions += -DFOO_SHARED)RP(

  )0 P(There are a few nuances in the above code worth keeping in mind. Firstly,
  notice that we append \201rather than assign\202 to all the non-export variables
  \201)SM(*.poptions)ES(, )SM(*.coptions)ES(, )SM(*.libs)ES(\202.
  This is because they may already contain some values specified by the user
  with their )SM(config.*.*)ES( counterparts. On the other hand, the
  )SM(*.export.*)ES( variables are assigned.)EP(

  )0 P(Secondly, the order in which we append to the variables is important for
  the value to accumulate correctly. You want to first append all the
  scope-level values, then target type/pattern-specific, and finally any
  target-specific; that is, from more general to more specific \201see )0 2 A(Buildfile
  Language)EA( for background\202. To illustrate this point, let's say in our
  )SM(libfoo)ES(, the )SM(FOO_POSIX)ES( or )SM(FOO_WIN32)ES(
  macro are only necessary when compiling )SM(util.cpp)ES(. Below would
  be the correct order of assigning to )SM(cxx.poptions)ES(:)EP(

  ) 12 51 PR(cxx.poptions =+ "-I$out_pfx_src" "-I$src_pfx_src" \200
                "-I$out_pfx_inc" "-I$src_pfx_inc"

cxx.poptions += -DFOO_EXTRAS

#obja{*}: cxx.poptions += -DFOO_STATIC_BUILD
#objs{*}: cxx.poptions += -DFOO_SHARED_BUILD

if \201$cxx.target.class == 'windows'\202
  {obja objs}{util}: cxx.poptions += -DFOO_WIN32
else
  {obja objs}{util}: cxx.poptions += -DFOO_POSIX)RP(

  )BR(
  )0 P(Note that target-specific )SM(*.poptions)ES( and
  )SM(*.coptions)ES( must be specified on the object file targets while
  )SM(*.loptions)ES( and )SM(*.libs)ES( \235 on the library or
  executable targets.)EP(
  )BR(

  )0 3 31 H(2.4.10)WB 154 Sn()WB 33 Sn( Adjust source
  )SM(buildfile)ES(: symbol exporting)EH(

  )0 P(Let's now turn to a special sub-topic of the build and export options
  that relates to the shared library symbol exporting. To recap, a shared
  library on Windows must explicitly specify the symbols \201functions and global
  data\202 that it wishes to make accessible by its consumers \201executables and
  other shared libraries\202. This can be achieved in three different ways: The
  library can explicitly mark in its source code the names whose symbols
  should be exported. Alternatively, the library can provide a
  )SM(.def)ES( file to the linker that lists the symbols to be exported.
  Finally, the library can request the automatic exporting of all symbols,
  which is the default semantics on non-Windows platforms. Note that the last
  two approaches only work for exporting functions, not data, unless special
  extra steps are taken by the library consumers. Let's discuss each of these
  approaches in the reverse order, that is, starting with the automatic symbol
  exporting.)EP(

  )0 P(The automatic symbol exporting is implemented in )SM(build2)ES( by
  generating a )SM(.def)ES( file that exports all the relevant symbols.
  It requires a few additional definitions in our )SM(buildfile)ES( as
  described in )0 2 A(Automatic
  DLL Symbol Exporting)EA(. You can automatically generate the necessary setup
  with the )SM(auto-symexport)ES( )SM(bdep-new)ES( sub-option.)EP(

  )0 P(Using a custom )SM(.def)ES( file to export symbols is fairly
  straightforward: simply list it as a prerequisite of the library and it will
  be automatically passed to the linker when necessary. For example:)EP(

  ) 3 54 PR(# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx cxx}{**} $impl_libs $intf_libs def{foo})RP(

  )BR(
  )0 P(Some third-party projects automatically generate their )SM(.def)ES(
  file. In this case you can try to re-create the same generation in the
  )SM(buildfile)ES( using an ad hoc recipe \201or the )0 2 A()SM(in)ES()EA(
  or )R27 2 A()SM(autoconf)ES()EA(
  build system modules\202. If that doesn't look possible \201for example, if the
  generation logic is complex and is implemented in something like Perl or
  Python\202, then you can try your luck with automatic symbol exporting. Failing
  that, the only remaining option is to use a pre-generated )SM(.def)ES(
  file in the )SM(build2)ES( build.)EP(
  )BR(

  )0 P(The last approach is to explicitly specify in the source code which
  symbols must be exported by marking the corresponding declarations with
  )SM(__declspec\201dllexport\202)ES( during the library build and
  )SM(__declspec\201dllimport\202)ES( during the library use. This is commonly
  achieved with a macro, customarily called )SM(*_EXPORT)ES( or
  )SM(*_API)ES(, which is defined to one of the above specifiers based on
  whether static or shared library is being built or is being consumed, which,
  in turn, is also normally signaled with a few more macros, such as
  )SM(*_BUILD_DLL)ES( and )SM(*_USE_STATIC)ES(.)EP(

  )BR(
  )0 P(Because this approach requires extensive changes to the source code, you
  will normally only use it in your )SM(build2)ES( build if it is already
  used in the upstream build.)EP(
  )BR(

  )0 P(In )SM(build2)ES( you can explicitly signal any of the four
  situations \201shared/static, built/consumed\202 by uncommenting and adjusting the
  following four lines in the build and export options blocks:)EP(

  ) 15 47 PR(# Build options.
#

...

#obja{*}: cxx.poptions += -DFOO_STATIC_BUILD
#objs{*}: cxx.poptions += -DFOO_SHARED_BUILD

# Export options.
#

...

#liba{foo}: cxx.export.poptions += -DFOO_STATIC
#libs{foo}: cxx.export.poptions += -DFOO_SHARED)RP(

  )0 P(As an example, let's assume our )SM(libfoo)ES( defines in one of its
  headers the )SM(FOO_EXPORT)ES( macro based on the
  )SM(FOO_BUILD_DLL)ES( \201shared library is being build\202 and
  )SM(FOO_USE_STATIC)ES( \201static library is being used\202 macros that it
  expects to be appropriately defined by the build system. This is how we
  would modify the above fragment to handle this setup:)EP(

  ) 13 50 PR(# Build options.
#

...

objs{*}: cxx.poptions += -DFOO_BUILD_DLL

# Export options.
#

...

liba{foo}: cxx.export.poptions += -DFOO_USE_STATIC)RP(

  )0 3 32 H(2.4.11)WB 155 Sn()WB 34 Sn( Adjust source
  )SM(buildfile)ES(: shared library version)EH(

  )0 P(The final few lines in the above )SM(buildfile)ES( deal with shared
  library binary \201ABI\202 versioning:)EP(

  ) 8 68 PR(# For pre-releases use the complete version to make sure they cannot
# be used in place of another pre-release or the final version. See
# the version module for details on the version.* variable values.
#
if $version.pre_release
  lib{foo}: bin.lib.version = "-$version.project_id"
else
  lib{foo}: bin.lib.version = "-$version.major.$version.minor")RP(

  )0 P(The )SM(bdep-new)ES(-generated setup arranges for the
  platform-independent versioning where the package's major and minor version
  components are embedded into the shared library binary name \201and
  )SM(soname)ES(\202 under the assumption that only patch versions are
  ABI-compatible.)EP(

  )0 P(The two situations where you would want to change this are when the above
  assumption does not hold and/or when upstream provides platform-specific
  shared library versions which you would like to re-create in your
  )SM(build2)ES( build. See )0 2 A(Library
  Exportation and Versioning)EA( for background and details.)EP(

  )0 3 33 H(2.4.12)WB 156 Sn()WB 35 Sn( Adjust source
  )SM(buildfile)ES(: executables)EH(

  )0 P(If instead of a library you are packaging an executable, then, as
  mentioned earlier, it will most likely be a combined layout with a single
  )SM(buildfile)ES(. This )SM(buildfile)ES( will also be much
  simpler compared to the library's. For example, give the following
  )SM(bdep-new)ES( command:)EP(

  ) 4 47 PR($ bdep new --package \200
  --lang c++         \200
  --type exe,no-subdir,prefix=foo,export-stub \200
  foo)RP(

  )0 P(The resulting source )SM(buildfile)ES( will look like this:)EP(

  ) 9 48 PR(libs =
#import libs += libhello%lib{hello}

exe{foo}: {hxx ixx txx cxx}{**} $libs testscript

out_pfx = [dir_path] $out_root/foo/
src_pfx = [dir_path] $src_root/foo/

cxx.poptions =+ "-I$out_pfx" "-I$src_pfx")RP(

  )0 P(If the executable doesn't have any inline/template/header files, then you
  can remove the )SM(ixx)ES(/)SM(txx)ES(/)SM(hxx)ES( target
  types, respectively \201which would be parallel to the change made in
  )SM(root.build)ES(; see )0 24 1 A(Adjust
  project-wide build system files in )SM(build/)ES()24 0 TN TL()Ec /AF f D(\202. For
  example:)EP(

  ) 1 40 PR(exe{foo}: {hxx cxx}{**} $libs testscript)RP(

  )0 P(If the source code includes its own headers with the )SM("")ES(
  style inclusion \201or doesn't have any headers\202, then we can also get rid of
  )SM(out_pfx)ES( and )SM(src_pfx)ES(. For example:)EP(

  ) 4 48 PR(libs =
#import libs += libhello%lib{hello}

exe{foo}: {hxx ixx txx cxx}{**} $libs testscript)RP(

  )BR(
  )0 P(Unfortunately, it's not uncommon for projects that provide both a library
  and an executable, for the executable source code to include public and/or
  private library headers with the relative )SM("")ES( style inclusion.
  For example:)EP(

  ) 2 44 PR(#include "../../libfoo/include/foo/util.hpp"
#include "../../libfoo/src/impl.hpp")RP(

  )0 P(This approach won't work in )SM(build2)ES( since the two packages
  may end up in different directories or the library could even be installed.
  There are two techniques that can be used to work around this issue \201other
  than patching the upstream source code\202.)EP(

  )0 P(For public headers we can provide, in the appropriate places within the
  executable package, "thunk headers" with the same names as public headers
  that simply include the corresponding public header from the library using
  the )SM(<>)ES( style inclusion.)EP(

  )0 P(For private headers we can provide, again in the appropriate places
  within the executable package, our own symlinks for a subset of private
  headers. Note that this will only work if the use of private headers within
  the executable does not depend on any symbols that are not exported by the
  library \201failing that, the executable will have to always link to the static
  variant of the library\202.)EP(

  )0 P(For a real example of both of these techniques, see the )R28 2 A()SM(zstd)ES()EA(
  package repository.)EP(
  )BR(

  )0 P(Dealing with dependencies in executables is similar to libraries except
  that here we don't have the interface/implementation distinction; see the )0 29 1 A(Adjust source
  )SM(buildfile)ES(: dependencies)29 0 TN TL()Ec /AF f D( step. For example:)EP(

  ) 3 48 PR(import libs = libfoo%lib{foo}

exe{foo}: {hxx ixx txx cxx}{**} $libs testscript)RP(

  )0 P(Likewise, dealing with build options in executables is similar to
  libraries except that here we have no export options; see the )0 32 1 A(Adjust source
  )SM(buildfile)ES(: build and export options)32 0 TN TL()Ec /AF f D( step.)EP(

  )0 P(If the executable can plausibly be used in a build, then it's recommended
  to add )SM(build2)ES( metadata as describe in )R26 2 A(How
  do I convey additional information \201metadata\202 with executables and C/C++
  libraries?)EA( See also )0 96 1 A(Modifying upstream source code
  with C/C++ preprocessor)96 0 TN TL()Ec /AF f D( on how to do it without physically modifying
  upstream source code. See the )R28 2 A()SM(zstd)ES()EA(
  package repository for a real example of doing this.)EP(

  )BR(
  )0 P(We will discuss the )SM(testscript)ES( prerequisite in the )0 41 1 A(Make smoke test: executables)41 0 TN TL()Ec /AF f D( step below.)EP(
  )BR(

  )0 3 34 H(2.4.13)WB 157 Sn()WB 36 Sn( Adjust source
  )SM(buildfile)ES(: extra requirements)EH(

  )0 P(The changes discussed so far should be sufficient to handle a typical
  library or executable that is written in C and/or C++ and is able to handle
  platform differences with the preprocessor and compile/link options.
  However, sooner or later you will run into a more complex library that may
  use additional languages, require more elaborate platform detection, or use
  additional functionality, such as support for source code generators. The
  below list provides pointers to resources that cover the more commonly
  encountered additional requirements.)EP(

  )UL(  )-1 LI()0 2 A(The
  )SM(in)ES( build system module)EA(

  )0 P(Use to process )SM(config.h.in)ES( \201or other )SM(.in)ES( files\202
  that don't require Autoconf-style platform probing \201)SM(HAVE_*)ES(
  options\202.)EP(

  )-1 LI()R27 2 A(The
  )SM(autoconf)ES( build system module)EA(

  )0 P(Use to process )SM(config.h.in)ES( \201or their CMake/Meson variants\202
  that require Autoconf-style platform probing \201)SM(HAVE_*)ES( options\202
  or CMake/Meson-specific substitution syntax \201)SM(#cmakedefine)ES(,
  etc\202.)EP(

  )-1 LI()0 2 A(Objective-C
  Compilation)EA( and )0 2 A(Objective-C++
  Compilation)EA(

  )0 P(Use to compile Objective-C \201)SM(.m)ES(\202 or Objective-C++
  \201)SM(.mm)ES(\202 source files.)EP(

  )-1 LI()0 2 A(Assembler
  with C Preprocessor Compilation)EA(

  )0 P(Use to compile Assembler with C Preprocessor \201)SM(.S)ES(\202 source
  files.)EP(

  )-1 LI()0 2 A(Implementing
  Unit Testing)EA(

  )0 P(Use if upstream has tests \201normally unit tests\202 in the source
  subdirectory.)EP(

  )-1 LI()0 2 A(Build-Time
  Dependencies and Linked Configurations)EA(

  )0 P(Use if upstream relies on source code generators, such as )R29 2 A()SM(lex)ES()EA( and )R30 2 A()SM(yacc)ES()EA(.)EP(

  )-1 LI()R31 2 A(The )SM(build2)ES(
  HOWTO)EA(

  )0 P(See the )SM(build2)ES( HOWTO article collection for more unusual
  requirements.)EP(
  )LU(

  )0 3 35 H(2.4.14)WB 158 Sn()WB 37 Sn( Test library build)EH(

  )0 P(At this point our library should be ready to build, at least in theory.
  While we cannot build and test the entire package before adjusting the
  generated )SM(tests/)ES( subproject \201the subject of the next step\202, we
  can try to build just the library and, if it has any unit tests in the
  source subdirectory, even run some tests.)EP(

  )BR(
  )0 P(If the library is header only, there won't be anything to build unless
  there are unit tests. Still, you may want to continue with this exercise to
  detect any syntactic mistakes in the )SM(buildfiles)ES(, etc.)EP(
  )BR(

  )0 P(To build only a specific subdirectory of our package, we use the build
  system directly \201continuing with our )SM(libfoo)ES( example\202:)EP(

  ) 2 53 PR($ cd libfoo/src/ # Change to the source subdirectory.
$ b update)RP(

  )0 P(If there are any issues, try to fix them and then build again. Once the
  library builds and if it has unit tests, you can try to run them:)EP(

  ) 1 8 PR($ b test)RP(

  )0 P(It also makes sense to test the installation and see if anything is off
  \201such as private headers being installed\202:)EP(

  ) 2 44 PR($ rm -rf /tmp/install
$ b install config.install.root=/tmp/install)RP(

  )0 P(Once the library builds, it makes sense to commit our changes for easier
  rollbacks:)EP(

  ) 4 55 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Adjust source subdirectory buildfiles")RP(

  )0 2 36 H(2.5)WB 159 Sn()WB 38 Sn( Make smoke test)EH(

  )0 P(With the library build sorted, we need tests to make sure the result is
  actually functional. As )0 19 1 A(discussed earlier)19 0 TN TL()Ec /AF f D(, it is
  recommended to start with a simple "smoke test", make sure that works, and
  then replace it with upstream tests. However, if upstream tests look simple
  enough, you can skip the smoke test. For example, if upstream has all its
  tests in a single source file and the way it is built doesn't look too
  complicated, then you can just use that source file in place of the smoke
  test.)EP(

  )BR(
  )0 P(If upstream has no tests, then the smoke test will have to stay. A
  library can only be published if it has at least one test.)EP(

  )0 P(It is also recommended to have the smoke test if upstream tests are in a
  separate package. See )R12 2 A(How
  do I handle tests that have extra dependencies?)EA( for background and
  details.)EP(
  )BR(

  )BR(
  )0 P(If instead of a library you are packaging an executable, you can skip
  directly to )0 41 1 A(Make smoke test:
  executables)41 0 TN TL()Ec /AF f D(.)EP(
  )BR(

  )0 P(To recap, the )SM(bdep-new)ES(-generated )SM(tests/)ES(
  subdirectory looks like this \201continuing with our )SM(libfoo)ES(
  example\202:)EP(

  ) 10 29 PR(libfoo/
|-- ...
\267-- tests/
    |-- build/
    |\302\240\302\240 |-- bootstrap.build
    |\302\240\302\240 \267-- root.build
    |-- basics/
    |\302\240\302\240 |-- driver.cpp
    |\302\240\302\240 \267-- buildfile
    \267-- buildfile)RP(

  )0 P(The )SM(tests/)ES( subdirectory is a build system subproject,
  meaning that it can be built independently, for example, to test the
  installed version of the library \201see )0 2 A(Testing)EA(
  for background\202. In particular, this means it has the )SM(build/)ES(
  subdirectory with project-wide build system files, the same as the library.
  The )SM(basics/)ES( subdirectory contains the generated test, which is
  what we will be turning into a smoke test. The subproject root
  )SM(buildfile)ES( rarely needs changing.)EP(

  )0 3 37 H(2.5.1)WB 160 Sn()WB 39 Sn( Adjust project-wide build system
  files in )SM(tests/build/)ES()EH(

  )0 P(Review and adjust the generated )SM(bootstrap.build)ES( and
  )SM(root.build)ES( \201there will be no )SM(export.build)ES(\202 similar
  to the )0 24 1 A(Adjust project-wide build system
  files in )SM(build/)ES()24 0 TN TL()Ec /AF f D( step.)EP(

  )0 P(Here the only change you would normally make is in
  )SM(root.build)ES( and which is to drop the assignment of extensions
  for target types that are not used in tests.)EP(

  )0 3 38 H(2.5.2)WB 161 Sn()WB 40 Sn( Convert generated test to library
  smoke test)EH(

  )0 P(The )SM(basics/)ES( subdirectory contains the
  )SM(driver.cpp)ES( source file that implements the test and
  )SM(buildfile)ES( that builds it. You can rename both the test
  subdirectory \201)SM(basics/)ES(\202 and the source file
  )SM(driver.cpp)ES(, for example, if you are going with the upstream
  tests directly. You can also add more tests by simply copying
  )SM(basics/)ES(.)EP(

  )0 P(The purpose of a smoke test is to make sure the library's public headers
  can be included \201including in the installed case, no pun intended\202, it can
  be linked, and its basic functionality works.)EP(

  )0 P(To achieve this, we modify )SM(driver.cpp)ES( to include the
  library's main headers and call a few functions. For example, if the library
  has the initialize/deinitialize type of functions, those are good candidates
  to call. If the library is not header-only, make sure that the smoke test
  calls at least one non-inline/template function to test symbol
  exporting.)EP(

  )BR(
  )0 P(Make sure that your test includes the library's public headers the same
  way as would be done by the library consumers.)EP(
  )BR(

  )0 P(Continuing with our )SM(libfoo)ES( example, this is what its smoke
  test might look like:)EP(

  ) 12 46 PR(#include <foo/core.hpp>
#include <foo/util.hpp>

#undef NDEBUG
#include <cassert>

int main \201\202
{
  foo::context* c \201foo::init \2010 /* flags */\202\202;
  assert \201c != nullptr\202;
  foo::deinit \201c\202;
})RP(

  )BR(
  )0 P(The C/C++ )SM(assert\201\202)ES( macro is often adequate for simple tests
  and does not require extra dependencies. But see )R32 2 A(How
  do I correctly use C/C++ assert\201\202 in tests?)EA()EP(
  )BR(

  )0 P(The test )SM(buildfile)ES( is pretty simple:)EP(

  ) 3 55 PR(import libs = libfoo%lib{foo}

exe{driver}: {hxx ixx txx cxx}{**} $libs testscript{**})RP(

  )0 P(If you have adjusted the library target name \201)SM(lib{foo})ES(\202 in
  the source subdirectory )SM(buildfile)ES(, then you will need to make
  the corresponding change in the )SM(import)ES( directive here. You may
  also want to tidy it up by removing unused prerequisite types. For
  example:)EP(

  ) 3 32 PR(import libs = libfoo%lib{foo}

exe{driver}: {hxx cxx}{**} $libs)RP(

  )0 3 39 H(2.5.3)WB 162 Sn()WB 41 Sn( Make smoke test: executables)EH(

  )0 P(If instead of a library we are packaging an executable, then instead of
  the )SM(tests/)ES( subproject we get the )SM(testscript)ES( file
  in the source subdirectory \201see )0 35 1 A(Adjust source
  )SM(buildfile)ES(: executables)35 0 TN TL()Ec /AF f D( for a refresher\202. This file can be
  used to write one or more tests that exercise our executable \201see )0 2 A(Testing)EA(
  for background\202.)EP(

  )0 P(How exactly to test any given executable depends on its functionality.
  For instance, for a compression utility we could write a roundtrip test that
  first compresses some input, then decompresses it, and finally compares the
  result to the original. For example \201taken from the )R28 2 A()SM(zstd)ES()EA(
  package repository\202:)EP(

  ) 3 53 PR(: roundtrip
:
echo 'test content' | $* -zc | $* -dc >'test content')RP(

  )0 P(On the other hand, for an executable that is a source code generator,
  proper testing would involve a separate tests package that has a build-time
  dependency on the executable and that exercises the generated code \201see )R12 2 A(How
  do I handle tests that have extra dependencies?)EA( for background and
  details\202. See the )R33 2 A()SM(thrift)ES()EA(
  package repository for an example of this setup.)EP(

  )0 P(If the executable provides a way to query its version, one test that you
  should always be able to write, and which can serve as a last resort smoke
  test, is the version check. For example:)EP(

  ) 5 58 PR(: version
:
$* --version >>~"/EOO/"
/.*$\201version.major\202\200.$\201version.minor\202\200.$\201version.patch\202.*/
EOO)RP(

  )0 P(See also )R34 2 A(How
  do I sanitize the execution of my tests?)EA()EP(

  )0 3 40 H(2.5.4)WB 163 Sn()WB 42 Sn( Test locally)EH(

  )0 P(With the smoke test ready, we can finally do some end-to-end testing of
  our library build. We will start with doing some local testing to catch
  basic mistakes and then do the full CI to detect any
  platform/compiler-specific issues.)EP(

  )0 P(First let's run the test in the default build configuration by invoking
  the build system directly \201see )0 2 A(Getting Started Guide)EA( for
  background on default configurations\202:)EP(

  ) 2 53 PR($ cd libfoo/tests/ # Change to the tests/ subproject.
$ b test)RP(

  )0 P(If there are any issues \201compile/link errors, test failures\202, try to
  address them and re-run the test.)EP(

  )0 P(Once the library builds in the default configuration and the result
  passes the tests, you can do the same for all the build configurations, in
  case you have )0 20 1 A(initialized)20 0 TN TL()Ec /AF f D( your library in
  several:)EP(

  ) 1 14 PR($ bdep test -a)RP(

  )0 3 41 H(2.5.5)WB 164 Sn()WB 43 Sn( Test locally:
  installation)EH(

  )0 P(Once the development build works, let's also test the installed version
  of the library. In particular, this makes sure that the public headers are
  installed in a way that is compatible with how they are included by our test
  \201and would be included by the library consumers\202. To test this we first
  install the library into a temporary directory:)EP(

  ) 3 44 PR($ cd libfoo/ # Change to the package root.
$ rm -rf /tmp/install
$ b install config.install.root=/tmp/install)RP(

  )0 P(Next we build just the )SM(tests/)ES( subproject out of source and
  arranging for it to find the installed library \201see )0 2 A(Output
  Directories and Scopes)EA( for background on the out of source build
  syntax\202:)EP(

  ) 4 42 PR($ cd libfoo/ # Change to the package root.
$ b test: tests/@/tmp/libfoo-tests-out/ \200
  config.cc.loptions=-L/tmp/install/lib \200
  config.bin.rpath=/tmp/install/lib)RP(

  )BR(
  )0 P(The equivalent MSVC command line would be:)EP(

  ) 5 48 PR(> b install config.install.root=c:\200tmp\200install

> set "PATH=c:\200tmp\200install\200bin;%PATH%"
> b test: tests\200@c:\200tmp\200libfoo-tests-out\200^
  config.cc.loptions=/LIBPATH:c:\200tmp\200install\200lib)RP(
  )BR(

  )0 P(It is a good idea to look over the installed files manually and make sure
  there is nothing unexpected, for example, missing or extraneous files.)EP(

  )0 P(Once done testing the installed case, let's clean things up:)EP(

  ) 1 42 PR($ rm -r /tmp/install /tmp/libfoo-tests-out)RP(

  )0 3 42 H(2.5.6)WB 165 Sn()WB 44 Sn( Test locally: distribution)EH(

  )0 P(Another special case worth testing is the preparation of the source
  distribution \201see )0 2 A(Distributing)EA(
  for background\202. This, in particular, is how your package will be turned
  into the source archive for publishing to )R1 2 A(cppget.org)EA(. Here we are primarily looking for
  missing files. As a bonus, this will also allow us to test the in source
  build. First we distribute our package to a temporary directory \201again using
  the default configuration and the build system directly\202:)EP(

  ) 2 64 PR($ cd libfoo/ # Change to the package root.
$ b dist config.dist.root=/tmp/dist config.dist.uncommitted=true)RP(

  )0 P(The result will be in the )SM(/tmp/dist/libfoo-<version>/)ES(
  directory which should resemble our )SM(libfoo/)ES( package but without
  files like )SM(.gitignore)ES(. Next we build and test the distribution
  in source:)EP(

  ) 4 32 PR($ cd /tmp/dist/libfoo-<version>/
$ b configure config.cxx=g++
$ b update
$ b test)RP(

  )BR(
  )0 P(If your package has dependencies that you import in your
  )SM(buildfile)ES(, then the above )SM(configure)ES( operation will
  most likely fail because such dependencies cannot be found \201it may succeed
  if they are available as system-installed\202. The error message will suggest
  specifying the location of each dependency with the
  )SM(config.import.*)ES( variable. You can fix this by setting each such
  )SM(config.import.*)ES( to the location of the default build
  configuration \201created in the )0 20 1 A(Initialize package
  in build configurations)20 0 TN TL()Ec /AF f D( step\202 which should contain all the necessary
  dependencies. Simply re-run the )SM(configure)ES( operation until you
  have discovered and specified all the necessary )SM(config.import.*)ES(
  variables, for example:)EP(

  ) 4 38 PR($ b configure config.cxx=g++ \200
  config.import.libz=.../foo-gcc \200
  config.import.libasio=.../foo-gcc \200
  config.import.libsqlite3=.../foo-gcc)RP(
  )BR(

  )0 P(It is a good idea to look over the distributed files manually and make
  sure there is nothing missing or extraneous.)EP(

  )0 P(Once done testing the distribution, let's clean things up:)EP(

  ) 1 17 PR($ rm -r /tmp/dist)RP(

  )0 3 43 H(2.5.7)WB 166 Sn()WB 45 Sn( Commit and test with CI)EH(

  )0 P(With local testing complete, let's commit our changes and submit a remote
  CI job to test our library on all the major platforms and with all the major
  compilers:)EP(

  ) 7 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Add smoke test"
$ git push -u

$ bdep ci)RP(

  )0 P(The result of the )0 2 A()SM()BD(bdep-ci\2011\202)ES()ES()EA(
  command is a link where you can see the status of the builds.)EP(

  )BR(
  )0 P(Make sure to wait until there are no more unbuilt configurations \201that
  is, the number of entries with the )SM(<unbuilt>)ES( or
  )SM(building)ES( result is )SM(0)ES(\202.)EP(
  )BR(

  )0 P(If any builds fail, view the logs to determine the cause, try to fix it,
  commit your fix, and CI again.)EP(

  )BR(
  )0 P(It is possible that upstream does not support some platforms or
  compilers. For example, it's common for smaller projects not to bother with
  supporting "secondary" compilers, such as MinGW GCC on Windows or Homebrew
  GCC on Mac OS.)EP(

  )0 P(If upstream expressly does not support some platform or compiler, it's
  probably not worth spending time and energy trying to support it in the
  package. Most likely it will require changes to upstream source code and
  that is best done upstream rather than in the package \201see )0 86 1 A(Don't try to fix upstream issues in the
  package)86 0 TN TL()Ec /AF f D( for background\202. In this case you would want to exclude these
  platforms/compilers from the CI builds using the )0 2 A()SM(builds)ES(
  package )SM(manifest)ES( value)EA(.)EP(

  )0 P(The other common cause of a failed build is a newer version of a compiler
  or platform that breaks upstream. In this case there are three options:
  Ideally you would want to fix this in upstream and have a new version
  released. Failing that, you may want to patch the upstream code to fix the
  issues, especially if this is one of the major platforms and/or primary
  compilers \201see )0 93 1 A(How do I patch
  upstream source code?)93 0 TN TL()Ec /AF f D( for details\202. Finally, you can just leave the
  build failing with the expectation that it will be fixed in the next
  upstream version. Note that in this case you should not exclude the failing
  build from CI.)EP(
  )BR(

  )0 2 44 H(2.6)WB 167 Sn()WB 46 Sn( Replace smoke test with upstream tests)EH(

  )0 P(With the smoke test working we can now proceed with replacing it with the
  upstream tests.)EP(

  )0 3 45 H(2.6.1)WB 168 Sn()WB 47 Sn( Understand how upstream tests
  work)EH(

  )0 P(While there are some commonalities in how C/C++ libraries are typically
  built, when it comes to tests there is unfortunately little common ground in
  how they are arranged, built, and executed. As a result, the first step in
  dealing with upstream tests is to study the existing build system and try to
  understand how they work.)EP(

  )BR(
  )0 P(If upstream tests prove incomprehensible \201which is unfortunately not
  uncommon\202 and the only options you see are to go with just the smoke test or
  to give up, then go with just the smoke test. In this case it's a good idea
  to create an issue in the package repository mentioning that upstream tests
  are still a TODO.)EP(
  )BR(

  )BR(
  )0 P(If instead of a library you are packaging an executable, then whether the
  below steps will apply depends on the functionality of the executable.)EP(

  )0 P(In particular, testing source code generators would normally involve
  exercising the generated code, in which case the following will largely
  apply, though in this case the tests would need to be placed into a separate
  tests package that has a build-time dependency on the executable \201see )R12 2 A(How
  do I handle tests that have extra dependencies?)EA( for background and
  details\202. In fact, if a source code generator is accompanied by a runtime
  library, then the tests will normally exercise them together \201though a
  runtime library might also have its own tests\202. See the )R33 2 A()SM(thrift)ES()EA(
  package repository for an example of this setup.)EP(
  )BR(

  )0 P(To get you started with analyzing the upstream tests, below are some of
  the questions you would likely need answered before you can proceed with the
  conversion:)EP(

  )UL(  )-1 LI()BD(Are upstream tests unit tests or integration tests?)ES(

  )0 P(While the distinction is often fuzzy, for our purposes the key
  differentiator between unit and integration tests is which API they use:
  integration tests only use the library's public API while unit tests need
  access to the implementation details.)EP(

  )0 P(Normally \201but not always\202, unit tests will reside next to the library
  source code since they need access to more than just the public headers and
  the library binary \201private headers, individual object files, utility
  libraries, etc\202. While integration tests are normally \201but again not always\202
  placed into a separate subdirectory, usually called )SM(tests)ES( or
  )SM(test)ES(.)EP(

  )0 P(If the library has unit tests, then refer to )0 2 A(Implementing
  Unit Testing)EA( for background on how to handle them in
  )SM(build2)ES(.)EP(

  )0 P(If the library has integration tests, then use them to replace \201or
  complement\202 the smoke test.)EP(

  )0 P(If the library has unit tests but no integration tests, then it is
  recommended to keep the smoke test since that's the only way the library
  will be tested via its public API.)EP(

  )-1 LI()BD(Do upstream tests use an external testing framework?)ES(

  )0 P(Oftentimes a C++ library will use an external testing framework to
  implement tests. Popular choices include )R20 2 A()SM(catch2)ES()EA(, )R35 2 A()SM(gtest)ES()EA(, )R36 2 A()SM(doctest)ES()EA(, and )R37 2 A()SM(libboost-test)ES()EA(.)EP(

  )0 P(If a library uses such an external testing framework, then it is
  recommended to factor tests into a separate package in order to avoid making
  the library package depend on the testing framework \201which is only required
  during testing\202. See )R12 2 A(How
  do I handle tests that have extra dependencies?)EA( for details.)EP(

  )BR(
  )0 P(Sometimes you will find that upstream bundles the source code of the
  testing framework with their tests. This is especially common with
  )SM(catch2)ES(. If that's the case, it is strongly recommended that you
  "unbundle" it by making it a proper external dependency. See )0 89 1 A(Don't bundle dependencies)89 0 TN TL()Ec /AF f D( for background.)EP(
  )BR(

  )-1 LI()BD(Are upstream tests in a single or multiple executables?)ES(

  )0 P(It's not unusual for libraries to have a single test executable that runs
  all the test cases. This is especially common if a C++ testing framework is
  used. In this case it is natural to replace the contents of the smoke test
  with the upstream source code, potentially renaming the test subdirectory
  \201)SM(basics/)ES(\202 to better match upstream naming.)EP(

  )0 P(If upstream has multiple test executables, then they could all be in a
  single test subdirectory \201potentially reusing some common bits\202 or spread
  over multiple subdirectories. In both cases it's a good idea to follow the
  upstream structure unless you have good reasons to deviate. In the former
  case \201all executables in the same subdirectory\202, you can re-purpose the
  smoke test subdirectory. In the latter case \201each executable in a separate
  subdirectory\202 you can make copies of the smoke test subdirectory.)EP(

  )-1 LI()BD(Do upstream tests use an internal utility library?)ES(

  )0 P(If there are multiple test executables and they need to share some common
  functionality, then it's not unusual for upstream to place such
  functionality into a static library and then link it to each test
  executable. In )SM(build2)ES( such an internal library is best
  represented with a utility library \201see )0 2 A(Implementing
  Unit Testing)EA( for details\202. See the following section for an
  example.)EP(

  )-1 LI()BD(Are upstream tests well behaved?)ES(

  )0 P(Unfortunately, it's not uncommon for upstream tests not to behave well,
  such as to write diagnostics to )SM(stdout)ES( instead of
  )SM(stderr)ES(, create temporary files without cleaning them up, or
  assume presence of input files in the current working directory. For details
  on how to deal with such situations see )R34 2 A(How
  do I sanitize the execution of my tests?)EA()EP(
  )LU(

  )0 3 46 H(2.6.2)WB 169 Sn()WB 48 Sn( Convert smoke test to upstream
  tests)EH(

  )0 P(Once you have a good grasp of how upstream tests work, convert or replace
  the smoke test with the upstream tests. If upstream has multiple test
  executables, you may want to deal with one test at a time, making sure that
  it passes before moving to the next one.)EP(

  )0 P(It's normally a good idea to use the smoke test )SM(buildfile)ES( as
  a starting point for upstream tests. To recap, the smoke test
  )SM(buildfile)ES( for our )SM(libfoo)ES( example ended up looking
  like this:)EP(

  ) 3 32 PR(import libs = libfoo%lib{foo}

exe{driver}: {hxx cxx}{**} $libs)RP(

  )0 P(At a minimum you will most likely need to change the name of the
  executable to match upstream. If you need to build multiple executables in
  the same directory, then it's probably best to get rid of the name pattern
  for the source files and specify the prerequisite names explicitly, for
  example:)EP(

  ) 4 32 PR(import libs = libfoo%lib{foo}

./: exe{test1}: cxx{test1} $libs
./: exe{test2}: cxx{test2} $libs)RP(

  )0 P(If you have a large number of such test executables, then a )0 2 A()SM(for)ES(-loop)EA(
  might be a more scalable option:)EP(

  ) 4 34 PR(import libs = libfoo%lib{foo}

for src: cxx{test*}
  ./: exe{$name\201$src\202}: $src $libs)RP(

  )0 P(If the upstream tests have some common functionality that is used by all
  the test executables, then it is best placed into a utility library. For
  example:)EP(

  ) 6 40 PR(import libs = libfoo%lib{foo}

./: exe{test1}: cxx{test1} libue{common}
./: exe{test2}: cxx{test2} libue{common}

libue{common}: {hxx cxx}{common} $libs)RP(

  )0 3 47 H(2.6.3)WB 170 Sn()WB 49 Sn( Test locally)EH(

  )0 P(With the upstream tests ready, we re-do the same end-to-end testing as we
  did with the smoke test:)EP(

  )0 P()0 42 1 A(Test
  locally)42 0 TN TL()Ec /AF f D(
  )BR(  )0 43 1 A(Test locally: installation)43 0 TN TL()Ec /AF f D(
  )BR(  )0 44 1 A(Test locally: distribution)44 0 TN TL()Ec /AF f D()EP(

  )0 3 48 H(2.6.4)WB 171 Sn()WB 50 Sn( Commit and test with CI)EH(

  )0 P(With local testing complete, we commit our changes and submit a remote CI
  job. This step is similar to what )0 45 1 A(we did for
  the smoke test)45 0 TN TL()Ec /AF f D( but this time we are using the upstream tests:)EP(

  ) 7 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Add upstream tests"
$ git push

$ bdep ci)RP(

  )0 2 49 H(2.7)WB 172 Sn()WB 51 Sn( Add upstream examples, benchmarks, if
  any)EH(

  )0 P(If the upstream project provides examples and/or benchmarks and you wish
  to add them to the )SM(build2)ES( build \201which is not strictly
  necessary for the )SM(build2)ES( package to be usable\202, then now is a
  good time to do that.)EP(

  )0 P(As was mentioned in )0 16 1 A(Review and test
  auto-generated )SM(buildfile)ES( templates)16 0 TN TL()Ec /AF f D(, the recommended
  approach is to copy the )SM(tests/)ES( subproject \201potentially from the
  commit history before the smoke test was replaced with the upstream tests\202
  and use that as a starting point for examples and/or benchmarks. Do not
  forget to add the corresponding entry in the root
  )SM(buildfile)ES(.)EP(

  )0 P(Once that is done, follow the same steps as in )0 46 1 A(Replace smoke test with upstream tests)46 0 TN TL()Ec /AF f D( to add
  upstream examples/benchmarks and test the result.)EP(

  )0 2 50 H(2.8)WB 173 Sn()WB 52 Sn( Adjust root files \201)SM(buildfile)ES(,
  )SM(manifest)ES(, etc\202)EH(

  )0 P(The last few files that we need to review and potentially adjust are the
  root )SM(buildfile)ES(, package )SM(manifest)ES(, and
  )SM(PACKAGE-README.md)ES(.)EP(

  )0 3 51 H(2.8.1)WB 174 Sn()WB 53 Sn( Adjust root )SM(buildfile)ES()EH(

  )0 P(The main function of the root )SM(buildfile)ES( is to pull in all
  the subdirectories that need building plus list targets that are usually
  found in the root directory of a project, typically )SM(README.md)ES(,
  )SM(LICENSE)ES(, etc. This is what the generated root
  )SM(buildfile)ES( looks like for our )SM(libfoo)ES( project
  assuming we have symlinked )SM(README.md)ES(, )SM(LICENSE)ES(, and
  )SM(NEWS)ES( from upstream in the )0 17 1 A(Create
  final package)17 0 TN TL()Ec /AF f D( step:)EP(

  ) 7 43 PR(./: {*/ -build/}                          \200
    doc{README.md PACKAGE-README.md NEWS} \200
    legal{LICENSE} manifest

# Don't install tests.
#
tests/: install = false)RP(

  )0 P(If the upstream project provides any other documentation \201detailed change
  logs, contributing guidelines, etc\202 or legal files \201alternative licenses,
  list of authors, code of conduct, etc\202, then you may want to symlink and
  list them as the )SM(doc{})ES( and )SM(legal{})ES( prerequisites,
  respectively.)EP(

  )BR(
  )0 P(If you are packaging an executable and it provides a man page, then it
  can also be listed in the root )SM(buildfile)ES(. For example, if the
  man page file is called )SM(foo.1)ES(:)EP(

  ) 1 17 PR(./: ... man1{foo})RP(
  )BR(

  )BR(
  )0 P(One file you don't need to list is )SM(INSTALL)ES( \201or equivalent\202
  which normally contains the installation instructions for the upstream build
  system. In the )SM(build2)ES( package of a third-party project the
  )SM(PACKAGE-README.md)ES( file serves this purpose \201see )0 60 1 A(Adjust )SM(PACKAGE-README.md)ES()60 0 TN TL()Ec /AF f D(
  for details\202.)EP(
  )BR(

  )0 3 52 H(2.8.2)WB 175 Sn()WB 54 Sn( Adjust root )SM(buildfile)ES(:
  other subdirectories)EH(

  )0 P(If the upstream project has other subdirectories that makes sense to
  include into the )SM(build2)ES( package, then now is a good time to
  take care of that. The most common such case will be extra documentation
  \201besides the root )SM(README)ES(\202, typically in a subdirectory called
  )SM(doc/)ES(, )SM(docs/)ES(, or )SM(documentation/)ES(.)EP(

  )0 P(The standard procedure for handling such subdirectories will be to
  symlink the relevant files \201or the entire subdirectory\202 and then list the
  files as prerequisites. For this last step, there are two options: we can
  list the files directly in the root )SM(buildfile)ES( or we can create
  a separate )SM(buildfile)ES( in the subdirectory.)EP(

  )BR(
  )0 P(If symlinking entire subdirectories, don't forget to also list them in
  )SM(.gitattributes)ES( if you want your package to be usable from the
  )SM(git)ES( repository directly on Windows. See )R14 2 A(Symlinks and
  Windows)EA( for details.)EP(
  )BR(

  )0 P(Let's examine each approach using our )SM(libfoo)ES( as an example.
  We will assume that the upstream project contains the )SM(docs/)ES(
  subdirectory with additional )SM(*.md)ES( files that document the
  library's API. It would make sense to include them into the
  )SM(build2)ES( package.)EP(

  )0 P(Listing the subdirectory files directly in the root
  )SM(buildfile)ES( works best for simple cases, where you have a bunch
  of static files that don't require any special provisions, such as
  customizations to their installation locations. In this case we can symlink
  the entire )SM(docs/)ES( subdirectory:)EP(

  ) 2 42 PR($ cd libfoo/ # Change to the package root.
$ ln -s ../upstream/docs ./)RP(

  )0 P(The adjustments to the root )SM(buildfile)ES( are pretty
  straightforward: we exclude the )SM(docs/)ES( subdirectory \201since it
  has no )SM(buildfile)ES(\202 and list the )SM(*.md)ES( files as
  prerequisites using the )SM(doc{})ES( target type \201which, in
  particular, makes sure they are installed into the appropriate
  location\202:)EP(

  ) 4 43 PR(./: {*/ -build/ -docs/}                   \200
    doc{README.md PACKAGE-README.md NEWS} \200
    docs/doc{*.md}                        \200
    legal{LICENSE} manifest)RP(

  )0 P(The alternative approach \201create a separate )SM(buildfile)ES(\202 is a
  good choice if things are more complicated than that. Let's say we need to
  adjust the installation location of the files in )SM(docs/)ES( because
  there is another )SM(README.md)ES( inside and that would conflict with
  the root one when installed into the same location. This time we cannot
  symlink the top-level )SM(docs/)ES( subdirectory \201because we need to
  place a )SM(buildfile)ES( there\202. The two options here are to either
  symlink the individual files or introduce another subdirectory level inside
  )SM(docs/)ES( \201which is the same approach as discussed in )0 90 1 A(Don't build your main targets in the
  root )SM(buildfile)ES()90 0 TN TL()Ec /AF f D(\202. Let's illustrate both sub-cases.)EP(

  )0 P(Symlinking individual files works best when you don't expect the set of
  files to change often. For example, if )SM(docs/)ES( contains a man
  page and its HTML rendering, then it's unlikely this set will change. On the
  other hand, if )SM(docs/)ES( contains a manual split into an
  )SM(.md)ES( file per chapter, then there is a good chance this set of
  files will fluctuate between releases.)EP(

  )0 P(Continuing with our )SM(libfoo)ES( example, this is how we symlink
  the individual )SM(*.md)ES( files in )SM(docs/)ES(:)EP(

  ) 4 42 PR($ cd libfoo/ # Change to the package root.
$ mkdir docs
$ cd docs/
$ ln -s ../../upstream/docs/*.md ./)RP(

  )0 P(Then write a new )SM(buildfile)ES( in )SM(docs/)ES(:)EP(

  ) 7 71 PR(./: doc{*.md}

# Install the documentation in docs/ into the manual/ subdirectory of,
# say, /usr/share/doc/libfoo/ since we cannot install both its and root
# README.md into the same location.
#
doc{*.md}: install = doc/manual/)RP(

  )0 P(Note that we don't need to make any changes to the root
  )SM(buildfile)ES( since this subdirectory will automatically get picked
  up by the )SM({*/\240-build/})ES( name pattern that we have
  there.)EP(

  )0 P(Let's now look at the alternative arrangement with another subdirectory
  level inside )SM(docs/)ES(. Here we achieve the same result but in a
  slightly different way. Specifically, we call the subdirectory
  )SM(manual/)ES( and install recreating subdirectories \201see )0 2 A(Installing)EA(
  for background\202:)EP(

  ) 4 42 PR($ cd libfoo/ # Change to the package root.
$ mkdir -p docs/manual
$ cd docs/manual/
$ ln -s ../../../upstream/docs/*.md ./)RP(

  )0 P(And the corresponding )SM(buildfile)ES( in )SM(docs/)ES(:)EP(

  ) 10 70 PR(./: doc{**.md}

# Install the documentation in docs/ into, say, /usr/share/doc/libfoo/
# recreating subdirectories.
#
doc{*}:
{
  install = doc/
  install.subdirs = true
})RP(

  )BR(
  )0 P(Yet another option would be to open a scope for the )SM(docs/)ES(
  subdirectory directly in the root )SM(buildfile)ES( \201see )0 2 A(Output
  Directories and Scopes)EA( for background\202. For example:)EP(

  ) 2 42 PR($ cd libfoo/ # Change to the package root.
$ ln -s ../upstream/docs ./)RP(

  )0 P(And then add the following to the root )SM(buildfile)ES(:)EP(

  ) 10 68 PR(docs/
{
  ./: doc{*.md}

  # Install the documentation in docs/ into the manual/ subdirectory
  # of, say, /usr/share/doc/libfoo/ since we cannot install both its
  # and root README.md into the same location.
  #
  doc{*.md}: install = doc/manual/
})RP(

  )0 P(However, this approach should be used sparingly since it can quickly make
  the root )SM(buildfile)ES( hard to comprehend. Note also that it cannot
  be used for main targets since an export stub requires a
  )SM(buildfile)ES( to load \201see )0 90 1 A(Don't build your main targets in the
  root )SM(buildfile)ES()90 0 TN TL()Ec /AF f D( for details\202.)EP(
  )BR(

  )0 3 53 H(2.8.3)WB 176 Sn()WB 55 Sn( Adjust root
  )SM(buildfile)ES(: commit and test)EH(

  )0 P(Once all the adjustments to the root )SM(buildfile)ES( are made, it
  makes sense to test it locally \201this time from the root of the package\202,
  commit our changes, and test with CI:)EP(

  ) 3 42 PR($ cd libfoo/ # Change to the package root.
$ b test
$ bdep test -a)RP(

  )0 P(If you had to add any extra files to the root )SM(buildfile)ES( \201or
  add )SM(buildfiles)ES( in extra subdirectories\202, then it also makes
  sense to test the installation \201)0 43 1 A(Test locally: installation)43 0 TN TL()Ec /AF f D(\202 and
  the preparation of the source distribution \201)0 44 1 A(Test locally: distribution)44 0 TN TL()Ec /AF f D(\202 to make
  sure the extra files end up in the right places.)EP(

  )0 P(Then commit our changes and CI:)EP(

  ) 7 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Adjust root buildfile"
$ git push

$ bdep ci)RP(

  )0 3 54 H(2.8.4)WB 177 Sn()WB 56 Sn( Adjust )SM(manifest)ES()EH(

  )0 P(The next file we need to look over is the package's
  )SM(manifest)ES(. Here is what it will look like, using our
  )SM(libfoo)ES( as an example:)EP(

  ) 16 53 PR(: 1
name: libfoo
version: 2.1.0-a.0.z
language: c++
project: foo
summary: C++ library implementing secure Foo protocol
license: MIT ; MIT License.
description-file: README.md
package-description-file: PACKAGE-README.md
changes-file: NEWS
url: https://example.org/upstream
email: upstream@example.org
package-url: https://github.com/build2-packaging/foo
package-email: packaging@build2.org ; Mailing list.
depends: * build2 >= 0.16.0
depends: * bpkg >= 0.16.0)RP(

  )0 P(You can find the description of these and other package
  )SM(manifest)ES( values in )0 2 A(Package
  Manifest)EA( \201the manifest format is described in )0 2 A(Manifest
  Format)EA(\202.)EP(

  )0 P(In the above listing the values that we likely need to adjust are
  )SM(summary)ES( and )SM(license)ES(, unless correctly
  auto-detected by )SM(bdep-new)ES( in the )0 17 1 A(Create final package)17 0 TN TL()Ec /AF f D( step. See )0 57 1 A(Adjust )SM(manifest)ES(:
  )SM(summary)ES()57 0 TN TL()Ec /AF f D( and )0 58 1 A(Adjust
  )SM(manifest)ES(: )SM(license)ES()58 0 TN TL()Ec /AF f D( below for guidelines on
  changing these values.)EP(

  )BR(
  )0 P(It is not uncommon for projects to be licensed under multiple licenses.
  Note, however, that )SM(bdep-new)ES( will only detect one license and
  you will need to specify any additional licenses manually.)EP(
  )BR(

  )0 P(We will also need to change )SM(url)ES( and )SM(email)ES( with
  the upstream project's homepage URL and e-mail, respectively. If upstream
  doesn't have a dedicated website for the project, then use its repository
  URL on GitHub or equivalent. For e-mail you would normally use a mailing
  list address. If upstream doesn't have any e-mail contacts, then you can
  drop this value from the )SM(manifest)ES(. The )SM(package-url)ES(
  and )SM(package-email)ES( values normally do not need to be
  changed.)EP(

  )BR(
  )0 P()R38 2 A(packaging@build2.org)EA( is a mailing
  list for discussions related to the packaging efforts of third-party
  projects.)EP(
  )BR(

  )0 P(Note also that while you may be tempted to adjust the
  )SM(version)ES( value, resist this temptation since this will be done
  automatically by )0 2 A()SM()BD(bdep-release\2011\202)ES()ES()EA(
  later.)EP(

  )0 P(You may also want to add the following values in certain cases:)EP(

  )0 DL(  )0 DT()0 2 A()SM()BD(changes-file)ES()ES()EA(
  )DD(If you have added any extra news of changelog files to the root
  )SM(buildfile)ES( \201see )0 53 1 A(Adjust root
  buildfile)53 0 TN TL()Ec /AF f D(\202, then it may also make sense to list them in the
  )SM(manifest)ES(. For example:

  ) 1 27 PR(changes-file: ChangeLog.txt)RP(

  )0 DT()0 2 A()SM()BD(topics)ES()ES()EA(
  )DD(Package topics. For example:

  ) 1 42 PR(topics: network protocol, network security)RP(

  )BR(
  )0 P(If the upstream project is hosted on GitHub or similar, then you can
  usually copy the topics from the upstream repository description.)EP(
  )BR(

  )0 DT()0 2 A()SM()BD(doc-url)ES()ES()EA(
  )BR(  )0 2 A()SM()BD(src-url)ES()ES()EA(
  )DD(Documentation and source code URLs. For example:

  ) 2 37 PR(doc-url: https://example.org/foo/doc/
src-url: https://github.com/.../foo)RP(
  )LD(

  )0 3 55 H(2.8.5)WB 178 Sn()WB 57 Sn( Adjust )SM(manifest)ES(:
  )SM(summary)ES()EH(

  )0 P(For )SM(summary)ES( use a brief description of the functionality
  provided by the library or executable. Less than 70 characters is a good
  target to aim for. Don't capitalize subsequent words unless proper nouns and
  omit the trailing dot. For example:)EP(

  ) 1 32 PR(summary: Vim xxd hexdump utility)RP(

  )0 P(Omit weasel words such as "modern", "simple", "fast", "small", etc.,
  since they don't convey anything specific. Omit "header-only" or
  "single-header" for C/C++ libraries since, at least in the context of
  )SM(build2)ES(, it does not imply any benefit.)EP(

  )0 P(If upstream does not offer a sensible summary, the following template is
  recommended for libraries:)EP(

  ) 2 36 PR(summary: <functionality> C library
summary: <functionality> C++ library)RP(

  )0 P(For example:)EP(

  ) 2 61 PR(summary: Event notification C library
summary: Validating XML parsing and serialization C++ library)RP(

  )0 P(If the project consists of multiple packages, it may be tempting to name
  each package in terms of the overall project name, for example:)EP(

  ) 2 27 PR(name: libigl-core
summary: libigl core module)RP(

  )0 P(This doesn't give the user any clue about what functionality is provided
  unless they find out what )SM(libigl)ES( is about. Better:)EP(

  ) 1 53 PR(summary: Geometry processing C++ library, core module)RP(

  )0 P(If you follow the above pattern, then to produce a summary for external
  tests or examples packages simply add "tests" or "examples" at the end, for
  example:)EP(

  ) 2 62 PR(summary: Event notification C library tests
summary: Geometry processing C++ library, core module examples)RP(

  )0 3 56 H(2.8.6)WB 179 Sn()WB 58 Sn( Adjust )SM(manifest)ES(:
  )SM(license)ES()EH(

  )0 P(For )SM(license)ES(, use the )R39 2 A(SPDX license ID)EA( if at all possible. If
  multiple licenses are involved, use the SPDX License expression. See the )R40 2 A()SM(license)ES(
  manifest value)EA( documentation for details, including the list of the SPDX
  IDs for the commonly used licenses.)EP(

  )0 3 57 H(2.8.7)WB 180 Sn()WB 59 Sn( Adjust )SM(manifest)ES(:
  commit and test)EH(

  )0 P(Once all the adjustments to the )SM(manifest)ES( are made, it makes
  sense to test it locally, commit our changes, and test with CI:)EP(

  ) 3 42 PR($ cd libfoo/ # Change to the package root.
$ b test
$ bdep test -a)RP(

  )0 P(Then commit our changes and CI:)EP(

  ) 7 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Adjust manifest"
$ git push

$ bdep ci)RP(

  )0 3 58 H(2.8.8)WB 181 Sn()WB 60 Sn( Adjust
  )SM(PACKAGE-README.md)ES()EH(

  )0 P(The last package file we need to adjust is )SM(PACKAGE-README.md)ES(
  which describes how to use the package from a )SM(build2)ES(-based
  project. The template generated by )SM(bdep-new)ES( establishes the
  recommended structure and includes a number of placeholders enclosed in
  )SM(<\240>)ES(, such as )SM(<UPSTREAM-NAME>)ES( and
  )SM(<SUMMARY-OF-FUNCTIONALITY>)ES(, that need to be replaced with
  the package-specific content. While all the placeholders should be
  self-explanatory, below are a couple of guidelines.)EP(

  )0 P(For )SM(<SUMMARY-OF-FUNCTIONALITY>)ES( it's best to copy a
  paragraph or two from the upstream documentation, usually from
  )SM(README.md)ES( or the project's web page.)EP(

  )BR(
  )0 P(If the )SM(bdep new)ES( command was able to extract the summary from
  upstream )SM(README)ES(, then the summary in the heading \201first line\202
  will contain that information. Otherwise, you would need to adjust it
  manually, similar to )SM(manifest)ES( above. In this case use the
  )SM(summary)ES( value form the )SM(manifest)ES(, perhaps slightly
  shortened.)EP(
  )BR(

  )0 P(If the package contains a single importable target, as is typical with
  libraries, then it makes sense to drop the "Importable targets" section
  since it won't add anything that hasn't already been said in the "Usage"
  section.)EP(

  )0 P(Similarly, if the package has no configuration variables, then it makes
  sense to drop the "Configuration variables" section.)EP(

  )0 P(For inspiration, see)EP(

  )0 P()R41 2 A()SM(PACKAGE-README.md)ES()EA(
  in )R28 2 A()SM(zstd)ES()EA(
  and )R42 2 A()SM(PACKAGE-README.md)ES()EA(
  in )R43 2 A()SM(libevent)ES()EA(
  \201libraries\202 as well as )R44 2 A()SM(PACKAGE-README.md)ES()EA(
  in )R28 2 A()SM(zstd)ES()EA(
  and )R45 2 A()SM(README.md)ES()EA(
  in )R46 2 A()SM(xxd)ES()EA(
  \201executables\202.)EP(

  )BR(
  )0 P(If upstream does not provide a )SM(README)ES( file, then it makes
  sense to rename )SM(PACKAGE-README.md)ES( to just
  )SM(README.md)ES( in the )SM(build2)ES( package, as was done in
  the )SM(xxd)ES( package mentioned above.)EP(
  )BR(

  )0 P(Once )SM(PACKAGE-README.md)ES( is ready, commit and push the
  changes. You may also want to view the result on GitHub to make sure
  everything is rendered correctly.)EP(

  ) 5 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Adjust PACKAGE-README.md"
$ git push)RP(

  )0 2 59 H(2.9)WB 182 Sn()WB 61 Sn( Adjust package repository
  )SM(README.md)ES()EH(

  )0 P(With all the package files taken care of, the last file we need to adjust
  is )SM(README.md)ES( in the root of our package repository \201it was
  created in the )0 10 1 A(Initialize package repository with
  )SM(bdep new)ES()10 0 TN TL()Ec /AF f D( step\202.)EP(

  )BR(
  )0 P(If you need to add additional packages and are doing this one package at
  a time \201for example, first library then executable in the "library and
  executable" project\202, then this is the point where you would want to restart
  from )0 12 1 A(Create package and generate
  )SM(buildfile)ES( templates)12 0 TN TL()Ec /AF f D( for another iteration. Only once all
  the packages are added does it make sense to continue with updating this
  )SM(README.md)ES(.)EP(
  )BR(

  )0 P(The primary purpose of the package repository )SM(README.md)ES( is
  to provide setup instructions as well as any other relevant information for
  the development of the packages as opposed to their consumption. However,
  it's also a good idea to give a brief summary of what this repository is
  about and to point users interested in consumption to the
  )SM(PACKAGE-README.md)ES( files.)EP(

  )0 P(The template generated by )SM(bdep new)ES( establishes the
  recommended structure to achieve these objectives. It includes a number of
  placeholders enclosed in )SM(<\240>)ES(, such as
  )SM(<UPSTREAM-URL>)ES( and
  )SM(<SUMMARY-OF-FUNCTIONALITY>)ES(, that need to be replaced with
  the repository-specific content. While all the placeholders should be
  self-explanatory, below are a couple of guidelines.)EP(

  )0 P(If there is a single package, then )SM(<SUMMARY>)ES( in the
  heading can be the same as in )SM(PACKAGE-README.md)ES(. If there are
  multiple packages, then use an overall summary of the upstream project.)EP(

  )0 P(For )SM(<SUMMARY-OF-FUNCTIONALITY>)ES( it's best to copy a
  paragraph or two from the upstream documentation, usually from
  )SM(README.md)ES( or the project's web page. Again, for a single
  package, this can be copied directly from
  )SM(PACKAGE-README.md)ES(.)EP(

  )0 P(If there are multiple packages in the repository, then it's recommended
  to replace a single link to )SM(PACKAGE-README.md)ES( with a list of
  links \201this also shows the available packages\202. For example:)EP(

  ) 5 65 PR(... If you want to use `foo` in your `build2`-based project, then
instead see the accompanying `PACKAGE-README.md` files:

* [`libfoo/PACKAGE-README.md`]\201libfoo/PACKAGE-README.md\202
* [`foo/PACKAGE-README.md`]\201foo/PACKAGE-README.md\202)RP(

  )0 P(The remainder of the generated )SM(README.md)ES( file are the
  standard )SM(bdep)ES( initialization instructions. Adjust them if your
  package repository requires anything special \201for example, a host
  configuration\202. This is also the place to mention anything unusual, such as
  that upstream does not use semver \201and thus only a subset of
  )SM(bdep)ES( functionality is usable\202.)EP(

  )0 P(For inspiration, see )R47 2 A()SM(README.md)ES()EA(
  in the )R28 2 A()SM(zstd)ES()EA(
  package repository.)EP(

  )0 P(Once the repository )SM(README.md)ES( is ready, commit and push the
  changes. You may also want to view the result on GitHub to make sure
  everything is rendered correctly.)EP(

  ) 5 53 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Adjust package repository README.md"
$ git push)RP(

  )0 2 60 H(2.10)WB 183 Sn()WB 62 Sn( Release and publish)EH(

  )0 P(Once all the adjustments are in and everything is tested, we can release
  the final version of the package and then publish it to )R1 2 A(cppget.org)EA(. Both of these steps are automated
  with the corresponding )SM(bdep)ES( commands. But before performing
  these steps we need to transfer the package repository to )R5 2 A(github.com/build2-packaging)EA(.)EP(

  )0 3 61 H(2.10.1)WB 184 Sn()WB 63 Sn( Transfer package
  repository)EH(

  )0 P(If you have been doing your work in a repository in your personal
  workspace, then now is the time to transfer it to the )R5 2 A(github.com/build2-packaging)EA(
  organization.)EP(

  )BR(
  )0 P(It is important to transfer the repository before publishing the first
  version of the package since the repository is used as a proxy for package
  name ownership \201see )0 2 A()SM()BD(bdep-publish\2011\202)ES()ES()EA(
  for details\202. If you publish the package from your personal workspace and
  then transfer the repository, the ownership information will have to be
  adjusted manually, which we would prefer to avoid.)EP(
  )BR(

  )0 P(The first step is to become a member of this organization \201unless you
  already are\202. This will give you permissions to create new repositories,
  which is required to perform a transfer \201you will also have full read/write
  access to the repository once transferred\202. To get an invite, )R10 2 A(get in touch)EA( not
  forgetting to mention your GitHub user name.)EP(

  )0 P(If your repository has any prefixes, such as )SM(build2-)ES(, or
  suffixes such as )SM(-package)ES(, then the next step is to rename it
  to follow the )0 8 1 A(Use upstream repository name as
  package repository name)8 0 TN TL()Ec /AF f D( guideline. Go to the repository's Settings on
  GitHub where you should see the Rename button.)EP(

  )0 P(Finally, to perform the transfer, go to the repository's Settings, Danger
  Zone section, where you should see the Transfer button. Select
  )SM(build2-packaging)ES( as the organization to transfer to, and
  complete the transfer.)EP(

  )0 P(Once transferred, you will be considered the maintainer of this package
  going forward. If other members of the )SM(build2-packaging)ES(
  organization wish to participate in the package maintenance, the correct
  etiquette is to do this via pull requests. However, if you lose interest in
  maintaining a package or otherwise become unresponsive, we may allow a new
  maintainer to take over this role.)EP(

  )BR(
  )0 P(In extraordinary circumstances the )SM(build2-packaging)ES(
  administrators may make direct changes to the package, for example, to
  release a new revision in order to address a critical issue. They will still
  try to coordinate the changes with the maintainer but may not always be able
  to wait for a response in time-sensitive cases.)EP(
  )BR(

  )0 3 62 H(2.10.2)WB 185 Sn()WB 64 Sn( Release final version)EH(

  )0 P(As you may recall, our package currently has a pre-release snapshot
  version of the upstream version \201see )0 18 1 A(Adjust package version)18 0 TN TL()Ec /AF f D(\202. Once all
  the changes are in, we can change to the final upstream version, in a sense
  signaling that this package version is ready.)EP(

  )BR(
  )0 P(If you are working in a branch, then now is also the time to merge it
  into )SM(master)ES( \201or equivalent\202.)EP(
  )BR(

  )0 P(The recommended way to do this is with the )0 2 A()SM()BD(bdep-release\2011\202)ES()ES()EA(
  command \201see )0 2 A(Versioning
  and Release Management)EA( for background\202. Besides replacing the
  )SM(version)ES( value in the package )SM(manifest)ES( file, it
  also commits this change, tags it with the
  )SM(v)I(X)ES(.)I(Y)ES(.)I(Z)ES()ES( tag, and can be instructed to push
  the changes \201or show the )SM(git)ES( command to do so\202. This command
  also by default "opens" the next development version, which is something
  that we normally want for our own projects but not when we package a
  third-party one \201since we cannot predict which version upstream will release
  next\202. So we disable this functionality. For example:)EP(

  ) 2 50 PR($ cd foo/ # Change to the package repository root.
$ bdep release --no-open --show-push)RP(

  )0 P(Then review the commit made by )SM(bdep-release)ES( and, if
  everything looks good, push the changes by copying the command that it
  printed:)EP(

  ) 2 17 PR($ git diff HEAD~1
$ git push ...)RP(

  )BR(
  )0 P(If something is wrong and you need to undo this commit, don't forget to
  also remove the tag. Note also that once you have pushed your changes, you
  cannot undo the commit. Instead, you will need to make a revision. See )0 66 1 A(Version management)66 0 TN TL()Ec /AF f D( for background and
  details.)EP(
  )BR(

  )0 3 63 H(2.10.3)WB 186 Sn()WB 65 Sn( Publish released version)EH(

  )0 P(Once the version is released we can publish the package to )R1 2 A(cppget.org)EA( with the )0 2 A()SM()BD(bdep-publish\2011\202)ES()ES()EA(
  command \201see )0 2 A(Versioning
  and Release Management)EA( for background\202:)EP(

  ) 2 50 PR($ cd foo/ # Change to the package repository root.
$ bdep publish)RP(

  )0 P(The )SM(bdep-publish)ES( command prepares the source distribution of
  your package, uploads the resulting archive to the package repository, and
  prints a link to the package submission in the queue. Open this link in the
  browser and check that there are no surprises in the build results \201they
  should match the earlier CI results\202 or in the displayed package information
  \201)SM(PACKAGE-README.md)ES(, etc\202.)EP(

  )BR(
  )0 P(While there should normally be no discrepancies in the build results
  compared to our earlier CI submissions, the way the packages are built on CI
  and in the package repository are not exactly the same. Specifically, CI
  builds them from )SM(git)ES( while the package repository \235 from
  the submitted package archives. If there are differences, it's almost always
  due to issues in the source distribution preparation \201see )0 44 1 A(Test locally: distribution)44 0 TN TL()Ec /AF f D(\202.)EP(
  )BR(

  )0 P(If everything looks good, then you are done: the package submission will
  be moved to )R1 2 A(cppget.org)EA( for further testing
  and review. If this further testing or review identifies any problems with
  the package, then an issue will be created in the package repository with
  the feedback \201see )0 108 1 A(Package Review)108 0 TN TL()Ec /AF f D( for details\202. In this
  case you may need to )0 67 1 A(release
  and publish a version revision)67 0 TN TL()Ec /AF f D( to address any serious problems. But
  before doing that \201or releasing a new version\202, you should first read
  through the following )0 66 1 A(Package version
  management)66 0 TN TL()Ec /AF f D( section to understand the recommended "version lifecycle" of
  a third-party package.)EP(

  )0 P(Also, if there is an issue for this package in )R11 2 A(github.com/build2-packaging/WISHLIST)EA(,
  then you would want to add a comment and close it once the package has been
  moved to )R1 2 A(cppget.org)EA(.)EP(

  )0 2 64 H(2.11)WB 187 Sn()WB 66 Sn( Package version management)EH(

  )0 P(Once we have pushed the release commit, in order to preserve continuous
  versioning \201see )0 18 1 A(Adjust package
  version)18 0 TN TL()Ec /AF f D( for background\202, no further changes should be made to the
  package without also changing its version.)EP(

  )BR(
  )0 P(More precisely, you can make and commit changes without changing the
  version provided they don't affect the package. For example, you may keep a
  )SM(TODO)ES( file in the root of your repository which is not part of
  any package. Updating such a file without changing the version is ok since
  the package remains unchanged.)EP(
  )BR(

  )0 P(While in our own projects we can change the versions as we see fit, with
  third-party projects the versions are dictated by upstream and as a result
  we are limited to what we can use to fix issues in our packaging work
  itself. It may be tempting \201and perhaps even conceptually correct\202 to
  release a patch version for our own fixes, however, we will be in trouble if
  later upstream releases the same patch version but with a different set of
  changes \201plus the users of our package may wonder where did this version
  come from\202. As a result, we should only change the major, minor, or patch
  components of the package version in response to the corresponding upstream
  releases. For fixes to the packaging work itself we should instead use
  version revisions.)EP(

  )BR(
  )0 P(Because a revision replaces the existing version, we should try to limit
  revision changes to bug fixes and preferably only in the package
  "infrastructure" \201)SM(buildfiles)ES(, )SM(manifest)ES(, etc\202.
  Fixes to upstream source code should be limited to critical bugs and be
  preferably backported from upstream. To put it another way, changes in a
  revision should have an even more limited scope than a patch release.)EP(
  )BR(

  )0 P(Based on this, the recommended "version lifecycle" for a third-party
  package is as follows:)EP(

  )4 OL(  )-1 LI(After a release \201the )0 64 1 A(Release
  final version)64 0 TN TL()Ec /AF f D( step above\202, for example, version )SM(2.1.0)ES(, the
  package enters a "revision phase" where we can release revisions
  \201)SM(2.1.0+1)ES(, )SM(2.1.0+2)ES(, etc\202 to address any issues in
  the packaging work. See )0 67 1 A(New
  revision)67 0 TN TL()Ec /AF f D( for the detailed procedure.

  )-1 LI(When a new upstream version is released, for example version
  )SM(2.2.0)ES(, and we wish to upgrade our package to this version, we
  switch to its pre-release snapshot version \201)SM(2.2.0-a.0.z)ES(\202 the
  same way as we did in the )0 18 1 A(Adjust
  package version)18 0 TN TL()Ec /AF f D( step initially. See )0 68 1 A(New version)68 0 TN TL()Ec /AF f D( for the detailed
  procedure.

  )-1 LI(Once we are done upgrading to the new upstream version, we release the
  final version just like in the )0 64 1 A(Release final version)64 0 TN TL()Ec /AF f D( step
  initially. At this point the package enters another revision phase.
  )LO(

  )0 P(Note also that in the above example, once we have switched to
  )SM(2.2.0-a.0.z)ES(, we cannot go back and release another revision or
  patch version for )SM(2.1.0)ES( on the current branch. Instead, we will
  need to create a separate branch for the )SM(2.1.Z)ES( release series
  and make a revision or patch version there. See )0 83 1 A(New version/revision in old
  release series)83 0 TN TL()Ec /AF f D( for the detailed procedure.)EP(

  )0 3 65 H(2.11.1)WB 188 Sn()WB 67 Sn( New revision)EH(

  )0 P(As discussed in )0 66 1 A(Package version
  management)66 0 TN TL()Ec /AF f D(, we release revisions to fix issues in the package
  "infrastructure" \201)SM(buildfiles)ES(, )SM(manifest)ES(, etc\202 as
  well as critical bugs in upstream source code.)EP(

  )BR(
  )0 P(Releasing a new revision is also a good opportunity to review and fix any
  accumulated issues that didn't warrant a revision on their own. See )0 80 1 A(New version: review/fix
  accumulated issues)80 0 TN TL()Ec /AF f D( for background.)EP(
  )BR(

  )0 P(In the revision phase of the package version lifecycle \201i.e., when the
  version does not end with )SM(-a.0.z)ES(\202, every commit must be
  accompanied by the revision increment to maintain continuous versioning. As
  a result, each revision release commit necessarily also contains the changes
  in this revision. Below is a typical workflow for releasing and publishing
  the revision:)EP(

  ) 8 37 PR($ # make changes
$ # test locally
$ git add .
$ bdep release --revision --show-push
$ # review commit
$ git push ...
$ # test with CI
$ bdep publish)RP(

  )0 P(Customarily, the revision commit message has the )SM("Release version
  X.Y.Z+R")ES( summary as generated by )SM(bdep-release)ES( followed
  by the description of changes, organized in a list if there are several. For
  example:)EP(

  ) 6 68 PR(Release version 2.1.0+1

- Don't compile port/strlcpy.c on Linux if GNU libc is 2.38 or newer
  since it now provides the strl*\201\202 functions.

- Switch to using -pthread instead of -D_REENTRANT/-lpthread.)RP(

  )BR(
  )0 P(The fact that all the changes must be in a single commit is another
  reason to avoid substantial changes in revisions.)EP(
  )BR(

  )0 P(Note also that you can make multiple commits while developing and testing
  the changes for a revision in a separate branch. However, once they are
  ready for a release, they need to be squashed into a single commit. The )0 2 A()SM()BD(bdep-release\2011\202)ES()ES()EA(
  command provides the )SM(--amend)ES( and )SM(--squash)ES( options
  to automate this. For example, here is what a workflow with a separate
  branch might look like:)EP(

  ) 22 63 PR($ git checkout -b wip-2.1.0+1

$ # make strl*\201\202 changes
$ # test locally
$ git commit -a -m "Omit port/strlcpy.c if glibc 2.38 or newer"
$ git push -u
$ # test with CI

$ # make pthread changes
$ # test locally
$ git commit -a -m "Switch to using -pthread"
$ git push
$ # test with CI

$ git checkout master
$ git merge --ff-only wip-2.1.0+1
$ bdep release --revision --show-push --amend --squash 2
$ # review commit
$ # test locally
$ git push ...
$ # test with CI
$ bdep publish)RP(

  )0 3 66 H(2.11.2)WB 189 Sn()WB 68 Sn( New version)EH(

  )0 P(As discussed in )0 66 1 A(Package version
  management)66 0 TN TL()Ec /AF f D(, we release new versions strictly in response to the
  corresponding upstream releases.)EP(

  )0 P(The amount or work required to upgrade a package to a new upstream
  version depends on the extend of changes in the new version.)EP(

  )0 P(On one extreme you may have a patch release which fixes a couple of bugs
  in the upstream source code without any changes to the set of source files,
  upstream build system, etc. In such cases, upgrading a package is a simple
  matter of creating a new work branch, pointing the )SM(upstream)ES(
  )SM(git)ES( submodule to the new release, running tests, and then
  merging, releasing, and publishing a new package version.)EP(

  )0 P(On the other extreme you may have a new major upstream release which is
  essentially a from-scratch rewrite with new source code layout, different
  upstream build system, etc. In such cases it may be easier to likewise start
  from scratch. Specifically, create a new work branch, point the
  )SM(upstream)ES( )SM(git)ES( submodule to the new release, delete
  the existing package, and continue from )0 12 1 A(Create
  package and generate )SM(buildfile)ES( templates)12 0 TN TL()Ec /AF f D(.)EP(

  )0 P(Most of the time, however, it will be something in between where you may
  need to tweak a few things here and there, such as adding symlinks to new
  source files \201or removing old ones\202, tweaking the )SM(buildfiles)ES( to
  reflect changes in the upstream build system, etc.)EP(

  )0 P(The following sections provide a checklist-like sequence of steps that
  can be used to review upstream changes with links to the relevant earlier
  sections in case adjustments are required.)EP(

  )0 3 67 H(2.11.3)WB 190 Sn()WB 69 Sn( New version:
  create new work branch)EH(

  )0 P(When upgrading a package to a new upstream version it's recommended to do
  this in a new work branch which, upon completion, is merged into
  )SM(master)ES( \201or equivalent\202. For example, if the new upstream
  version is )SM(2.2.0)ES(:)EP(

  ) 1 27 PR($ git checkout -b wip-2.2.0)RP(

  )BR(
  )0 P(If you are not the maintainer of the package and would like to help with
  preparing the new version, then, when everything is ready, use this branch
  to create a pull request instead of merging it directly.)EP(
  )BR(

  )0 3 68 H(2.11.4)WB 191 Sn()WB 70 Sn( New version: open
  new version)EH(

  )0 P(This step corresponds to )0 18 1 A(Adjust
  package version)18 0 TN TL()Ec /AF f D( during the initial packaging. Here we can make use of
  the )SM(bdep-release)ES( command to automatically open the new version
  and make the corresponding commit. For example, if the new upstream version
  is )SM(2.2.0)ES(:)EP(

  ) 1 49 PR($ bdep release --open --no-push --open-base 2.2.0)RP(

  )0 3 69 H(2.11.5)WB 192 Sn()WB 71 Sn( New version:
  update )SM(upstream)ES( submodule)EH(

  )0 P(This step corresponds to )0 11 1 A(Add upstream
  repository as )SM(git)ES( submodule)11 0 TN TL()Ec /AF f D( during the initial packaging.
  Here we need to update the submodule to point to the upstream commit that
  corresponds to the new version.)EP(

  )0 P(For example, if the upstream release tag we are interested in is called
  )SM(v2.2.0)ES(, to update the )SM(upstream)ES( submodule to point
  to this release commit, run the following commands:)EP(

  ) 8 52 PR($ cd upstream/
$ git fetch
$ git checkout v2.2.0
$ cd ../

$ git add .
$ git status
$ git commit -m "Update upstream submodule to 2.2.0")RP(

  )0 3 70 H(2.11.6)WB 193 Sn()WB 72 Sn( New version:
  review upstream changes)EH(

  )0 P(At this point it's a good idea to get an overview of the upstream changes
  between the two releases in order to determine which adjustments are likely
  to be required in the )SM(build2)ES( package. We can use the
  )SM(upstream)ES( submodule for that, which contains the change history
  we need.)EP(

  )0 P(One way to get an overview of changes between the releases is to use a
  graphical repository browser such as )SM(gitk)ES( and view a cumulative
  )SM(diff)ES( of changes between the two versions. For example, assuming
  the latest packaged version is tagged )SM(v2.1.0)ES( and the new
  version is tagged )SM(v2.2.0)ES(:)EP(

  ) 2 23 PR($ cd upstream/
$ gitk v2.1.0..v2.2.0 &)RP(

  )0 P(Then click on the commit tagged )SM(v2.2.0)ES(, scroll down and
  right-click on the commit tagged )SM(v2.1.0)ES(, and select the "Diff
  this -> selected" menu item. This will display the cumulative set of changes
  between these two upstream versions. Review them looking for the following
  types of changes in particular \201discussed in the following sections\202:)EP(

  )UL(  )-1 LI(Changes to the source code layout.

  )-1 LI(New dependencies being added or old removed.

  )-1 LI(New source files being added or old removed \201including in tests,
  etc\202.

  )-1 LI(Changes to the upstream build system.

  )-1 LI(Other new files/subdirectories being added or old removed.
  )LU(

  )0 3 71 H(2.11.7)WB 194 Sn()WB 73 Sn( New version:
  layout changes)EH(

  )0 P(As mentioned earlier, for drastic layout changes it may make sense to
  start from scratch and re-generate the package with the
  )SM(bdep-new)ES( command \201use )0 14 1 A(Decide on
  the package source code layout)14 0 TN TL()Ec /AF f D( as a starting point\202. On the other hand,
  if the changes are minor, then you can try to adjust things manually. An
  in-between strategy is to generate the new layout using
  )SM(bdep-new)ES( on the side and then retrofit the relevant changes in
  )SM(buildfiles)ES( to the existing package. In a sense, this approach
  uses )SM(bdep-new)ES( as a guide to figure out how to implement the new
  layout.)EP(

  )0 3 72 H(2.11.8)WB 195 Sn()WB 74 Sn( New
  version: new/old dependencies)EH(

  )0 P(If upstream added new or removed old dependencies, then you will need to
  replicate these changes in your package as in the )0 21 1 A(Add dependencies)21 0 TN TL()Ec /AF f D( and )0 29 1 A(Adjust source
  )SM(buildfile)ES(: dependencies)29 0 TN TL()Ec /AF f D( initial packaging steps.)EP(

  )0 3 73 H(2.11.9)WB 196 Sn()WB 75 Sn( New version:
  new/old source files)EH(

  )0 P(If upstream added new or removed old source files, then you will need to
  replicate these changes in your package as in the )0 22 1 A(Fill with upstream source code)22 0 TN TL()Ec /AF f D( and possibly )0 26 1 A(Adjust header
  )SM(buildfile)ES()26 0 TN TL()Ec /AF f D( and )0 31 1 A(Adjust source
  )SM(buildfile)ES(: sources, private headers)31 0 TN TL()Ec /AF f D( initial packaging
  steps.)EP(

  )0 P(Also don't forget about tests, examples, etc., which may also add new or
  remove old source files \201typically new tests\202. See )0 48 1 A(Convert smoke test to upstream
  tests)48 0 TN TL()Ec /AF f D(.)EP(

  )0 P(If there are any manual modifications to the upstream source code, then
  you will also need to re-apply them to the new version as discussed in )0 94 1 A(Modifying upstream source code
  manually)94 0 TN TL()Ec /AF f D(.)EP(

  )0 3 74 H(2.11.10)WB 197 Sn()WB 76 Sn( New version:
  changes to build system)EH(

  )0 P(If upstream changed anything in the build system, then you may need to
  replicate these changes in your package's )SM(buildfiles)ES(. The
  relevant initial packaging steps are: )0 24 1 A(Adjust project-wide build system files in
  )SM(build/)ES()24 0 TN TL()Ec /AF f D( and )0 32 1 A(Adjust source
  )SM(buildfile)ES(: build and export options)32 0 TN TL()Ec /AF f D(.)EP(

  )0 P(The corresponding steps for tests are: )0 39 1 A(Adjust project-wide build system files in
  )SM(tests/build/)ES()39 0 TN TL()Ec /AF f D( and )0 48 1 A(Convert smoke test to upstream
  tests)48 0 TN TL()Ec /AF f D(.)EP(

  )0 3 75 H(2.11.11)WB 198 Sn()WB 77 Sn( New version:
  other new/old files/subdirectories)EH(

  )0 P(If upstream added or removed any other files or subdirectories that are
  relevant to our package \201such as documentation\202, then adjust the package
  similar to the )0 53 1 A(Adjust root
  )SM(buildfile)ES()53 0 TN TL()Ec /AF f D( and )0 54 1 A(Adjust
  root )SM(buildfile)ES(: other subdirectories)54 0 TN TL()Ec /AF f D( initial packaging
  steps.)EP(

  )0 3 76 H(2.11.12)WB 199 Sn()WB 78 Sn( New version:
  review )SM(manifest)ES( and )SM(PACKAGE-README.md)ES()EH(

  )0 P(It makes sense to review the package )SM(manifest)ES( \201)0 56 1 A(Adjust )SM(manifest)ES()56 0 TN TL()Ec /AF f D(\202 and
  )SM(PACKAGE-README.md)ES( \201)0 60 1 A(Adjust
  )SM(PACKAGE-README.md)ES()60 0 TN TL()Ec /AF f D(\202 for any updates.)EP(

  )0 3 77 H(2.11.13)WB 200 Sn()WB 79 Sn( New version:
  review repository )SM(README.md)ES()EH(

  )0 P(If any new packages were added in this version or if there are any
  changes to the development workflow, then it makes sense to review and if
  necessary update package repository )SM(README.md)ES( \201)0 61 1 A(Adjust package repository
  )SM(README.md)ES()61 0 TN TL()Ec /AF f D(\202.)EP(

  )0 3 78 H(2.11.14)WB 201 Sn()WB 80 Sn( New version:
  review/fix accumulated issues)EH(

  )0 P(When a bug is identified in an already released package version, we may
  not always be able to fix it immediately \201for example, by )0 67 1 A(releasing a revision)67 0 TN TL()Ec /AF f D(\202. This
  could be because the change is too extensive/risky for a revision or simply
  not critical enough to warrant a release. In such cases it's recommended to
  file an issue in the package repository with the view to fix it when the
  next opportunity arises. Releasing a new upstream version is one such
  opportunity and it makes sense to review any accumulated package issues and
  see if any of them could be addressed.)EP(

  )0 3 79 H(2.11.15)WB 202 Sn()WB 81 Sn( New version: test
  locally and with CI)EH(

  )0 P(Once all the adjustments are in, test the package both locally and with
  CI similar to how we did it during the initial packaging after completing
  the smoke test:)EP(

  )0 P()0 42 1 A(Test locally)42 0 TN TL()Ec /AF f D(
  )BR(  )0 43 1 A(Test locally: installation)43 0 TN TL()Ec /AF f D(
  )BR(  )0 44 1 A(Test locally: distribution)44 0 TN TL()Ec /AF f D(
  )BR(  )0 45 1 A(Commit and test with CI)45 0 TN TL()Ec /AF f D()EP(

  )0 3 80 H(2.11.16)WB 203 Sn()WB 82 Sn( New version:
  merge, release, and publish)EH(

  )0 P(When the new version of the package is ready to be released, merge the
  work branch to )SM(master)ES( \201or equivalent\202:)EP(

  ) 2 31 PR($ git checkout master
$ git merge --ff-only wip-2.2.0)RP(

  )0 P(Then release and publish using the same steps as after the initial
  packaging: )0 62 1 A(Release and publish)62 0 TN TL()Ec /AF f D(.)EP(

  )0 3 81 H(2.11.17)WB 204 Sn()WB 83 Sn( New version/revision in
  old release series)EH(

  )0 P(As discussed in )0 66 1 A(Package version
  management)66 0 TN TL()Ec /AF f D(, if we have already switched to the next upstream version in
  the )SM(master)ES( \201or equivalent\202 branch, we cannot go back and
  release a new version or revision for an older release series on the same
  branch. Instead, we need to create a separate, long-lived branch for this
  work.)EP(

  )0 P(As an example, let's say we need to release another revision or a patch
  version for an already released )SM(2.1.0)ES( while our
  )SM(master)ES( branch has already moved on to )SM(2.2.0)ES(. In
  this case we create a new branch, called )SM(2.1)ES(, to continue with
  the )SM(2.1.Z)ES( release series. The starting point of this branch
  should be the latest released version/revision in the )SM(2.1)ES(
  series. Let's say in our case it is )SM(2.1.0+2)ES(, meaning we have
  released two revisions for )SM(2.1.0)ES( on the )SM(master)ES(
  branch before upgrading to )SM(2.2.0)ES(. Therefore we use the
  )SM(v2.1.0+2)ES( release tag to start the )SM(2.1)ES( branch:)EP(

  ) 1 30 PR($ git checkout -b 2.1 v2.1.0+2)RP(

  )0 P(Once this is done, we continue with the same steps as in )0 67 1 A(New revision)67 0 TN TL()Ec /AF f D( or )0 68 1 A(New version)68 0 TN TL()Ec /AF f D( except that we
  never merge this branch to )SM(master)ES(. If we ever need to release
  another revision or version in this release series, then we continue using
  this branch. In a sense, this branch becomes the equivalent of the
  )SM(master)ES( branch for this release series and you should treat it
  as such \201once published, never delete, rewrite its history, etc\202.)EP(

  )BR(
  )0 P(It is less likely but possible that you may need to release a new minor
  version in an old release series. For example, the master branch may have
  moved on to )SM(3.0.0)ES( and you want to release )SM(2.2.0)ES(
  after the already released )SM(2.1.0)ES(. In this case it makes sense
  to call the branch )SM(2)ES( since it corresponds to the
  )SM(2.Y.Z)ES( release series. If you already have the )SM(2.1)ES(
  branch, then it makes sense to rename it to )SM(2)ES(.)EP(
  )BR(

  )0 1 82 H(3)WB 205 Sn()WB 84 Sn( What Not to Do)EH(

  )0 P(This chapter describes the common anti-patterns along with the
  recommended alternative approaches.)EP(

  )0 2 83 H(3.1)WB 206 Sn()WB 85 Sn( Don't write )SM(buildfiles)ES( from
  scratch, use )SM(bdep-new)ES()EH(

  )0 P(Unless you have good reasons not to, create the initial project layout
  automatically using )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(,
  then tweak it if necessary and fill with upstream source code.)EP(

  )0 P(The main rationale here is that there are many nuances in getting the
  build right and auto-generated )SM(buildfiles)ES( had years of
  refinement and fine-tuning. The familiar structure also makes it easier for
  others to understand your build, for example while reviewing your package
  submission or helping out with the package maintenance.)EP(

  )0 P(The )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command supports a wide variety of )0 2 A(source layouts)EA(. While it
  may take a bit of time to understand the customization points necessary to
  achieve the desired layout for your first package, this will pay off in
  spades when you work on converting subsequent packages.)EP(

  )0 P(See )0 15 1 A(Craft )SM(bdep\240new)ES(
  command line to create package)15 0 TN TL()Ec /AF f D( for details.)EP(

  )0 2 84 H(3.2)WB 207 Sn()WB 86 Sn( Avoid fixing upstream issues in the
  )SM(build2)ES( package)EH(

  )0 P(Any deviations from upstream makes the )SM(build2)ES( package more
  difficult to maintain. In particular, if you make a large number of changes
  to the upstream source code, releasing a new version will require a lot of
  work. As a result, it is recommended to avoid fixing upstream issues in the
  )SM(build2)ES( package. Instead, try to have the issues fixed upstream
  and wait for them to be released as a new version.)EP(

  )0 P(Sometimes, however, you may have no choice. For example, upstream is
  inactive or has no plans to release a new version with your fixes any time
  soon. Or you may want to add support for a platform/compiler that upstream
  is not willing or capable of supporting.)EP(

  )0 P(Note that even if you do fix some issues in the )SM(build2)ES(
  package directly, try hard to also incorporate them upstream so that you
  don't need to maintain the patches forever.)EP(

  )0 P(See also )0 87 1 A(Avoid changing upstream source
  code layout)87 0 TN TL()Ec /AF f D( and )0 93 1 A(How do I patch
  upstream source code?)93 0 TN TL()Ec /AF f D()EP(

  )0 2 85 H(3.3)WB 208 Sn()WB 87 Sn( Avoid changing upstream source code
  layout)EH(

  )0 P(It's a good idea to stay as close to the upstream's source code layout as
  possible. For background and rationale, see )0 14 1 A(Decide on the package source code
  layout)14 0 TN TL()Ec /AF f D(.)EP(

  )0 2 86 H(3.4)WB 209 Sn()WB 88 Sn( Don't make library header-only if it can be
  compiled)EH(

  )0 P(Some libraries offer two alternative modes: header-only and compiled.
  Unless there are good reasons not to, a )SM(build2)ES( build of such a
  library should use the compiled mode.)EP(

  )BR(
  )0 P(Some libraries use the )I(precompiled)ES( term to describe the
  non-header-only mode. We don't recommend using this term in the
  )SM(build2)ES( package since it has a strong association with
  precompiled headers and can therefore be confusing. Instead, use the
  )I(compiled)ES( term.)EP(
  )BR(

  )0 P(The main rationale here is that a library would not be offering a
  compiled mode if there were no benefits \201usually faster compile times of
  library consumers\202 and there is no reason not to take advantage of it in the
  )SM(build2)ES( package.)EP(

  )0 P(There are, however, valid reasons why a compiled mode cannot be used, the
  most common of which are:)EP(

  )UL(  )-1 LI(The compiled mode is not well maintained/tested by upstream and
  therefore offers inferior user experience.

  )-1 LI(The compiled mode does not work on some platforms, usually Windows due
  to the lack of symbol export support \201but see )0 2 A(Automatic
  DLL Symbol Exporting)EA(\202.

  )-1 LI(Uses of the compiled version of the library requires changes to the
  library consumers, for example, inclusion of different headers.
  )LU(

  )0 P(If a compiled mode cannot always be used, then it may be tempting to
  support both modes by making the mode user-configurable. Unless there are
  strong reasons to, you should resist this temptation and, if the compiled
  mode is not universally usable, then use the header-only mode
  everywhere.)EP(

  )0 P(The main rationale here is that variability adds complexity which makes
  the result more prone to bugs, more difficult to use, and harder to review
  and maintain. If you really want to have the compiled mode, then the right
  way to achieve it is to work with upstream to fix any issues that prevent
  its use in )SM(build2)ES(.)EP(

  )0 P(There are, however, valid reasons why supporting both modes may be
  needed, the most common of which are:)EP(

  )UL(  )-1 LI(The library is widely used in both modes but switching from one mode to
  the other requires changes to the library consumers \201for example, inclusion
  of different headers\202. In this case only supporting one mode would mean not
  supporting a large number of library consumers.

  )-1 LI(The library consists of a large number of independent components while
  its common for applications to only use a small subset of them. And
  compiling all of them in the compiled mode takes a substantial amount of
  time.  Note that this can alternatively be addressed by making the presence
  of optional components user-configurable.
  )LU(

  )0 2 87 H(3.5)WB 210 Sn()WB 89 Sn( Don't bundle dependencies)EH(

  )0 P(Sometimes third-party projects bundle their dependencies with their
  source code \201also called vendoring\202. For example, a C++ library may bundle a
  testing framework. This is especially common with )R20 2 A()SM(catch2)ES()EA( where one often
  encounters a comical situation with only a few kilobytes of library source
  code and over 600KB of )SM(catch2.hpp)ES(.)EP(

  )0 P(The extra size, while wasteful, is not the main issue, however. The
  bigger problem is that if a bug is fixed in the bundled dependency, then to
  propagate the fix we will need to release a new version \201or revision\202 of
  each package that bundles it. Needless to say this is not scalable.)EP(

  )0 P(While this doesn't apply to testing frameworks, an even bigger issue with
  bundling of dependencies in general is that two libraries that bundle the
  same dependency \201potentially of different versions\202 may not be able to
  coexist in the same build with the symptoms ranging from compile errors to
  subtle runtime issues that are hard to diagnose.)EP(

  )0 P(As a result, it is strongly recommended that you unbundle any
  dependencies that upstream may have bundled. In case of testing frameworks,
  see )R12 2 A(How
  do I handle tests that have extra dependencies?)EA( for the recommended way
  to deal with such cases.)EP(

  )BR(
  )0 P(One special case where a bundled dependency may be warranted is a small
  utility that is completely inline/private to the implementation and where
  making it an external dependency may lead to a less performant result \201due
  to the inability to inline without resorting to LTO\202. The
  )SM(xxhash)ES( implementation in )SM(libzstd)ES( is a
  representative example of this situation.)EP(
  )BR(

  )0 2 88 H(3.6)WB 211 Sn()WB 90 Sn( Don't build your main targets
  in the root )SM(buildfile)ES()EH(

  )0 P(It may be tempting to have your main targets \201libraries, executables\202 in
  the root )SM(buildfile)ES(, especially if it allows you to symlink
  entire directories from )SM(upstream/)ES( \201which is not possible if you
  have to have a )SM(buildfile)ES( inside\202. However, this is not
  recommended except for the simplest of projects.)EP(

  )0 P(Firstly, this quickly gets messy since you have to combine managing
  )SM(README)ES(, )SM(LICENSE)ES(, etc., and subdirectories with
  your main target builds. More importantly, this also means that when your
  main target is imported \201and thus the )SM(buildfile)ES( that defines
  this target must be loaded\202, your entire project will be loaded, including
  any )SM(tests/)ES( and )SM(examples/)ES( subprojects, and that is
  wasteful.)EP(

  )0 P(If you want to continue symlinking entire directories from
  )SM(upstream/)ES( but without moving everything to the root
  )SM(buildfile)ES(, the recommended approach is to simply add another
  subdirectory level. Let's look at a few concrete example to illustrate the
  technique \201see )0 14 1 A(Decide on the package source
  code layout)14 0 TN TL()Ec /AF f D( for background on the terminology used\202.)EP(

  )0 P(Here is the directory structure of a package which uses a combined layout
  \201no header/source split\202 and where the library target is in the root
  )SM(buildfile)ES(:)EP(

  ) 4 61 PR(libigl-core/
|-- igl/ -> ../upstream/igl/
|-- tests/
\267-- buildfile                        # Defines lib{igl-core}.)RP(

  )0 P(And here is the alternative structure where we have added the extra
  )SM(libigl-core)ES( subdirectory with its own
  )SM(buildfile)ES(:)EP(

  ) 6 63 PR(libigl-core/
|-- libigl-core/
|\302\240\302\240 |-- igl/ -> ../../upstream/igl/
|\302\240\302\240 \267-- buildfile                    # Defines lib{igl-core}.
|-- tests/
\267-- buildfile)RP(

  )0 P(Below is the )SM(bdep-new)ES( invocation that can be used to
  automatically create this alternative structure \201see )0 15 1 A(Craft )SM(bdep\240new)ES( command line
  to create package)15 0 TN TL()Ec /AF f D( for background and )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( for
  details\202:)EP(

  ) 3 63 PR($ bdep new \200
 --type lib,prefix=libigl-core,subdir=igl,buildfile-in-prefix \200
 libigl-core)RP(

  )0 P(Let's also look at an example of the split layout, which may require a
  slightly different )SM(bdep-new)ES( sub-options to achieve the same
  result. Here is the layout which matched upstream exactly:)EP(

  ) 10 62 PR($ bdep new --type lib,split,subdir=foo,no-subdir-source libfoo
$ tree libfoo
libfoo/
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     |-- buildfile
|\302\240\302\240     \267-- ...
\267-- src/
    |-- buildfile
    \267-- ...)RP(

  )0 P(However, with this layout we will not be able to symlink the entire
  )SM(include/foo/)ES( and )SM(src/)ES( subdirectories because there
  are )SM(buildfiles)ES( inside \201and which may tempt you to just move
  everything to the root )SM(buildfile)ES(\202. To fix this we can move the
  )SM(buildfiles)ES( out of source subdirectory )SM(foo/)ES( and
  into prefixes \201)SM(include/)ES( and )SM(src/)ES(\202 using the
  )SM(buildfile-in-prefix)ES( sub-option. And since )SM(src/)ES(
  doesn't have a source subdirectory, we have to invent one:)EP(

  ) 9 65 PR($ bdep new --type lib,split,subdir=foo,buildfile-in-prefix libfoo
$ tree libfoo
libfoo/
|-- include/
|\302\240\302\240 |-- foo/ -> ../../upstream/include/foo/
|\302\240\302\240 \267-- buildfile
\267-- src/
    |-- foo/ -> ../../upstream/src/
    \267-- buildfile)RP(

  )0 2 89 H(3.7)WB 212 Sn()WB 91 Sn( Don't make extensive changes in a
  revision)EH(

  )0 P(Unlike a new version, a revision replaces the previous revision of the
  same version and as a result must be strictly backwards-compatible in all
  aspects with what it replaces. If you make extensive changes in a revision,
  it becomes difficult to guarantee that this requirement is satisfied. As a
  result, you should refrain from making major changes, like substantially
  altering the build, in a revision, instead delaying such changes until the
  next version.)EP(

  )0 P(The recommendation is to limit revision changes to bug fixes and
  preferably only in the package "infrastructure" \201)SM(buildfiles)ES(,
  )SM(manifest)ES(, etc\202. Fixes to upstream source code should be limited
  to critical bugs and be preferably backported from upstream. To put it
  another way, changes in a revision should have an even more limited scope
  than a patch release.)EP(

  )0 1 90 H(4)WB 213 Sn()WB 92 Sn( Packaging HOWTO)EH(

  )0 P(This chapter provides advice on how to handle less common packaging tasks
  and requirements.)EP(

  )0 2 91 H(4.1)WB 214 Sn()WB 93 Sn( How do I patch upstream source
  code?)EH(

  )0 P(If you need to change something in the upstream source code, there are
  several options: You can make a copy of the upstream source file and make
  the modifications there. While straightforward, this approach has one major
  drawback: you will have to keep re-applying the changes for every subsequent
  version unless and until upstream incorporates your changes. The other two
  options try to work around this drawback.)EP(

  )0 P(The first alternative option is to modify the upstream source code
  automatically during the build, typically using an ad hoc recipe. This
  approach works best when the changes are regular and can be applied
  mechanically with something like the )0 2 A()SM(sed)ES(
  builtin)EA(.)EP(

  )0 P(The second alternative option is to use the C/C++ preprocessor to make
  the necessary changes to the upstream source code during compilation. Unlike
  the first alternative, this approach doesn't have a prescribed way to apply
  it in every situation and often requires some imagination. Note that it also
  has the tendency to quickly get out of hand, at which point it's wise to
  keep it simple and use the first option \201manual modification\202.)EP(

  )0 P(The following sections examine each approach in detail.)EP(

  )0 3 92 H(4.1.1)WB 215 Sn()WB 94 Sn( Modifying upstream source
  code manually)EH(

  )0 P(As an illustration of this approach, let's say we need to patch
  )SM(src/foo.cpp)ES( in our )SM(libfoo)ES( example from the
  previous sections \201see the )0 22 1 A(Fill with upstream
  source code)22 0 TN TL()Ec /AF f D( step for a refresher\202. The recommended sequence of steps is
  as follows:)EP(

  )4 OL(  )-1 LI(Rename the upstream symlink to )SM(.orig)ES(:

  ) 2 25 PR($ cd libfoo/src/
$ mv foo.cpp foo.cpp.orig)RP(

  )-1 LI(Make a deep copy of )SM(.orig)ES(:

  ) 1 28 PR($ cp -H foo.cpp.orig foo.cpp)RP(

  )-1 LI(Make any necessary modifications in the deep copy:

  ) 1 14 PR($ edit foo.cpp)RP(

  )-1 LI(Create a patch for the modifications:

  ) 1 45 PR($ diff -u foo.cpp.orig foo.cpp >foo.cpp.patch)RP(
  )LO(

  )0 P(The presence of the )SM(.orig)ES( and )SM(.patch)ES( files
  makes it clear that the upstream code was modified. They are also useful
  when re-applying the changes to the new version of the upstream source code.
  The recommended sequence of steps for this task is as follows:)EP(

  )4 OL(  )-1 LI(After the )SM(upstream)ES( submodule update \201see the )0 71 1 A(New version: update
  )SM(upstream)ES( submodule)71 0 TN TL()Ec /AF f D( step\202, the )SM(.orig)ES( symlink
  points to the new version of the upstream source file.

  )-1 LI(Overwrite old modified version with a deep copy of new
  )SM(.orig)ES(:

  ) 1 28 PR($ cp -H foo.cpp.orig foo.cpp)RP(

  )-1 LI(Apply old modifications to the new deep copy:

  ) 1 22 PR($ patch <foo.cpp.patch)RP(

  )0 P(If some hunks of the patch could not be applied, manually resolve any
  conflicts.)EP(

  )-1 LI(If in the previous step the patch did not apply cleanly, regenerate it:

  ) 1 45 PR($ diff -u foo.cpp.orig foo.cpp >foo.cpp.patch)RP(
  )LO(

  )0 3 93 H(4.1.2)WB 216 Sn()WB 95 Sn( Modifying upstream source
  code during build)EH(

  )0 P(As an illustration of this approach, let's say upstream is using the
  )SM(${VAR})ES( style variable substitutions in their
  )SM(config.h.cmake)ES( instead of the more traditional
  )SM(@VAR@)ES( style:)EP(

  ) 3 40 PR(/* config.h.cmake */

#define FOO_VERSION "${PROJECT_VERSION}")RP(

  )0 P(The )SM(${VAR})ES( style is not supported by the )SM(build2)ES(
  )R27 2 A()SM(autoconf)ES()EA(
  module which means we cannot use the upstream )SM(config.h.cmake)ES( as
  is. While we could patch this file manually to use )SM(@VAR@)ES(
  instead, this is a pretty mechanical change that can be easily made with a
  simple ad hoc recipe during the build, freeing us from manually applying the
  same changes in subsequent versions. For example:)EP(

  ) 12 51 PR(using autoconf

h{config}: in{config.h.in}
{
  autoconf.flavor = cmake
  PROJECT_VERSION = $version
}

in{config.h.in}: file{config.h.cmake}
{{
  sed -e 's/\200$\200{\201.+\202\200}/@\2001@/g' $path\201$<\202 >$path\201$>\202
}})RP(

  )0 3 94 H(4.1.3)WB 217 Sn()WB 96 Sn( Modifying upstream source
  code with C/C++ preprocessor)EH(

  )0 P(A good illustration of this approach is adding the )SM(build2)ES(
  metadata to an executable \201see )R26 2 A(How
  do I convey additional information \201metadata\202 with executables and C/C++
  libraries?)EA( for background\202. Let's say we have a symlink to upstream's
  )SM(main.c)ES( that implements the executable's )SM(main\201\202)ES(
  function and we need to add a snipped of code at the beginning of this
  function that handles the )SM(--build2-metadata)ES( option. While
  manually modifying )SM(main.c)ES( is not a wrong approach, we can try
  to be clever and do it automatically with the preprocessor.)EP(

  )0 P(Specifically, we can create another file next to the )SM(main.c)ES(
  symlink, calling it, for example, )SM(main-build2.c)ES(, with the
  following contents:)EP(

  ) 22 68 PR(/* Handle --build2-metadata in main\201\202 \201see also buildfile\202. */

#define main xmain
#include "main.c"
#undef main

#include <stdio.h>
#include <string.h>

int main \201int argc, const char** argv\202
{
  if \201argc == 2 && strncmp \201argv[1], "--build2-metadata=", 18\202 == 0\202
  {
    printf \201"# build2 buildfile foo\200n"\202;
    printf \201"export.metadata = 1 foo\200n"\202;
    printf \201"foo.name = [string] foo\200n"\202;
    ...
    return 0;
  }

  return xmain \201argc, argv\202;
})RP(

  )0 P(The idea here is to rename the original )SM(main\201\202)ES( with the help
  of the C preprocessor and provide our own )SM(main\201\202)ES( which, after
  handling )SM(--build2-metadata)ES( calls the original. One notable
  deal-breaker for this approach would be a C++ implementation of
  )SM(main\201\202)ES( that doesn't have the explicit )SM(return)ES(.
  There is also a better chance in C++ for the )SM(main)ES( macro to
  replace something unintended.)EP(

  )0 P(To complete this we also need to modify our )SM(buildfile)ES( to
  exclude )SM(main.c)ES( from compilation \201since it is compiled as part
  of )SM(main-build2.c)ES( via the preprocessor inclusion\202. For
  example:)EP(

  ) 2 64 PR(exe{foo}: {h c}{** -main}
exe{foo}: c{main}: include = adhoc  # Included in main-build2.c.)RP(

  )0 2 95 H(4.2)WB 218 Sn()WB 97 Sn( How do I deal with bad header
  inclusion practice?)EH(

  )0 P(This section explains how to deal with libraries that include their
  public, generically-named headers without the library name as a subdirectory
  prefix. Such libraries cannot coexist, neither in the same build nor when
  installed.)EP(

  )0 P(Specifically, as an illustration of the problem, consider the
  )SM(libfoo)ES( library with a public header named )SM(util.h)ES(
  that is included as )SM(<util.h>)ES( \201instead of, say,
  )SM(<libfoo/util.h>)ES( or )SM(<foo/util.h>)ES(\202. If this
  library's headers are installed directly into, say,
  )SM(/usr/include)ES(, then if two such libraries happened to be
  installed at the same time, then one will overwrite the other's header.
  There are also problems in the non-installed case: if two such libraries are
  used by the same project, then which )SM(<util.h>)ES( header gets
  included depends on which library's header search path ends up being
  specified first on the command line \201with the )SM(-I)ES( option\202.)EP(

  )0 P(These issues are severe enough that libraries with such inclusion issues
  cannot be published to )R1 2 A(cppget.org)EA( without
  them being addressed in the )SM(build2)ES( package. Thankfully, most
  library authors these days use the library name as an inclusion prefix \201or
  sometimes they have headers that are decorated with the library name\202.
  However, libraries that do not follow these guidelines do exist and this
  section describes how to change their inclusion scheme if you are attempting
  to package one of them.)EP(

  )BR(
  )0 P(One notable consequence of changing the inclusion scheme is that it will
  no longer be possible to use a system-installed version of the package
  \201because it presumably still uses the unqualified inclusion scheme\202. Note,
  however, that distributions like Debian and Fedora have the same
  co-existence issue as we do and are generally strict about potential header
  clashes. In particular, it is not uncommon to find Debian packages
  installing library headers into subdirectories of )SM(/usr/include)ES(
  to avoid such clashes. And if you find this to be the case for the library
  you are packaging, then it may make sense to use the same prefix as used by
  the main distributions for compatibility.)EP(

  )0 P(It is also possible that distributions disregard these considerations for
  some libraries. This usually happens for older, well-known libraries that
  happened to be installed this way in the early days and changing things now
  will be too disruptive. In a sense, it is understood that such libraries
  effectively "own" the unqualified header names that they happen to be using.
  If you think you are packaging such a library, )R10 2 A(get in touch)EA( to discuss
  this further since it may make sense to also disregard this rule in )R1 2 A(cppget.org)EA(.)EP(
  )BR(

  )0 P(As a concrete example of the approach, let's continue with
  )SM(libfoo)ES( that has )SM(util.h)ES( and which upstream expects
  the users to include as )SM(<util.h>)ES(. The is what the upstream
  source code layout may look like:)EP(

  ) 5 16 PR(libfoo/
|-- include/
|\302\240\302\240 \267-- util.h
\267-- src/
    \267-- ...)RP(

  )0 P(Our plan is to change the inclusion scheme in the )SM(build2)ES(
  package from )SM(<util.h>)ES( to )SM(<libfoo/util.h>)ES(. To
  this effect, we use a slightly modified layout for our package \201see )0 15 1 A(Craft )SM(bdep new)ES( command line to
  create package)15 0 TN TL()Ec /AF f D( on how to achieve it\202:)EP(

  ) 6 57 PR(libfoo/
|-- include/
|\302\240\302\240 \267-- libfoo/
|\302\240\302\240     \267-- util.h  -> ../../../upstream/include/util.h
\267-- src/
    \267-- ...          -> ../../upstream/src/...)RP(

  )0 P(The installation-related section in our )0 26 1 A(header )SM(buildfile)ES()26 0 TN TL()Ec /AF f D( will
  look like this:)EP(

  ) 8 62 PR(# Install into the libfoo/ subdirectory of, say, /usr/include/
# recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/libfoo/
  install.subdirs = true
})RP(

  )0 P(In the )0 27 1 A(source
  )SM(buildfile)ES()27 0 TN TL()Ec /AF f D( we will most likely need to add the
  )SM(include/libfoo)ES( header search path since the upstream source
  files continue to include public headers without the library prefix \201there
  should be no harm in that and it's not worth modifying them\202:)EP(

  ) 15 57 PR(# Build options.
#
out_pfx_inc = [dir_path] $out_root/include/
src_pfx_inc = [dir_path] $src_root/include/
out_pfx_src = [dir_path] $out_root/src/
src_pfx_src = [dir_path] $src_root/src/

# Unqualified \201without <libfoo/...>\202 header search paths.
#
out_pfx_inc_unq = [dir_path] $out_root/include/libfoo
src_pfx_inc_unq = [dir_path] $src_root/include/libfoo

cxx.poptions =+ "-I$out_pfx_src" "-I$src_pfx_src" \200
                "-I$out_pfx_inc" "-I$src_pfx_inc" \200
                "-I$out_pfx_inc_unq" "-I$src_pfx_inc_unq")RP(

  )0 P(It is also possible that public headers include each other as
  )SM(<util.h>)ES( rather than the more common )SM("util.h")ES(.
  If that's the case, then we need to fix that and there are two ways to do
  it. The first approach is to patch the public headers to include each other
  with the library prefix \201that is, )SM(<libfoo/util.h>)ES(, etc\202. See
  )0 93 1 A(How do I patch upstream source
  code?)93 0 TN TL()Ec /AF f D( for details.)EP(

  )0 P(The second approach is to support including public headers both ways,
  that is, as )SM(<libfoo/util.h>)ES( and as )SM(<util.h>)ES(.
  This will not only solve the above problem \201public headers including each
  other\202, but also support any existing code that uses this library and most
  likely includes its headers the old way, without the prefix.)EP(

  )0 P(There is, however, a major drawback to doing that: while the installation
  of the library can now co-exist with other libraries \201because we install its
  public headers into, say, )SM(/usr/include/libfoo)ES(\202, it may still
  not be usable in combination with other libraries from the same build
  \201because we still add the unqualified header search path\202.)EP(

  )0 P(If you still want to provide this dual inclusion support, the way to
  achieve it is by exporting the unqualified header search path and also
  adding it to the )SM(pkg-config)ES( files \201see )0 98 1 A(How do I handle extra header
  installation subdirectory?)98 0 TN TL()Ec /AF f D( for background on the latter\202. For
  example:)EP(

  ) 14 65 PR(# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$out_pfx_inc" "-I$src_pfx_inc" \200
                        "-I$out_pfx_inc_unq" "-I$src_pfx_inc_unq"
  cxx.export.libs = $intf_libs
}

# Make sure headers installed into, say, /usr/include/libfoo/
# can also be included without the directory prefix for backwards
# compatibility.
#
lib{foo}: cxx.pkgconfig.include = include/ include/libfoo/)RP(

  )0 2 96 H(4.3)WB 219 Sn()WB 98 Sn( How do I handle extra header
  installation subdirectory?)EH(

  )0 P(This section explains how to handle an additional header installation
  subdirectory. As an illustration of the problem, consider the
  )SM(libfoo)ES( example from the previous sections \201see the )0 22 1 A(Fill with upstream source code)22 0 TN TL()Ec /AF f D( step for a
  refresher\202. In that example the library headers are included as
  )SM(<foo/util.hpp>)ES( and installed as, say,
  )SM(/usr/include/foo/util.hpp)ES(. In this scheme the installed header
  inclusion works without requiring any extra steps from our side because the
  compiler searches for header in )SM(/usr/include)ES( by default.)EP(

  )0 P(However, some libraries choose to install their headers into a
  subdirectory of, say, )SM(/usr/include)ES( but without having this
  subdirectory as part of the inclusion path \201)SM(foo/)ES( in
  )SM(<foo/util.hpp>)ES(\202. The two typical reasons for this are
  support for installing multiple versions of the same library side-by-side
  \201for example, )SM(/usr/include/foo-v1/foo/util.hpp)ES(\202 as well as not
  using the library name as the inclusion subdirectory prefix and then having
  to hide the headers in a subdirectory due to potential clashes with other
  headers \201if installed directly into, say, )SM(/usr/include)ES(; see )0 97 1 A(How do I deal with bad header inclusion
  practice?)97 0 TN TL()Ec /AF f D( for background\202.)EP(

  )0 P(In such cases the installed header inclusion does not work out of the box
  and we have to arrange for an additional header search path to be added via
  )SM(pkg-config)ES(. Let's use the versioned library case to illustrate
  this technique. The relevant part from the )0 26 1 A(header )SM(buildfile)ES()26 0 TN TL()Ec /AF f D( will
  look like this:)EP(

  ) 8 66 PR(# Install into the foo-vN/foo/ subdirectory of, say, /usr/include/
# recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/"foo-v$version.major"/foo/
  install.subdirs = true
})RP(

  )0 P(The part that we need to add, this time to the )0 27 1 A(source )SM(buildfile)ES()27 0 TN TL()Ec /AF f D(,
  looks like this:)EP(

  ) 5 65 PR(# Make sure headers installed into, say, /usr/include/foo-vN/foo/
# can be included as <foo/*.hpp> by overriding the header search
# path in the generated pkg-config files.
#
lib{foo}: cxx.pkgconfig.include = include/"foo-v$version.major"/)RP(

  )BR(
  )0 P(The variable will be )SM(c.pkgconfig.include)ES( for a C
  library.)EP(
  )BR(

  )0 2 97 H(4.4)WB 220 Sn()WB 99 Sn( How do I handle headers without an
  extension?)EH(

  )0 P(If all the headers in a project have no extension, then you can simply
  specify the empty )SM(extension)ES( value for the )SM(hxx{})ES(
  target type in )SM(build/root.build)ES(:)EP(

  ) 2 23 PR(hxx{*}: extension =
cxx{*}: extension = cpp)RP(

  )0 P(Note, however, that using wildcard patterns for such headers in your
  )SM(buildfile)ES( is a bad idea since such a wildcard will most likely
  pick up other files that also have no extension \201such as
  )SM(buildfile)ES(, executables on UNIX-like systems, etc\202. Instead,
  it's best to spell the names of such headers explicitly. For example,
  instead of:)EP(

  ) 1 24 PR(lib{hello}: {hxx cxx}{*})RP(

  )0 P(Write:)EP(

  ) 1 29 PR(lib{hello}: cxx{*} hxx{hello})RP(

  )0 P(If only some headers in a project have no extension, then it's best to
  specify the non-empty extension for the )SM(extension)ES( variable in
  )SM(build/root.build)ES( \201so that you can still use wildcards for
  headers with extensions\202 and spell out the headers with no extension
  explicitly. Continuing with the above example, if we have both the
  )SM(hello.hpp)ES( and )SM(hello)ES( headers, then we can handle
  them like this:)EP(

  ) 2 23 PR(hxx{*}: extension = hpp
cxx{*}: extension = cpp)RP(

  ) 1 36 PR(lib{hello}: {hxx cxx}{*} hxx{hello.})RP(

  )0 P(Notice the trailing dot in )SM(hxx{hello.})ES( \235 this is the
  explicit "no extension" specification. See )0 2 A(Targets and
  Target Types)EA( for details.)EP(

  )0 2 98 H(4.5)WB 221 Sn()WB 100 Sn( How do I expose extra debug macros of a
  library?)EH(

  )0 P(Sometimes libraries provide extra debugging facilities that are usually
  enabled or disabled with a macro. For example, )SM(libfoo)ES( may
  provide the )SM(LIBFOO_DEBUG)ES( macro that enables additional sanity
  checks, tracing, etc. Normally, such facilities are disabled by default.)EP(

  )0 P(While it may seem like a good idea to detect a debug build and enable
  this automatically, it is not: such facilities usually impose substantial
  overheads and the presence of debug information does not mean that
  performance is not important \201people routinely make optimized builds with
  debug information\202.)EP(

  )0 P(As a result, the recommended approach is to expose this as a
  configuration variable that the consumers of the library can use \201see )0 2 A(Project
  Configuration)EA( for background\202. Continue with the )SM(libfoo)ES(
  example, we can add )SM(config.libfoo.debug)ES( to its
  )SM(build/root.build)ES(:)EP(

  ) 3 42 PR(# build/root.build

config [bool] config.libfoo.debug ?= false)RP(

  )0 P(And then define the )SM(LIBFOO_DEBUG)ES( macro based on that in the
  )SM(buildfile)ES(:)EP(

  ) 4 32 PR(# src/buildfile

if $config.libfoo.debug
  cxx.poptions += -DLIBFOO_DEBUG)RP(

  )0 P(If the macro is also used in the library's interface \201for example, in
  inline or template functions\202, then we will also need to export it \201see )0 32 1 A(Adjust source
  )SM(buildfile)ES(: build and export options)32 0 TN TL()Ec /AF f D( for details\202:)EP(

  ) 7 49 PR(# src/buildfile

if $config.libfoo.debug
{
  cxx.poptions += -DLIBFOO_DEBUG
  lib{foo}: cxx.export.poptions += -DLIBFOO_DEBUG
})RP(

  )BR(
  )0 P(If the debug facility in question should be enabled by default even in
  the optimized builds \201in which case the macro usually has the
  )SM(NO_DEBUG)ES( semantics\202, the other option is to hook it up to the
  standard )SM(NDEBUG)ES( macro, for example, in the library's
  configuration header file.)EP(
  )BR(

  )0 P(Note that such )SM(.debug)ES( configuration variables should
  primarily be meant for the user to selectively enable extra debugging
  support in certain libraries of their build. However, if your project
  depends on a number of libraries with such extra debugging support and it
  generally makes sense to also enable this support in dependencies if it is
  enabled in your project, then you may want to propagate your
  )SM(.debug)ES( configuration value to the dependencies \201see the )0 2 A()SM(depends)ES(
  package )SM(manifest)ES( value)EA( for details on dependency
  configuration\202. You, however, should still allow the user to override this
  decision on the per-dependency basis.)EP(

  )0 P(Continuing with the above example, let's say we have )SM(libbar)ES(
  with )SM(config.libbar.debug)ES( that depends on )SM(libfoo)ES(
  and wishes by default to enable debugging in )SM(libfoo)ES( if it is
  enabled in )SM(libbar)ES(. This is how we can correctly arrange for
  this in )SM(libbar)ES('s )SM(manifest)ES(:)EP(

  ) 16 60 PR(depends:
\200
libfoo ^1.2.3
{
  # We prefer to enable debug in libfoo if enabled in libbar
  # but accept if it's disabled \201for example, by the user\202.
  #
  prefer
  {
    if $config.libbar.debug
      config.libfoo.debug = true
  }

  accept \201true\202
}
\200)RP(

  )0 2 99 H(4.6)WB 222 Sn()WB 101 Sn( How do I deal with tests that don't
  terminate?)EH(

  )0 P(If upstream tests don't terminate in a reasonable time \201or at all\202, then
  your CI jobs will be failing with timeouts.)EP(

  )BR(
  )0 P(Naturally, we cannot afford tests to run indefinitely or unreasonably
  long on our CI infrastructure and, as a result, we impose a timeout on tests
  execution. Currently it is 25 minutes.)EP(
  )BR(

  )0 P(If you find yourself in this situation, the first step is to examine such
  tests for a mechanism, typically a command line option, that allows you to
  set a limit on test execution, such as a time limit, number of test
  iterations, etc.)EP(

  )0 P(If there is an option, then we can pass it with )SM(test.options)ES(
  \201see )0 2 A(Testing)EA(
  for background\202:)EP(

  ) 1 44 PR(exe{driver}: test.options = --iterations 100)RP(

  )0 P(If, however, there is no mechanism for limiting upstream test execution,
  then the last resort is to set a test execution timeout that is treated as
  success. For details on how to achieve this see )R34 2 A(How
  do I sanitize the execution of my tests?)EA()EP(

  )0 2 100 H(4.7)WB 223 Sn()WB 102 Sn( How do I deal with compiler/linker running out
  of RAM?)EH(

  )0 P(If a third-party project contains very large/complex translation units or
  is linking a large number of object files, then the compiler or linker may
  run out of memory, especially if compilation/linking is performed in
  parallel with other compilation/linking jobs. For compilation, this is
  normally triggered when compiling with optimization enabled. For example, on
  Linux with GCC this could manifest in an error like this:)EP(

  ) 1 69 PR(Out of memory: Killed process 1857 \201cc1plus\202 ... pgtables:13572kB ...)RP(

  )0 P(The recommended way to deal with such issues is to serialize the
  compilation or linking of the targets in question. Specifically, both the
  C/C++ compile and link rules recognize the )SM(cc.serialize)ES( boolean
  variable which instructs them to compile/link serially \201as opposed to in
  parallel\202 with regards to any other recipe. For example:)EP(

  ) 2 36 PR(obj{memory-hog}: cc.serialize = true
exe{very-large}: cc.serialize = true)RP(

  )0 P(To identify which source files require a large amount of RAM, build
  serially \201)SM(-s)ES(\202 with optimization enabled while watching the
  amount of RAM used by the compiler. Similarly, for linking binaries, watch
  the amount of RAM used by the linker.)EP(

  )0 1 101 H(5)WB 224 Sn()WB 103 Sn( Packaging FAQ)EH(

  )0 2 102 H(5.1)WB 225 Sn()WB 104 Sn( Publishing FAQ)EH(

  )0 3 103 H(5.1.1)WB 226 Sn()WB 105 Sn( Why is my package in )SM(alpha)ES(
  rather than )SM(stable)ES(?)EH(

  )0 P(If your package uses a semver version \201or semver-like, that is, has three
  version components\202 and the first component is zero \201for example,
  )SM(0.1.0)ES(\202, then, according to the semver specification, this is an
  alpha version and )0 2 A()SM()BD(bdep-publish\2011\202)ES()ES()EA(
  automatically published such a version to the )SM(alpha)ES( section of
  the repository.)EP(

  )0 P(Sometimes, however, in a third-party package, while the version may look
  like semver, upstream may not assign the zero first component any special
  meaning. In such cases you can override the )SM(bdep-publish)ES(
  behavior with the )SM(--section)ES( option, for example:)EP(

  ) 1 31 PR($ bdep publish --section=stable)RP(

  )0 P(Note that you should only do this if you are satisfied that by having the
  zero first component upstream does not imply alpha quality. Getting an
  explicit statement to this effect from upstream is recommended.)EP(

  )0 3 104 H(5.1.2)WB 227 Sn()WB 106 Sn( Where to publish if package requires staged
  toolchain?)EH(

  )0 P(If your package requires the )R48 2 A(staged toolchain)EA(, for
  example, because it needs a feature or bugfix that is not yet available in
  the released toolchain, then you won't be able to publish it to
  )SM(cppget.org)ES(. Specifically, if your package has the accurate
  )SM(build2)ES( version constraint and you attempt to publish it, you
  will get an error like this:)EP(

  ) 3 72 PR(error: package archive is not valid
  info: unable to satisfy constraint \201build2 >= 0.17.0-\202 for package foo
  info: available build2 version is 0.16.0)RP(

  )0 P(There are three alternative ways to proceed in this situation:)EP(

  )4 OL(  )-1 LI(Wait until the next release and then publish the package to
  )SM(cppget.org)ES(.

  )-1 LI(If the requirement for the staged toolchain is "minor", that is, it
  doesn't affect the common functionality of the package or only affects a
  small subset of platforms/compilers, then you can lower the toolchain
  version requirement and publish the package to )SM(cppget.org)ES(. For
  example, if you require the staged toolchain because of a bugfix that only
  affects one platform, it doesn't make sense to delay publishing the package
  since it is perfectly usable on all the other platforms in the
  meantime.

  )-1 LI(Publish it to )R8 2 A(queue.stage.build2.org)EA(, the
  staging package repository. This repository contain new packages that
  require the staged toolchain to work and which will be automatically moved
  to )SM(cppget.org)ES( once the staged version is released. The other
  advantage of publishing to this repository \201besides not having to remember
  to manually publish the package once the staged version is released\202 is that
  your package becomes available from an archive repository, which is
  substantially faster than a )SM(git)ES( repository.

  )0 P(To publish to this repository, use the following
  )SM(bdep-publish)ES( command line:)EP(

  ) 1 56 PR($ bdep publish --repository=https://stage.build2.org ...)RP(
  )LO(

  )0 3 105 H(5.1.3)WB 228 Sn()WB 107 Sn( Why "project owner authentication failed"
  while publishing?)EH(

  )0 P(If you are getting the following error while attempting to publish a new
  version of a package:)EP(

  ) 3 42 PR($ bdep publish
...
error: project owner authentication failed)RP(

  )0 P(Then this means the remote )SM(git)ES( repository you are using does
  not match the one from which you \201or someone else\202 has published the initial
  version of the package.)EP(

  )0 P(In )SM(build2)ES( we use the ownership of the package
  )SM(git)ES( repository as a proxy for the ownership of the package name
  on )R1 2 A(cppget.org)EA(. Specifically, when you
  publish the package for the first time, we record the )SM(git)ES( URL
  for its package repository. And any further versions of this package can
  only be submitted by someone who has write access to this repository. See )0 2 A()SM()BD(bdep-publish\2011\202)ES()ES()EA(
  for details.)EP(

  )0 P(Based on this background, the first step you need to take when getting
  the above owner authentication error is to understand its cause. For that,
  first use the )SM(git-config)ES( command to see the URL you are using
  locally:)EP(

  ) 1 36 PR($ git config --get remote.origin.url)RP(

  )0 P(Then look in the )R49 2 A()SM(git)ES(
  repositories)EA( that back )R1 2 A(cppget.org)EA( and
  )R7 2 A(queue.cppget.org)EA( and find the URL
  that is recorded in the )SM(owners/)ES( subdirectory in the
  corresponding )SM(package-owner.manifest)ES( file.)EP(

  )0 P(Note that your local URL will normally be SSH while the recorded URL will
  always be HTTPS. Provided that the host names match, the part to look in for
  differences is the path component. One common cause of a mismatch is the
  missing )SM(.git)ES( extension. For example \201local first, recorded
  second\202:)EP(

  ) 2 44 PR(git@github.com:build2-packaging/zstd
https://github.com/build2-packaging/zstd.git)RP(

  )0 P(In this case adding the missing extension to the local URL should fix the
  error.)EP(

  )0 P(If, however, the discrepancy is expected, for example, because you have
  renamed the package repository or moved it to a new location, the ownership
  information will need to be updated manually. In this case feel free to
  submit a pull request with the necessary changes or )R10 2 A(get in touch)EA(.)EP(

  )0 1 106 H(6)WB 229 Sn()WB 108 Sn( Package Review)EH(

  )0 P(Due to the complexity of packaging C/C++ software and to maintain a
  standard of quality, package submissions must be reviewed by someone
  knowledgeable in )SM(build2)ES( and experienced in packaging
  third-party software before they can be deemed stable and moved from the
  )SM(testing)ES( to the )SM(stable)ES( section of the )R1 2 A(cppget.org)EA( repository. This applies to initial
  package submissions, new versions, and new revisions. This chapter describes
  the review process.)EP(

  )0 P(First, let's recap the package transition policies from )R7 2 A(queue.cppget.org)EA( to )R1 2 A(cppget.org)EA( and between the various )R21 2 A(sections of cppget.org)EA(.)EP(

  )0 P(All three types of submissions \201initial, new version, and new revision\202
  are performed with )0 2 A()SM()BD(bdep-publish\2011\202)ES()ES()EA(
  and automatically placed into )R7 2 A(queue.cppget.org)EA( where they are built
  and tested as archive packages in the same set of build configuration as )R1 2 A(cppget.org)EA(.)EP(

  )BR(
  )0 P(Publishing the package into the queue is the only automatic step and all
  other transitions are currently performed manually after review or
  evaluation by a )SM(build2)ES( core team member \201though some steps may
  be automated in the future\202.)EP(
  )BR(

  )0 P(When the package is published to )R7 2 A(queue.cppget.org)EA(, it ends up in one of
  the )R50 2 A(three sections)EA(:
  )SM(alpha)ES(, )SM(beta)ES(, or )SM(testing)ES(. The
  destination section is normally determined automatically by )0 2 A()SM()BD(bdep-publish\2011\202)ES()ES()EA(
  based on the package version: alpha semver versions go to
  )SM(alpha)ES(, beta \235 to )SM(beta)ES(, and the rest \201as well
  as non-semver versions\202 go to )SM(testing)ES(.)EP(

  )0 P(If the package published to )R7 2 A(queue.cppget.org)EA( successfully builds in
  at least one build configuration, then it is migrated to )R1 2 A(cppget.org)EA(. When the package is migrated from
  )R7 2 A(queue.cppget.org)EA(, it is placed into
  the corresponding section of )R1 2 A(cppget.org)EA(,
  that is, a package from the )SM(alpha)ES( section of the former go to
  )SM(alpha)ES( of the latter, )SM(beta)ES( \235 to
  )SM(beta)ES(, and )SM(testing)ES( \235 to
  )SM(testing)ES(.)EP(

  )0 P(If the package was migrated to either the )SM(alpha)ES( or
  )SM(beta)ES( section, then this is its final destination. If, however,
  the package was placed into the )SM(testing)ES( section, then it stays
  there for some time \201at least a week\202 to allow further testing and review by
  any interested users. It is then migrated to the )SM(stable)ES( section
  provided the following conditions are met:)EP(

  )4 OL(  )-1 LI(The package has at least one positive review that was performed by an
  experienced )SM(build2)ES( user.

  )-1 LI(There are no serious issues reported with the package based on further
  testing.
  )LO(

  )0 P(If the package has no reviews, then it will remain in the
  )SM(testing)ES( section until reviewed, potentially indefinitely.
  Likewise, if the package has a negative review that identified blocking
  issues, then they must be addressed by the package author in a revision,
  published to queue, and re-reviewed. Until then the package will remain in
  )SM(testing)ES( but in severe cases \201for example, security
  vulnerability and no forthcoming fix\202, it may also be dropped.)EP(

  )BR(
  )0 P(If the package has both positive and negative reviews, then the
  contradictions will be reconciled by the )SM(build2)ES( core team
  members.)EP(
  )BR(

  )BR(
  )0 P(Packages in the )SM(alpha)ES( and )SM(beta)ES( sections can
  also be reviewed and a negative review may lead to the package being dropped
  in severe cases.)EP(
  )BR(

  )0 P(For completeness, let's also mention the )SM(legacy)ES( section of
  )R1 2 A(cppget.org)EA(. A package that is no longer
  maintained \201either by upstream or by the )SM(build2)ES( project\202 may be
  moved to )SM(legacy)ES( for two primary reasons: to signal to the users
  that it has serious issues \201such as security vulnerabilities\202 and/or not to
  waste CI resources on building it.)EP(

  )0 P(How are the transitions effected, exactly? Both )R7 2 A(queue.cppget.org)EA( and )R1 2 A(cppget.org)EA( package repositories are backed by
  )SM(git)ES( repositories hosted at )R49 2 A(github.com/cppget/)EA(. Each transition
  described above \201including the initial submission by )0 2 A()SM()BD(bdep-publish\2011\202)ES()ES()EA(\202
  is recorded as a commit in one or both of these repositories \201study their
  commit histories to get a sense of how this works\202.)EP(

  )0 P(While all the transitions can be performed manually by moving files
  around and using )SM(git)ES( directly, the )SM(manage)ES( script
  in )R51 2 A()SM(bpkg-util)ES()EA(
  provides a high-level interface for the common transitions.)EP(

  )0 P(Note also that the person doing a review and the person effecting a
  package transition need not be the same. For security, package transitions
  can currently only be performed by the )SM(build2)ES( core team
  members.)EP(

  )0 P(With this background, let's now turn to the review process. At the outset
  you may be wondering why perform it so late in the packaging process when
  the final version has been released and published. Specifically, would it
  not be better to review some form of work-in-progress so that any issues can
  be corrected before releasing the final version?)EP(

  )0 P(There are several reasons why we prefer to review the released version.
  Firstly, we want to base our reviews on the build results of the final
  package archives as they will be published to )R1 2 A(cppget.org)EA(. Basing reviews on anything other
  than that means we will need to re-examine them when the final version is
  submitted.)EP(

  )0 P(The second reason is consideration for the reviewer. Reviewing other
  people's packaging work, often for software you personally have no interest
  in using, is a thankless and often frustrating job \201things tend to get
  frustrating when you have to point out the same basic mistakes over and over
  again\202. As a result, we want to make this job as streamlined as possible
  without \201hopefully\202 multiple rounds of reviews. Also, the finality of the
  submission will hopefully encourage authors to try to submit finished work
  rather than something incomplete, for example, in the hope that the reviewer
  will help them fix it into shape.)EP(

  )0 P(Having said that, nothing prevents members of the )SM(build2)ES(
  community from performing ad hoc pre-reviews, for example, for packaging
  efforts of new authors that require some help and guidance.)EP(

  )BR(
  )0 P(For background, this review process was heavily inspired by the Linux
  kernel development. Specifically, Linux developers review proposed changes
  and mark them with a number of tags, such as )R52 2 A()SM(Reviewed-by)ES()EA(.
  Below is the relevant quote from that document that gives a good description
  for what it means to offer a )SM(Reviewed-by)ES( tag and that matches
  many of the aspects of this review policy:)EP(

  )0 P()BD(Reviewer\342s statement of oversight)ES()EP(

  )0 P(By offering my )SM(Reviewed-by)ES( tag, I state that:)EP(

  )4 OL(  )-1 LI(I have carried out a technical review of this patch to evaluate its
  appropriateness and readiness for inclusion into the mainline kernel.

  )-1 LI(Any problems, concerns, or questions relating to the patch have been
  communicated back to the submitter. I am satisfied with the submitter\342s
  response to my comments.

  )-1 LI(While there may be things that could be improved with this submission, I
  believe that it is, at this time, \2011\202 a worthwhile modification to the
  kernel, and \2012\202 free of known issues which would argue against its
  inclusion.

  )-1 LI(While I have reviewed the patch and believe it to be sound, I do not
  \201unless explicitly stated elsewhere\202 make any warranties or guarantees that
  it will achieve its stated purpose or function properly in any given
  situation.
  )LO(

  )0 P(A )SM(Reviewed-by)ES( tag is a statement of opinion that the patch
  is an appropriate modification of the kernel without any remaining serious
  technical issues. Any interested reviewer \201who has done the work\202 can offer
  a )SM(Reviewed-by)ES( tag for a patch. This tag serves to give credit
  to reviewers and to inform maintainers of the degree of review which has
  been done on the patch. )SM(Reviewed-by)ES( tags, when supplied by
  reviewers known to understand the subject area and to perform thorough
  reviews, will normally increase the likelihood of your patch getting into
  the kernel.)EP(
  )BR(

  )0 P(Before we delve into the review process, let's also discuss how one finds
  packages to review. There are two common strategies: The first is to look at
  the packages that you are using in your own projects and, if there are any
  unreviewed versions that you would like to use, to consider reviewing them.
  Alternatively, if you would like to help the )SM(build2)ES( community
  by reviewing packages, pick any from the unreviewed list. For both cases you
  could use )R53 2 A(Advanced Package
  Search)EA(, limiting the result to specific packages in the first case. For
  example, you could search for )R54 2 A(unreviewed
  packages in the )SM(testing)ES( section)EA(.)EP(

  )0 P(The review process for the three types of submissions \201initial, new
  version, and new revision\202 are described in the following sections.)EP(

  )BR(
  )0 P(At this stage of the )R1 2 A(cppget.org)EA(
  repository evolution, where it primarily contains third-party packages, we
  are only concerned with reviewing the build and packaging support, ignoring
  everything else \201source code, documentation, etc\202. This, however, may change
  in the future.)EP(
  )BR(

  )0 2 107 H(6.1)WB 230 Sn()WB 109 Sn( Reviewing initial package submission)EH(

  )0 P(A review process for an initial package submission is the most elaborate
  since we need to review everything from scratch.)EP(

  )0 3 108 H(6.1.1)WB 231 Sn()WB 110 Sn( Create review issue)EH(

  )0 P(The first step in reviewing the initial package submission is to create a
  review issue on the package repository. The issue title should be in the
  following form \201here and below )SM(X.Y.Z)ES( is the version being
  reviewed\202:)EP(

  ) 1 58 PR(Review of the `X.Y.Z` version \201initial package submission\202)RP(

  )BR(
  )0 P(Before actually creating the issue you may also want to check if someone
  else is already reviewing this package and thus has already created the
  issue. While there is nothing wrong with having multiple reviews, you may
  want to consider picking something else to review in order to increase
  coverage.)EP(
  )BR(

  )0 P(For issue description, copy and paste the contents of )R55 2 A(packaging-initial-review-checklist.md)EA(.)EP(

  )0 P(Then create the issue.)EP(

  )0 3 109 H(6.1.2)WB 232 Sn()WB 111 Sn( Create review pull request)EH(

  )0 P(The only place where GitHub supports code reviews is a pull request \201PR\202.
  As a result, we create a dummy draft pull request against the
  )SM(master)ES(/)SM(main)ES( branch whose only purpose is to serve
  as a code review vehicle. The procedure is as follows:)EP(

  )4 OL(  )-1 LI(Clone the package repository \201referred to as )SM(<repo>)ES(\202
  locally:

  ) 2 94 PR(git clone --recurse-submodules --shallow-submodules git@github.com:build2-packaging/<repo>.git
cd <repo>)RP(

  )-1 LI(Find the first commit:

  ) 1 28 PR(git rev-list --all | tail -1)RP(

  )0 P(Make sure it is the canonical )SM(Initialize package repository)ES(
  commit from the )0 10 1 A(Initialize package repository with
  )SM(bdep\240new)ES()10 0 TN TL()Ec /AF f D( step:)EP(

  ) 1 44 PR(git log -p "$\201git rev-list --all | tail -1\202")RP(

  )BR(
  )0 P(The changes made in this commit will not be part of the review so we need
  to make sure nothing was lumped into it beside the project infrastructure
  created by )SM(bdep-new)ES(. We have to skip this commit because the
  two branches we will be creating the pull request from \201see below\202 must have
  common history.)EP(
  )BR(

  )-1 LI(Create the review branch:

  ) 2 57 PR(git branch review-X.Y.Z "$\201git rev-list --all | tail -1\202"
git push origin review-X.Y.Z)RP(

  )-1 LI(Create pull request:

  )4 OL(  )-1 LI(Open the GitHub link printed by the above
  )SM(git-push)ES( command.

  )-1 LI(Change )SM(base:)ES( branch to
  )SM(review-X.Y.Z)ES(, )SM(compare:)ES( branch to
  )SM(master)ES(/)SM(main)ES(.

  )-1 LI(For PR title use:

  ) 1 66 PR(Dummy draft pull request for version `X.Y.Z` review \201do not merge\202)RP(

  )-1 LI(In PR description link to the review issue
  \201)SM(<N>)ES( is the review issue number\202:

  ) 1 22 PR(See review issue #<N>.)RP(

  )-1 LI(Change the creation mode to )SM(Create draft
  pull request)ES( and create the PR.
  )LO(
  )LO(

  )BR(
  )0 P(The review pull request is setup as if we wanted to merge the
  )SM(master)ES(/)SM(main)ES( branch into )SM(review-X.Y.Z)ES(,
  which generally doesn't make much sense \201and is the reason why this PR
  should never be merged\202. However, this setup allows us to do code reviews of
  all the changes since the first commit. What's more, if the package author
  addresses some issues by releasing revisions, the revision commits will be
  automatically added to this PR and their changes available to further
  review.)EP(
  )BR(

  )0 3 110 H(6.1.3)WB 233 Sn()WB 112 Sn( Go through review checklist)EH(

  )0 P(Go through the review checklist in the review issue ticking off
  successfully completed items.)EP(

  )0 P(While reviewing an item you may identify an issue or have something to
  note. A note is a general observation that is worth mentioning to the
  package author. For example, while checking this item:)EP(

  ) 1 67 PR([ ] If library without lib prefix, no clashes with executable names)RP(

  )0 P(You may note that while there are no clashes with executables installed
  in )SM(PATH)ES( locations, there is a package in Debian that has a
  private executable named like this. So you may make a note along these
  lines:)EP(

  ) 5 71 PR(There is a file in Debian named ftest. It's not an executable installed
in a PATH location so I guess having this library named without the
lib prefix is technically allowed, though not ideal. Consider in the
future to follow the recommendation in the packaging guide and name
libraries with the lib prefix to sidestep such considerations.)RP(

  )0 P(An issue can be blocking or non-blocking. As the name suggests, a
  blocking issue fails the review and must be addressed in a revision. A
  non-blocking issue does not fail the review and can be optionally addressed
  in a revision or in the next version.)EP(

  )0 P(Whether an issue is blocking or not is a judgment call of the reviewer
  \201which is one of the reasons why a reviewer needs to be knowledgeable in
  )SM(build2)ES( and have experience packaging third-party projects\202. The
  overall guideline is to consider two dimensions: severity and impact. An
  issue that would prevent a large proportion of users from using the package
  is most likely blocking. Also, conceptual issues, like )R24 2 A(using
  compile/link options that should not be specified in
  )SM(buildfiles)ES()EA(, are always blocking. Finally, also consider
  whether it will be possible to fix the issue later without breaking
  backwards-compatibility. For example, renaming the package once it's
  published will be disruptive. If you are unsure whether an issue should be
  considered blocking, contact other reviewers to discuss.)EP(

  )0 P(A note or an issue can be communicated to the package author in two ways:
  you can add it to the outcome comment for the review issue \201created in the
  following step\202 or you can add it as a code review comment in the review
  PR.)EP(

  )0 P(The first way is more appropriate for general notes \201like the example
  above\202 and issues \201like missing )SM(README)ES( file\202. While code review
  comments work best when the issue is with a specific code fragment that can
  be pointed to.)EP(

  )0 P(To add code review comments, go to the review PR created in the previous
  step, select the "Files changed" tab, and start the code review. For each
  comment, specify whether it is a blocking issue, a non-blocking issue, or a
  note.)EP(

  )0 3 111 H(6.1.4)WB 234 Sn()WB 113 Sn( Add review outcome comment)EH(

  )0 P(Once you are done with the checklist, add a comment to the review issue
  with the outcome to notify the package author.)EP(

  )0 P(If the review was successful \201no blocking issues\202, start the comment with
  the following paragraph \201here )SM(<AUTHOR>)ES( is the package
  author's user name on GitHub\202:)EP(

  ) 4 68 PR(@<AUTHOR> Thank you for your submission! This version has passed the
review. Below you will find a list of non-blocking issues and notes
that have been identified during review. You can address the issues
with a revision if you wish or, alternatively, in the next version.)RP(

  )0 P(Adjust the last two sentences accordingly if there are no
  issues/notes.)EP(

  )0 P(If, however, there are blocking issues, start it with the following:)EP(

  ) 5 64 PR(@<AUTHOR> Thank you for your submission! Unfortunately there are
blocking issues and this version has failed the review. The list
of blocking issues is provided below. Please consider addressing
them \201as well as the non-blocking issues, if you wish\202 in a
revision and publishing it to continue this review.)RP(

  )0 P(Adjust the last sentence accordingly if there are no non-blocking
  issues.)EP(

  )0 P(Then continue the comment with a list of blocking issues, non-blocking
  issues, and finally notes \201remove sections that have no items\202:)EP(

  ) 11 20 PR(Blocking issues:

...

Non-blocking issues:

...

Notes:

...)RP(

  )0 P(If one or more issues or notes are captured as code review comments, then
  add a link to the review PR. Otherwise, describe them in the comment. For
  example \201here )SM(<NUM>)ES( is the review PR number\202:)EP(

  ) 15 73 PR(Blocking issues:

* A number of blocking issues described in the code review: #<NUM>

Non-blocking issues:

* A number of non-blocking issues described in the code review: #<NUM>

Notes:

* There is a file in Debian named ftest. It's not an executable installed
  in a PATH location so I guess having this library named without the
  lib prefix is technically allowed, though not ideal. Consider in the
  future to follow the recommendation in the packaging guide and name
  libraries with the lib prefix to sidestep such considerations.)RP(

  )0 3 112 H(6.1.5)WB 235 Sn()WB 114 Sn( Finish successful review)EH(

  )0 P(If the review is successful and once the outcome comment has been added,
  edit the issue description and remove the first sentence that says the
  review is in progress.)EP(

  )0 P(Also close \201note: not merge\202 the review PR and, if there are no
  non-blocking issues, the review issue.)EP(

  )BR(
  )0 P(If there are non-blocking issues, then we leave the review issue open as
  a reminder to the package author to address them in the next version.)EP(
  )BR(

  )0 P(Finally, send a notification email to )SM(review@cppget.org)ES( as
  described in )0 116 1 A(Send review notification
  email)116 0 TN TL()Ec /AF f D(.)EP(

  )0 3 113 H(6.1.6)WB 236 Sn()WB 115 Sn( Continue with unsuccessful review)EH(

  )0 P(If the review is unsuccessful and once the outcome comment has been
  added, send a notification email to )SM(review@cppget.org)ES( as
  described in )0 116 1 A(Send review notification
  email)116 0 TN TL()Ec /AF f D(.)EP(

  )0 P(Then wait for the package author to address blocking issues and publish a
  revision \201which will be reflected in the review PR\202. Also watch out for any
  questions in the review issue or code review comments in the PR.)EP(

  )0 P(Once the revision is published, re-review the relevant changes and
  confirm they address blocking issues. Check off any outstanding items in the
  review checklist and also note which non-blocking issues were addressed for
  the new outcome comment.)EP(

  )0 P(Then continue from the )0 113 1 A(Add review outcome
  comment)113 0 TN TL()Ec /AF f D( step by adding a new outcome comment. If all the blocking issues
  were addressed and no new blocking issues were identified, then the outcome
  is successful. Otherwise, it is unsuccessful and another review round is
  required: wait for another revision/comments, re-review, add another outcome
  comment, etc.)EP(

  )0 3 114 H(6.1.7)WB 237 Sn()WB 116 Sn( Send review notification email)EH(

  )0 P(In case of both successful and unsuccessful reviews, send an email to
  )SM(review@cppget.org)ES( in order to notify the )SM(build2)ES(
  core team about the outcome. The requirements for this email are as
  follows:)EP(

  )UL(  )-1 LI(The )SM(From)ES( field should contain your
  real name. Your review is a statement of oversight and without a real name
  it doesn't have much value.

  )-1 LI(The )SM(Subject)ES( filed should be in the
  following form:

  ) 1 26 PR(Review <PROJECT> <VERSION>)RP(

  )0 P(Here )SM(<PROJECT>)ES( is the project name to which the reviewed
  package or packages belong and )SM(<VERSION>)ES( is their version.
  Note that all the packages in a multi-package project must be reviewed
  together.)EP(

  )-1 LI(In the body of the email include the following
  information:

  )UL(  )-1 LI(List of packages reviewed.

  )-1 LI(Review outcome: )SM(pass)ES( or )SM(fail)ES(

  )-1 LI(Link to the outcome comment in the review issue.
  )LU(
  )LU(

  )0 P(For example:)EP(

  ) 14 68 PR(From: John Doe <john@example.org>
Subject: Review spdlog 1.14.1+2

Packages reviewed:

spdlog
spdlog-tests
spdlog-bench

Review outcome: fail

Outcome link:

https://github.com/build2-packaging/spdlog/issues/1#issuecomment-123)RP(

  )BR(
  )0 P(For a successful review of a new revision or version of an existing
  package that has no non-blocking issues or notes, there may be no review
  issue \201see )0 117 1 A(Reviewing new version submission)117 0 TN TL()Ec /AF f D(
  for details\202. In such cases the outcome link may be omitted.)EP(
  )BR(

  )BR(
  )0 P(The review outcome is recorded in the package metadata that is stored in
  the backing )SM(git)ES( repository. See )0 2 A(Package
  Review Manifest)EA( for details.)EP(
  )BR(

  )0 2 115 H(6.2)WB 238 Sn()WB 117 Sn( Reviewing new version submission)EH(

  )BR(
  )0 P(The following discussion assumes that you have read through )0 109 1 A(Reviewing initial package submission)109 0 TN TL()Ec /AF f D(.)EP(
  )BR(

  )0 P(The extent of changes to the build and packaging support in a new version
  can range from no changes, to only minor changes, to a complete rewrite. As
  a result, the review procedure for a new version varies depending on the
  changes and broadly consists of the following three alternatives:)EP(

  )4 OL(  )-1 LI(If there are no substantial changes and no issues \201blocking or
  non-blocking\202, then we can skip creating the review issue and go straight to
  the notification email.

  )-1 LI(If there are no substantial changes but there are issues \201blocking or
  non-blocking\202, then we create the review issue but skip the checklist.
  Creating the review PR is also optional.

  )-1 LI(If there are substantial changes then we should use the )0 109 1 A(Reviewing initial package submission)109 0 TN TL()Ec /AF f D( procedure to
  re-review the package from scratch with the checklist.
  )LO(

  )0 3 116 H(6.2.1)WB 239 Sn()WB 118 Sn( Determine the extent of changes)EH(

  )0 P(In order to select the appropriate review procedure we need to determine
  the extent of the changes in the new version compared to the previous
  version, which we will refer to as the "base version".)EP(

  )BR(
  )0 P(The previous version on which we are basing this review needs to be
  already reviewed. Failing that, reviewing the difference doesn't make much
  sense. If the immediately preceding version is not reviewed, you have two
  choices: either review it first or base your review on an earlier, already
  reviewed version. If its review is unsuccessful, then you will need to pay
  attention to the issues identified in the previous review.)EP(
  )BR(

  )0 P(The recommended next step is to get a sense of the changes by examining
  the difference between the base and the new versions. This can be done in
  several ways. You could clone the package repository locally and use your
  favorite )SM(git)ES( tool \201)SM(git-diff)ES(, )SM(gitk)ES(,
  etc\202 to view the cumulative changes between the two release commits.
  Alternatively, you can use the GitHub commit comparison support to compare
  the two release tags:)EP(

  ) 1 69 PR(https://github.com/build2-packaging/<project>/compare/v1.2.0...v1.3.0)RP(

  )BR(
  )0 P(Because the source code for the package comes from a )SM(git)ES(
  submodule, the changes that we see will be conveniently limited to the build
  and packaging support plus the related documentation.)EP(
  )BR(

  )0 P(Study the changes and determine which review procedure is appropriate.
  While all the consideration described in )0 109 1 A(Reviewing
  initial package submission)109 0 TN TL()Ec /AF f D( \201and its checklist\202 apply to new versions,
  additional attention must be paid to backwards compatibility. Unfortunately,
  it's not uncommon for inexperienced package authors to break backwards
  compatibility at the build level \201for example, by renaming exported targets,
  configuration variables, etc\202 even though the upstream respects its
  backwards compatibility obligations as signaled by the version.)EP(

  )0 P(The common case when reviewing a new version is no changes to the build
  and packaging support other than the version increment in
  )SM(manifest)ES(. If that's the case or you don't see any issues with
  other changes, then you can proceed directly to )0 116 1 A(Send review notification email)116 0 TN TL()Ec /AF f D(. In this case
  you can omit the outcome link.)EP(

  )BR(
  )0 P(Another common case that can use the same shortcut is when the upgrade to
  the new version was contributed as a PR by someone other than the package
  author. If such a PR was reviewed and merged by the package author, then
  this same review can also count as a package review and the package author
  can )0 116 1 A(Send review notification email)116 0 TN TL()Ec /AF f D( using
  the PR as the outcome link.)EP(
  )BR(

  )0 P(At the other, thankfully more rare, extreme you may find the package
  substantially changed or completely rewritten. This, for example, can happen
  in response to a major version release if upstream decides to re-architect
  their source code layout. But it can also be the result of more benign
  changes. For example, if upstream adds a dependency on a testing framework
  in its tests, then the )SM(build2)ES( package will need to split the
  tests into a separate package. In case of such substantial changes it is
  recommended to follow the )0 109 1 A(Reviewing initial package
  submission)109 0 TN TL()Ec /AF f D( procedure.)EP(

  )0 P(With the two extremes covered, this leaves the case of some changes that
  have issues, blocking or non-blocking. In this case the next step is to
  create the review issue.)EP(

  )0 3 117 H(6.2.2)WB 240 Sn()WB 119 Sn( Create review issue)EH(

  )0 P(If the changes in the new version have some issues, then we create the
  review issue on the package repository. The issue title should be in the
  following form \201here and below )SM(X.Y.Z)ES( is the version being
  reviewed\202:)EP(

  ) 1 29 PR(Review of the `X.Y.Z` version)RP(

  )BR(
  )0 P(Before actually creating the issue you may also want to check if someone
  else is already reviewing this package and thus has already created the
  issue. While there is nothing wrong with having multiple reviews, you may
  want to consider picking something else to review in order to increase
  coverage.)EP(
  )BR(

  )0 P(Unlike the initial package submission, here we don't use the review
  checklist since most items won't apply \201but you are welcome to refer to it
  if you like\202. Instead, you can put your feedback directly in the issue
  description, similar to )0 113 1 A(Add review outcome
  comment)113 0 TN TL()Ec /AF f D(.)EP(

  )0 P(If you find it helpful, you can also create a review pull request similar
  to )0 111 1 A(Create review pull request)111 0 TN TL()Ec /AF f D(. In this case
  use the base version's release commit as the starting commit for the review
  branch.)EP(

  )0 3 118 H(6.2.3)WB 241 Sn()WB 120 Sn( Finish successful review)EH(

  )0 P(If the review is successful \201no blocking issues\202, close \201note: not merge\202
  the review PR if one was created and, if there are no non-blocking issues,
  the review issue.)EP(

  )BR(
  )0 P(If there are non-blocking issues, then we leave the review issue open as
  a reminder to the package author to address them in the next version.)EP(
  )BR(

  )0 P(Finally, send a notification email to )SM(review@cppget.org)ES( as
  described in )0 116 1 A(Send review notification
  email)116 0 TN TL()Ec /AF f D(.)EP(

  )0 3 119 H(6.2.4)WB 242 Sn()WB 121 Sn( Continue with unsuccessful
  review)EH(

  )0 P(If the review is unsuccessful, send a notification email to
  )SM(review@cppget.org)ES( as described in )0 116 1 A(Send review notification email)116 0 TN TL()Ec /AF f D(.)EP(

  )0 P(Then wait for the package author to address blocking issues and publish a
  revision \201which will be reflected in the review PR, if any\202. Also watch out
  for any questions in the review issue or code review comments in the PR.)EP(

  )0 P(Once the revision is published, re-review the relevant changes and
  confirm they address blocking issues. Also note which non-blocking issues
  were addressed for the outcome comment.)EP(

  )0 P(Then continue from the )0 119 1 A(Create review
  issue)119 0 TN TL()Ec /AF f D( step except this time adding your feedback as an outcome comment
  rather than in the issue description. If all the blocking issues were
  addressed and no new blocking issues were identified, then the outcome is
  successful. Otherwise, it is unsuccessful and another review round is
  required: wait for another revision/comments, re-review, add another outcome
  comment, etc.)EP(

  )0 2 120 H(6.3)WB 243 Sn()WB 122 Sn( Reviewing new revision submission)EH(

  )0 P(The procedure for reviewing a new revision submission is essentially the
  same as )0 117 1 A(Reviewing new version submission)117 0 TN TL()Ec /AF f D(
  \201including sending the notification email\202. However, there are the
  additional requirement of the revision containing only minor changes and
  being strictly backwards-compatible with the version it replaces. See )0 91 1 A(Don't make extensive changes in a
  revision)91 0 TN TL()Ec /AF f D( for background and details.)EP(

)BR(

)WB NL
/TE t D NP /OU t D TU PM 1 eq and{/Pn () D showpage}if end restore
